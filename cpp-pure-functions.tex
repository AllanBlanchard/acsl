\section{Pure functions as logic functions}
As part of information hiding, programs often have utility functions that simply retrieve a value from a class field;
using the utility (`getter') function hides the actual representation of the concept the value returned by the function represents. 
The value returned may just be the value of an internal field or it may be the result of a more complex calculation.

It is often necessary to replicate such functions as logic functions. 
This is verbose and a maintenance burden. 
Accordingly, it is a convenience to, in some circumstances, 
allow a C function to be used as a logic function.

The key criterion for a C function to be allowed as a logic function is that the function be \textit{pure}, that is, that it have no side effects. 
Purity is judged by the conservative criterion that no assignments are made to any non-local variable; any functions that are called must also be pure.

Purity is indicated by including the keyword \lstinline|pure| in the function specification.
The intention to allow the function to be used in logic expressions is indicated by including the keyword \lstinline|logic| in the function specification.

If a function is \textit{pure}, it is an error for its specification to include any \lstinline|assigns| clause other than \lstinline|assigns \empty;| or \lstinline|assigns \nothing;|. 
If a behavior does not include an explicit \lstinline|assigns| clause, the implicit default is \lstinline|assigns \nothing|.

Purity is inherited. 
If a \textit{pure} function is virtual and overridden by a function in a derived class, the overriding function must also be \textit{pure}.

Note that such functions may have an implicit argument: the 
\lstinline|this| pointer to the class object.

An example is shown in the following listing: (TODO fix visibility)

\begin{listing-nonumber}
class C {
  private:
    int value;
        
  public:
    
    /*@ ensures \result == this->value;
      @ pure logic
      @*/
    int value() {
    	return value;
    }

}
\end{listing-nonumber}


\section{Inline functions}

\experimental

A second way to reduce verboseness and duplication between code and specifications is to use inlining. 
In this case the body of a function is used as its specification. When the function is called from elsewhere,
an analysis tool will effectively inline the body of the function at the call site (with appropriate replacement of formal arguments with actual arguments).

When inlining is desired, a function has no specification other than the keyword \lstinline|inline|, except perhaps also \lstinline|pure| and \lstinline|logic|.

Inlining may be a convenience; tools may even use it by default if there is no other specification. However, it should be used with caution:
\begin{itemize}
	\item An inlined function has no specification to be validated against its implementation, except in a calling context.
	\item The feature reduces modularity, because now a calling function depends on the body of a called function.
	\item It increases the effective size of the body of a calling function for analysis purposes.
\end{itemize}