\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage[a4paper=true,pdftex,colorlinks=true,urlcolor=blue,pdfstartview=FitH]{hyperref}

\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{amssymb}
\usepackage{graphicx}
%\usepackage{tikz}
\usepackage{color}
\usepackage{xspace}
\usepackage{makeidx}
%\usepackage{ulem}
\usepackage[leftbars]{changebar}
\usepackage{alltt}
\makeindex
\input{./macros}

\setlength{\textheight}{240mm}
\setlength{\topmargin}{-10mm}
\setlength{\textwidth}{160mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}

\renewcommand{\textfraction}{0.01}
\renewcommand{\topfraction}{0.99}
\renewcommand{\bottomfraction}{0.99}

\usepackage{fancyhdr}
\pagestyle{fancyplain}
\renewcommand{\footrulewidth}{0.4pt}
\addtolength{\headheight}{2pt}
\addtolength{\headwidth}{1cm}
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\chead{}
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\lfoot{\fancyplain{}{ANSI C Specification Language}}
\cfoot{}
\rfoot{\fancyplain{}{CAT RNTL project}}

\begin{document}
\sloppy
\hbadness=10000

\begin{titlepage}
\begin{center}
\includegraphics[height=14mm]{cealistlogo.jpg}
\hfill
\includegraphics[height=14mm]{inriasaclaylogo.png}

\vfill

%\includegraphics[height=60mm]{FramaC.jpg}
~

\vspace{20mm}

{\Huge\bfseries ACSL Mini-Tutorial}

\bigskip

\vspace{20mm}

{Virgile Prevosto$^1$}

\medskip

\begin{tabular}{l}
$^1$ CEA LIST, Software Security Laboratory, Saclay, F-91191 \\
\end{tabular}

\vfill

\begin{flushleft}
  This work has been supported by the 'CAT' ANR project
  (ANR-05-RNTL-0030x) and by the ANR CIFRE contract 2005/973.
\end{flushleft}

\end{center}
\end{titlepage}

\clearpage

\chapter{Foreword}
This document is a brief introduction to the ANSI/ISO C Specification
Language (ACSL). ACSL allows to formally specify the properties of a C
program, in order to be able to formally verify that the implementation
respects these properties. This verification is done \textit{via}
tools that are able to take into account ACSL annotations attached to
the C code. This tutorial focuses on the most important ACSL constructs
and gives an
intuitive grasp of their semantics, through short and illustrative
examples of C code annotated with ACSL formulas. A complete reference
of the ACSL language can be found in~\cite{ACSLref}. ACSL is inspired
from the specification language used by Caduceus~\cite{caduceus},
which is itself derived from the Java Modeling Language (JML, see~\cite{JML}).

\chapter{A First ACSL Example}
\label{chap:first-example}
The most important ACSL concept is the \textit{function
  contract}. A function contract for a C
function \verb+f+  is a set of
requirements over the arguments of
\verb+f+  and/or a set of properties
that are ensured at the end of the function.
The formula that expresses the requirements is called a {\em pre-condition},
whereas the formula that expresses the properties ensured when \verb|f|
returns is a {\em post-condition}.
Together, these conditions form a
contract between \verb+f+ and its callers: each caller must guarantee
that the pre-condition holds before calling \verb+f+. In exchange, \verb+f+
guarantees that the post-condition holds when it returns.

Let us consider the example of the \texttt{max} function. Informally, its
specification can be expressed this way: the function \texttt{max} takes two
\verb+int+ as arguments, and returns the greatest one. Let us see how
this can be expressed in ACSL:

\begin{c}
/*@ ensures \result >= x && \result >= y;
    ensures \result == x || \result == y;
*/
int max (int x, int y) { return (x > y) ? x : y; }
\end{c}

As can be seen above, ACSL annotations are written in special C
comments, the difference with plain comments being that annotations
begin with '\verb+/*@+'. It is also possible to
write one-line annotations introduced by '\verb+//@+'. The function
contract is written immediately above the function declaration.
In this example, the contract contains only post-conditions
(\verb+ensures+ clauses),
as \verb+max+ does not have any particular requirement.
%We could have
%added as a pre-condition the always-true formula, with the
%\verb+requires \true;+ clause, but this is not mandatory.
%Less trival \verb+requires+ clauses will be illustrated in the next examples.
The first \verb+ensures+ clause expresses the fact that the result
of \verb+max+ is greater than both \verb+x+ and \verb+y+, the arguments of
\verb+max+. The second clause mandates that the result is equal to either
\verb+x+ or \verb+y+. Since both clauses must hold, our ACSL
specification indeed expresses that the result of \texttt{max} is
the greatest of its two arguments.

It should be noted already that
there is an intuitive demarcation between ``complete'' and ``partial''
specifications. The above specification for \verb|max| can be thought
of as ``complete'', meaning that any function that satisfies the
specification should be deemed a satisfactory implementation for \verb|max|.
Partial specifications on the other hand express some of the properties that
are expected to hold for any implementation, but satisfying them is
not sufficient for an implementation to be satisfactory. Generally speaking,
partial formal specifications are the most likely to be encountered in
practice for real-life examples, complemented by informal specifications.
For instance, the above specification for \verb|max| is in fact
partial, for reasons that will become clearer later.

\chapter{Pointers and Arrays}
Now that we have specified a \verb+max+ function, we can use it to extract the
maximal value found in a sequence of \verb+int+s. A first step is to
write the prototype of the corresponding function with its
specification.

\section{Basic Specification}
\label{basic_max_seq}

\begin{c}
/*@ requires n > 0;
    requires \valid(p+ (0..n-1));
    ensures \forall int i; 0 <= i <= n-1 ==> \result >= p[i];
    ensures \exists int e; 0 <= e <= n-1 && \result == p[e];
*/
int max_seq(int* p, int n);
\end{c}

The function takes two arguments: a pointer \verb+p+ to the block containing
the \verb+int+s, and the number \verb+n+ of elements in the
sequence. This time, there are pre-conditions on these
arguments. First, it is not possible to compute the maximal value of an empty
sequence, and so \verb+n+ must be positive. Moreover, the block
pointed to by \verb+p+ must contain at least \verb+n+ elements. In
other words, \verb+p[0]+, \verb+p[1]+, ... \verb+p[n-1]+ must all be
valid memory accesses. This is what the second \verb+requires+ clause expresses.

The two \verb+ensures+ clauses display some similarities with
the contract of the \verb+max+ function above: the result
is greater than or equal to every value in the sequence, and there exists
an index for which the equality is attained. Note that the formulas in
the post-condition only make sense under the assumption that the
pre-condition holds: the validity condition ensures that it makes
sense to speak about \verb+p[i]+, and if \verb+n+ could be \verb+0+,
it would not be possible
to find an index where \verb+\result+ is attained.

\section{Advanced specification}
\noindent\emph{Note: This section can be skipped on a first reading}

In addition, a more advanced ACSL construction allows to provide a shorter
specification of \verb+max_seq+: \verb+\max+ is a built-in constructor
(together with \verb+\min+, \verb+\sum+, and a few others), that returns
the maximal value taken by a function in an interval of integers.
With \verb+\max+ and the \verb+\lambda+ construction to write
functions as first-class expressions, our specification becomes:
\begin{c}
/*@ requires n > 0 &&\valid(p + (0..n-1));
    ensures \result == \max(0,n-1,\lambda integer i; p[i]);
*/
int max_seq(int* p, int n);
\end{c}

\section{Implementation}

The implementation of the \verb+max_seq+ function is pretty
straightforward. For instance, we can use the following code.

\begin{c}
int max_seq(int* p, int n) {
  int res = *p;
  for(int i = 0; i < n; i++) {
    if (res < *p) { res = *p; }
    p++;
  }
  return res;
}
\end{c}
The specification we have given in the preceding section
defines an expected behavior for the function \verb+max_seq+.
We will see later in this document that actually verifying
that the function \verb+max_seq+ implements the specification
from the preceding section may require additional work.

\chapter{Assigns clauses}

The reader is invited at this point to pause and ponder the following
important question: is the above specification of the function \verb|max_seq|
a complete or partial one?

It may seem complete, because it takes great care in making
sure that \verb|n| is positive, and all the pointer accesses valid, and
it defines completely the expected result as the mathematical maximum
of the pointed values.
Still, there is a loophole that would allow a function to
implement this specification by the letter without being
what the specifier probably expected. Indeed, an implementation for
\verb|max_seq| could zero all the locations
\verb|p[0]|,\verb|p[1]|,\ldots,\verb|p[n-1]|, return zero,
and would still satisfy the post-conditions in the specification from
section \ref{basic_max_seq}.

The loophole is that the post-condition constrains the result of the function
to be the maximum of the pointed values {\em at the time the function
{\tt max\_seq} returns}. We should have specified that we expected
the returned result to be the maximum of the pointed values as they
were when the function was called. This can be written:


\begin{c}
/*@ requires n > 0;
    requires \valid(p+ (0..n-1));
    ensures \forall int i; 0 <= i <= n-1 ==> \result >= \old(p[i]);
    ensures \exists int e; 0 <= e <= n-1 && \result == \old(p[e]);
*/
int max_seq(int* p, int n);
\end{c}

The \verb+\old+ keyword does exactly what we intended: instead of
evaluating \verb+p[i]+ and \verb+p[e]+ at the time the function
returns, these expressions evaluate to the value they had when the
function was called.
Better yet, we should have expressed that we did not expect
\verb|max_seq| to modify any variable in memory other that its
locals, and in particular not \verb|p[0]|,\verb|p[1]|,\ldots,\verb|p[n-1]|.
The latter condition can be expressed in an additional post-condition,
using the \verb+\old+ construct that was just introduced:

\begin{c}
/*@ requires n > 0;
    requires \valid(p+ (0..n-1));
    ensures \forall int i; 0 <= i <= n-1 ==> p[i] == \old(p[i])|
    ensures \forall int i; 0 <= i <= n-1 ==> \result >= p[i];
    ensures \exists int e; 0 <= e <= n-1 && \result == p[e];
*/
int max_seq(int* p, int n);
\end{c}

Note that in the other two post-conditions, \verb+\old+ is not needed
anymore, since the first post-condition guarantees that the locations
pointed to by \verb+p+ are not modified by the \verb+max_seq+ function.

It would be possible, but tedious, to use the same approach to
specify that global variables do not change during the execution
of \verb|max_seq|.
The ACSL language provides a special clause to specify that a
function is not allowed to change memory locations other than
the ones explicitly listed. This clause is the \verb+assigns+ clause,
and it is part of the function contract. When no \verb|assigns| clauses
are specified, the function is allowed to modify every visible variable.
In presence of such clauses,
the function can only modify the content of the locations
that are explicitly mentioned in these clauses. In our case, we do not
expect \verb+max_seq+ to have any visible side-effect, so that the contract
becomes:
\begin{c}
/*@ requires n > 0;
    requires \valid(p+ (0..n-1));
    assigns \nothing;
    ensures \forall int i; 0 <= i <= n-1 ==> \result >= p[i];
    ensures \exists int e; 0 <= e <= n-1 && \result == p[e];
*/
int max_seq(int* p, int n);
\end{c}
Again, it is not necessary to use \verb+\old+ for the values of
the expressions \verb+p[i]+ and \verb+p[e]+ in the the post-conditions,
since the specification forces them to stay unchanged during the execution of
\verb+max_seq+.

An example of a function with a non-empty \verb|assign| clause is the
swap function below, which exchange the content of two pointers to integers.
\begin{c}
/*@
requires \valid(p) && \valid(q);
assigns *p, *q;
*/
void swap (int *p, int *q) { int tmp = *p; *p=*q; *q = tmp; return; }
\end{c}

The specification of the \verb|swap| function given above is partial.
Transforming it into a complete
specification by adding a post-condition is left as an exercise for the reader.

\chapter{Termination}

There is yet another property that is implicitely expected from
a satisfactory implementation of \verb|max_seq|. Namely,
this function, when called with arguments that satisfy its pre-conditions,
should eventually terminate (and return a result that satisfies
its post-conditions). The \verb|assigns| clause in itself
only guarantees that each time the function terminates, only the
specified locations may have been modified. Similarly, the
post-conditions only apply when the function terminates, and so
a function that never terminates would for instance satisfy the
\verb|assigns| and \verb|ensures| parts of the specification
for \verb|max_seq|. The termination of the function is a separate
property that can be specified in its contract using the
\verb|terminates| clause.

Because in practice many functions are implicitely expected to terminate,
the default in ACSL is to expect functions to terminate in all the contexts
that satisfy their pre-conditions. It is possible to relax a particular
function's specification by providing a formula that describes
the conditions in which the function is guaranteed to terminate.
An implementation is then allowed not to terminate when it is called
in contexts that do not satisfy this condition.

In the following example, the function \verb|f| can be called with
any argument \verb|c|, but the function is not guaranteed to terminate
if \verb|c<=0|.
\begin{c}
/*@
assigns \nothing;
terminates c>0;
*/
void f (int c) { while(!c); return;}
\end{c}

Another valid contract for the same implementation of \verb|f| is
the following one, where the function implicitely guarantees to terminate
whenever it is called, but expects to be called only with
non-zero arguments.
\begin{c}
/*@
assigns \nothing;
requires c!=0;
*/
void f (int c) { while(!c); return;}
\end{c}

\chapter{Behaviors}
The functions that we have seen so far had a quite simple
specification. In particular, their post-conditions were simple
relations. Specifications may be more complicated. Take for instance
the following \verb|extremum| function, which computes either the
maximum or the minimum of its \verb|int| arguments depending on the
\verb|kind| which is passed to it:

\begin{c}
typedef enum { Max, Min } kind;
int extremum (kind k, int x, int y) {
  return ((k == Max ? x > y : x < y) ? x: y);
}
\end{c}

What could be a complete specification of \verb|extremum|? First, we
should require that \verb|k| is either \verb|Max| or \verb|Min|. Then,
as for \verb|max|, the result is either \verb|x| or \verb|y|. More
precisely, if \verb|k| is equal to \verb|Max| then the result is the
greatest one, and if \verb|k| is equal to \verb|Min|, then the result
is the smallest one. All of this can be summed up in the following
ACSL contract:

\begin{c}
/*@ requires k == Max || k == Min;
    assigns \nothing;
    ensures \result == x || \result == y;
    ensures k == Max ==> \result >= x && \result >= y;
    ensures k == Min ==> \result <= x && \result <= y;
*/
int extremum (kind k, int x, int y);
\end{c}

However, this might not be the clearest way to express this
specification. Namely, we would like to say that \verb|extremum| has
two distinct modes of operation. These are called \emph{behaviors} in
ACSL. A function can have several behaviors in addition to a general
specification. A behavior can have additional \verb|assigns| and
\verb|ensures| clauses, but in addition, it can also have
\verb|assumes| clauses, which indicate when the behavior is triggered.

In our case, the first three clauses of the contract remain the same,
but the last two post-conditions can be expressed as two behaviors,
\verb|is_max| and \verb|is_min|, whose \verb|assume| clauses are
respectively \verb|k==Max| and \verb|k==Min|. In addition, we would
like to state that \verb|is_min| and \verb|is_max| describes
completely the set of behaviors of the function, and that they are
mutually exclusive. This is done by the \verb|complete_behaviors| and
the \verb|disjoint_behaviors| clauses respectively.
\begin{c}
/*@ requires k == Max || k == Min;
    assigns \nothing;
    ensures \result == x || \result == y;
    behavior is_max:
      assumes k == Max;
      ensures \result >= x && \result >= y;
    behavior is_min:
      assumes k == Min;
      ensures \result <= x && \result <= y;
    complete_behaviors is_max, is_min;
    disjoint_behaviors is_max, is_min;
*/
int extremum (kind k, int x, int y);
\end{c}

\chapter{Predicates and Logic Functions}

So far, we have only used logical built-ins operators and relations.
It is often needed to define new logic predicates and logic
functions. For instance, if we define (simply) linked lists as such:
\begin{c}
  typedef struct _list { int element; struct _list* next; } list;
\end{c}

there are some common properties of lists that we want to be able to
deal with in the logic. In particular, the notion of reachability (can
a given node be attained from some root through a chain of \verb|next|
fields) plays an important role. It can be defined in ACSL through the
following annotation:
\begin{c}
  /*@ predicate reachable(list* root, list* node) =
        root == node ||
        \valid(root) && reachable(root -> next, node);
    */
\end{c}

We define a binary predicate over lists, which holds when the two
pointers are equal or, if the pointer \verb|root| is valid, when \verb|node|
can be proved reachable from \verb|root->next|. In addition, this
predicate can be used to discriminate between circular and
finite lists: in a finite list, we will ultimately reach
\verb|\null|;

\begin{c}
  /*@ predicate finite(list* root) = reachable(root,\null); */
\end{c}

Similarly, we can define a logical function computing the length of a
\verb|\null| terminated list. This time, we have to avoid circular
lists, since the notion of length has little meaning for them. But
logical functions are \emph{total}, {\it i.e.} they always return a
value. A possible way to overcome this issue is to use an axiomatic
definition for \verb|length|:
\begin{c}
  /*@ logic integer length(list* l); */

  /*@ axiom length_nil: length(\null) == 0; */

  /*@ axiom length_cons:
        \forall list* l, integer n;
          finite(l) && \valid(l) ==>
            length(l) == length(l->next) + 1
   */
\end{c}
This way, it is possible to speak about \verb|length(l)| for any list
\verb|l|, but if \verb|l| is circular, the value of this expression
will remain undefined: the only way to prove that \verb|length(l)==n|
for a given \verb|n| is to prove first \verb|finite(l)|.

Now that we know how to define logic predicates and logic functions,
we can go back to our maximum example, this time on (finite) lists. A
possible specification for \verb|max_list| would be the following:
\begin{c}
  /*@
      requires \valid(l);
      assigns \nothing;
      terminates finite(root);
      ensures
       \forall list* l;
         \valid(l) && reachable(root,l) ==>
           \result >= l->element;
      ensures
       \exists list* l;
         \valid(l) && reachable(root,l) && \result == l->element;
  */
  int max_list(list* root);
\end{c}
As with arrays, we have as pre-condition that the list is non-empty.
The post-conditions are also quite similar to the ones of \verb|max_array|,
except that indices have been replaced by the reachability of the node
from the root of the list. In addition, we find a \verb|terminates|
clause, that indicates that the implementation may loop forever on
circular lists (but could choose not to, even though this would imply
an huge overhead in this setting). A possible implementation is thus
the following:
\begin{c}
  int max_list(list* root) {
    int max = root->element;
    while(root->next) {
      root = root -> next;
      if (root->element > max) max = root->element;
    }
    return max;
  }
\end{c}

%\chapter{Types Invariants}

\chapter{Verification activities}

The preceding examples have shown us how to write the specification of
a C function in ACSL. However, at verification time,
it can be necessary to write additional annotations in the
implementation itself in order to guide the analyzers.
In particular, loops are often problematic for automatic tools, and
we may attempt to help them by providing
an {\em invariant} for each loop. A loop invariant is
a property that is preserved across the loop body. In this case, a
useful invariant for proving that the implementation satisfies the
formal specification would be that \verb+res+ contains the maximal value seen
so far.

Let us now try to formalize this invariant property.
Part of the formal invariant that we are trying to build
is that at any iteration \verb|j|, the variable \verb|res| is greater or
equal to \verb|p[0]|,\verb|p[1]|,\ldots,\verb|p[j]|.
This part of the invariant is written:
\begin{c}
int max_seq(int* p, int n) {
  int res = *p;
  //@ loop invariant \forall integer j; 0 <= j <= i ==> res >= *(p+j);
  for(int i = 0; i < n; i++) {
    if (res < *p) { res = *p; }
    p++;
  }
  return res;
}
\end{c}

The other part of the invariant property that should be expressed
formally is that there exists an element in
\verb|p[0]|,\verb|p[1]|,\ldots,\verb|p[n-1]| that is equal to
\verb|res|. In other words, this second part expresses that there
exists an integer \verb|e| such that \verb|0 <= e < n| and
\verb|p[e] == res|.  In order to prove the existence of such an
integer~\verb|e|, the simplest way is to keep track of the index for
which the maximal value is attained. This can be done in ACSL with
extra statements called {\em ghost code}.  Ghost code is C code
written inside \verb|//@ ghost ..| or \verb|/*@ ghost .. */|
comments. The original program must have exactly the same behavior
with and without ghost code. In other word,
ghost code must not interfere with the concrete
implementation. The variables defined and assigned in ghost code ({\em
  ghost variables}) can be used in the ACSL properties.

The complete annotated function \verb|max_seq| then becomes:

\begin{c}
int max_seq(int* p, int n) {
  int res = *p;
  //@ ghost int e = 0;
  /*@ loop invariant \forall integer j; 0 <= j <= i ==> res >= p[j];
      loop invariant \valid(p+e) && p[e] == res;
  */
  for(int i = 0; i < n; i++) {
    if (res < *p) {
      res = *p;
      //@ ghost e = i;
    }
    p++;
  }
  return res;
}
\end{c}


\bibliographystyle{plain}
\bibliography{mini-biblio}

\end{document}
Local Variables:
mode: latex
End:
