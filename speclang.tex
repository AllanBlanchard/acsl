
\chapter{Specification language}
\label{chap:base}

\section{Logic expressions}
\label{sec:expressions}

This first section presents the language of expressions one can use in
the annotations. These are called below \emph{logic expressions}. They
corresponds more or less to pure C expressions, without function
calls, with additional constructs that we introduce one at a time.

\begin{figure}[p]
  \fbox{\begin{minipage}{0.97\textwidth} \input{term.bnf}
    \end{minipage}}
  \caption{Grammar of terms and predicates}
\label{fig:gram:term}
\end{figure}

Figure~\ref{fig:gram:term} presents the grammar for logic expressions.
In that grammar, we distinguish between \emph{predicates} and
\emph{terms}, following the usual distinction between propositions and
terms in classical multi-sorted first-order logic.


The additional constructs are as follows:
\begin{itemize}
\item C operators \verb|&&|, \verb+||+ and \verb|!| are used as
  logical connectives. There are additional connectives \verb|==>| for
  implication, \verb|<==>| for equivalence, \verb|^^| for exclusive
  or.

\item Quantifications: universal $\Forall \tau x; e$ and existential
  $\Exists \tau x; e$

\item Local naming $\Let x = e_1 ; e_2$ introduce the name $x$ for
  expression $e_1$ which can be used in expression $e_2$.

\item conditional $\If c \Then e_1 \Else e_2$. There is a subtlety
  here: the condition may be either a boolean term or a predicate.  In
  case of a predicate, the two branches must be also predicates, so
  that this construct acts as a connective with the following
  semantics: $\If c \Then e_1 \Else e_2$ is equivalent to $(c
  \verb|==>| e_1) \verb|&&| (\verb|!| c \verb|==>| e_2)$

\item syntactic naming: $id \verb|::| e$ is a term or a predicate
  equivalent to $e$. It is different from local naming with $\Let$:
  the name cannot be reused in other terms of predicates. It is only
  for tools purposes.

\item The construct $t_1~relop_1~t_2~relop_2~t_3 \cdots t_k$ is a
  shortcut for $t_1~relop_1~t_2 ~\verb|&&|~ t_2~relop_2~t_3
  ~\verb|&&|~ \cdots $.

\item Function and predicate application are not applications of C functions, but of logic functions or predicates: see Section~\ref{sec:logicspec}
\end{itemize}

\subsection{Semantics, typing}

always defined (2-valued logic). Distinction entre booleens et
predicats.  TODO: referer aux travaux de P Chalin ? 
Donner des examples

on veut la logique equationnelle classique, cad que l'axiome
\[
\forall x, x=x
\]
est valide. Donc on ne peut pas introduire de construction
non-déterministe comme  $(\texttt{any} x \mid P)$


Types de la logique (see Section~\ref{sec:logicspec}:
\begin{itemize}
\item types mathematiques: real, integer, boolean
\item types du C
\item types logiques introduits par l'utilisateur
\end{itemize}

Typing rules: TODO

\section{Function contracts}
\label{sec:fn-behavior}



\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\textwidth}
      \input{fn_behavior.bnf}
    \end{minipage}}
    \caption{Grammar of function contracts}
  \label{fig:gram:contracts}
\end{figure}

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\textwidth}
      \input{oldandresult.bnf}
    \end{minipage}}
    \caption{\old and \result in terms}
  \label{fig:gram:oldandresult}
\end{figure}



The Figure~\ref{fig:gram:contracts} show a grammar for the function
contracts. The grammars for non-terminal locations is given later,
informally, they denotes C l-values. We also introduce additional constructs 
for terms as given on figure~\ref{fig:gram:oldandresult}. These are the following:
\begin{itemize}
\item $\old(e)$ denotes the value of $e$ in the pre-state of the function. 
\item \result{} denotes the returned value of the function.
\end{itemize}


They both can be used only in \ensures{} clauses.


\remark{Patrick}{pourquoi seuls les ``behavior'' peuvent avoir un
  nom~? Ne peut-t'on pas avoir le ``ident:'' optionnel pour chacune
  des clauses~? Claude: parce que le nommage de behavior doit servir
  pour les associer a des clauses du corps de la fonction, p. ex.
  assert ou lopp invariant. Mais on peut aussi proposer par ailleurs
  de nommer des predicate ou terms, p. ex. avec la notation Caduceus
  (id :: f) }

\subsection{Simple function contracts}

A simple function contract, having no named behavior, as the following
form:
\begin{flushleft}\ttfamily
/*@ requires $P_1$; \\
~~@ requires $P_2$; \\
~~@ assumes $A_1$; \\
~~@ assumes $A_2$; \\
~~@ assigns $L_1$; \\
~~@ assigns $L_2$; \\
~~@ ensures $E_1$; \\
~~@ ensures $E_2$; \\
~~@ decreases $m$ for $R$; \\
~~@r*/
\end{flushleft}

The semantics of such a contract is as follows:
\begin{itemize}
\item The caller of the function must guarantee that it is called in a
  state where the property $P_1 \verb|&&| P_2$ holds.
\item The called function returns a state where the property
  $\old(A_1) \verb|&&| \old(A_2) \verb|==>| E_1 \verb|&&| E_2$ holds. 
\item If the function is called in a pre-state where
  $A_1 \verb|&&| A_2$ holds, then all memory locations of that
  pre-state that do not belong to the set $L_1 \cup L_2$ remain allocated
  and are left unchanged in the post-state.
\item If the decreases clause is present, the function can call only
  functions (including itself) which have also a decreases clause with
  the same relation $R$, which are called in a state for which the
  measure expression $m$ is smaller.
\end{itemize}

Notice that the \assumes{} clauses, and the multiplicity of clauses in
general, are proposed mainly to improve readibility (and to avoid \old and
some duplications of formulas), since the contract above is equivalent
to the following simplified one:
\begin{flushleft}\ttfamily
/*@ requires $P_1 \verb|&&| P_2$; \\
~~@ assigns $L_1,L_2$; \\
~~@ ensures $\old(A_1) \verb|&&| \old(A_2) \verb|==>| E_1 \verb|&&| E_2$; \\
~~@ decreases $m$ for $R$; \\
~~@*/ 
\end{flushleft}

\begin{example}
The following function is given a simple contract for computation of integer square root, rounded to the floor.
\input{isqrt.pp}

The contract means that the function must not be called with a
negative argument, and in return the result satisfies the conjunction
of the three predicates given in \ensures{} clauses.
\end{example}

\begin{example}
The following function is given a contract to specify it increments the value pointed by the pointer given as argument.
\input{incrstar.pp}

The contract means that the function must be called with a pointer $p$
that points to a safely allocated memory location (See
Section~\ref{sec:pointers} for details on $\valid$ built-in predicate). It
modifies only the value pointed by $p$, and more precisely it
increments it by one.
\end{example}


\subsection{Contracts with named behaviors}

More generally, a function contract as the following form with named
behaviors (restricted to two behaviors for readability):
\begin{flushleft}\ttfamily
/*@ requires $P$; \\
~~@ behavior $b_1$: \\
~~@ ~~requires $R_1$; \\
~~@ ~~assumes $A_1$; \\
~~@ ~~assigns $L_1$; \\
~~@ ~~ensures $E_1$; \\
~~@ behavior $b_2$:  \\
~~@ ~~requires $R_2$;  \\
~~@ ~~assumes $A_2$; \\
~~@ ~~assigns $L_2$; \\
~~@ ~~ensures $E_2$; \\
~~@ decreases $m$ for $R$; \\
~~@r*/
\end{flushleft}

The semantics of such a contract is as follows:
\begin{itemize}
\item The caller of the function must guarantee that it is called in a
  state where the property $P \verb|&&| (R_1 \verb+||+ R_2)$
  holds.
\item The called function returns a state where the properties
  $\old(R_i) \verb|&&| \old(A_i) \verb|==>| E_i$ hold for each $i$.
\item for each $i$, if the function is called in a pre-state where
  $R_i \verb|&&| A_i$ holds, then all memory locations of that
  pre-state that do not belong to the set $L_i$ remain allocated
  are left unchanged in the post-state.
\item If the decreases clause is present, the function can call only
  functions (including itself) which has also a decreases clause with
  the same relation $R$, which are called in a state for which the
  measure expression $m$ is smaller.
\end{itemize}

Notice that the assumes clauses and the requires clause in the
behaviors are proposed mainly to improve readibility (to avoid \old
and some duplications of formulas), since the contract above is
equivalent to the following simplified one:
\begin{flushleft}\ttfamily
/*@ requires $P_1$ \&\& $P_2$ \&\& ($R_1$ || $R_2$); \\
~~@ behavior $b_1$: \\
~~@ ~~assigns $L_1$; \\
~~@ ~~ensures \old($R_1$) \&\& \old($A_1$) ==> $E_1$ \\
~~@ behavior $b_2$:  \\ 
~~@ ~~assigns $L_2$; \\
~~@ ~~ensures \old($R_2$) \&\& \old($A_2$) ==> $E_2$; \\
~~@ decreases $m$ for $R$; \\
~~@*/ 
\end{flushleft}


\begin{example}
In the following, \texttt{bsearch($t,n,v$)} searches for element $v$ in array $t$ between index $0$ and $n-1$.
\input{bsearch.pp}

The intention is to perform a binary search, which requires that the
array $t$ is sorted in increasing order: this is the purpose of the
predicate named \texttt{t\_is\_sorted} in the precondition. The
remaining of the precondition is to require that the array is safely
allocated for at least the index from $0$ to $n-1$. The two named
behaviors correspond respectively to the succesful behavior and the
failing behavior.

See~\ref{sec:loop_invariant} for a continuation of this example.
\end{example}

\begin{example}
  The following function illustrates the importance of different
  \assigns{} clauses for each behavior.  

  \input{cond_assigns.pp} 

  Its contract means that it assigns values pointed by $p$ or by $q$,
  conditionally on the sign of $n$.
\end{example}


\subsection{Remarks}

\remark{Yannick}{JML propose deux modes de spécification des fonctions~:
 soit à base de ``requires'' et ``ensures'', soit à base de
 ``behavior''. JML n'a pas de ``assumes'' dans les
  ``behaviors'', mais des ``requires''. Dans le cas où les deux modes
  peuvent se combiner, la sémantique est la suivante~:}

\begin{verbatim}
  requires P_1
  requires P_2
  ensures  Q_1
  ensures  Q_2
  behavior x_1: requires R_1 ensures E_1
  behavior x_2: requires R_2 ensures E_2
\end{verbatim}


\begin{verbatim}
 pre-condition : P_1 and P_2
             and (R_1 or R_2)
 post-condition: Q_1 and Q_2
             and (\old(R_1) implies E_1)
             and (\old(R_2) implies E_2)
\end{verbatim}

\remark{Patrick}{les ``behavior'' de JML présente l'avantage de
  pouvoir spécifier une fonction par cas (non exclusifs)
  et de vérifier que les cas d'appel sont spécifiés (sinon on ne peut
  vérifier la pré-condition).
  Il semble important à Airbus de pouvoir s'assurer qu'ils ont
  énoncé l'ensemble des cas.}

\remark{Yannick}{avoir ``requires'' en plus des ``assumes'' dans les
  ``behaviors'' semble utile :
la sémantique consiste à rajouter $(A_i \ra R_i)$ en conjonction de la
précondition globale}

\begin{verbatim}
  requires P_1
  requires P_2
  ensures  Q_1
  ensures  Q_2
  behavior x_1: requires R_1 assumes A_1 ensures E_1
  behavior x_2: requires R_2 assumes A_2 ensures E_2
\end{verbatim}


\begin{verbatim}
 pre-condition : P_1 and P_2
             and (A_1 implies R_1)
             and (A_2 implies R_2)
 post-condition: Q_1 and Q_2
             and (\old(A_1) implies E_1)
             and (\old(A_2) implies E_2)
\end{verbatim}

\subsection{Memory locations}
\label{sec:locations}

There are several places where one needs to describe a set of memory locations: \assigns{} clauses, \reads{} clauses.

\begin{figure}
  \fbox{\begin{minipage}{0.97\textwidth}
      \input{loc.bnf}  
    \end{minipage}}
  \caption{Grammar for memory locations}
\label{fig:gram:locations}
\end{figure}

The grammar for denoting such a set of memory locations is given
Figure~\ref{fig:gram:locations}.

The semantics is given as follows, where $s$ denotes any tset:
\begin{itemize}
\item a simple term denotes a singleton
\item $s\ra id$ denotes the set of $x\ra id$ for each $x \in s$
\item $s.id$ denotes the set of $x.id$ for each $x \in s$
\item $*s$ denotes the set of $*x$ for each x in s
\item $s_1[s_2]$ denotes the set of $x_1[x_2]$ for each $x_1 \in s_1$
  and $x_2 \in s_2$
\item $t_1 .. t_2$ denotes the set of integers between $t_1$ and
  $t_2$, included
\item $s_1,s_2$ denotes the union of $s_1$ and $s_2$
\item $s_1+s_2$ denotes the set of $x_1+x_2$ for each $x_1 in s_1$ and $x_2 in s_2$
\item $(s)$ denotes the same set as $s$
\item $\{ s \mid b ; P \}$ denotes set comprehension: set of term denoted by $s$ for each values of binders satisfying predicate $P$. Binders $b$ are bound in $s$ and $P$
\end{itemize}

A \emph{location} is any set of terms denoting a set of lvalues.
Only locations are valid as argument to \assigns{} clauses

Examples:
\input{assigns.pp}

\remark{Patrick}{ne faut-t'il pas étendre les clauses ``assigns'' aux
  clauses ``from'' de CAVEAT prenant en comptes les locations lues, et les
  expressions fonctionnelles~?}

\subsection{Typing rules}

Two judgements:
\begin{itemize}
\item $\Gamma,\Lambda \vdash e : loc \tau$ means e is a set of location of type
  $tau$
\item $\Gamma,\Lambda \vdash e : tset \tau$ means e is a set of terms of type
  $tau$
\end{itemize}
$\Gamma$ is the C environment and $\Lambda$ is the logic environment.

Rules:
\[
\frac{\vdash e:loc \tau}{\vdash e: tset \tau}
\]
\[
\frac{\tau x \in \Gamma}{\vdash x: loc \tau}
\]
\[
\frac{e:tset \tau*}{\vdash *e: loc \tau}
\]
\[
\frac{e_1:tset \tau \quad e_2:tset \tau}{\vdash e_1,e_2: \tau}
\]
\[
\frac{e: tset struct S* \quad e_2:tset \tau}{\vdash e->f : loc \tau}
\]
\[
\frac{b\cup \Lambda \vdash e: tset \tau}{\vdash \{ e \mid b ; P \} : tset \tau }
\]
idem for $loc \tau$

Notes:
\begin{itemize}
\item Quantification can be be made over any type (both C and
  logic types).
\item Quantification over pointers, structures, union, etc.
  are possible too. TODO: the meaning must be carefully defined.
\end{itemize}

\section{Statement annotations}


  \begin{itemize}
  \item \assert, label
    \remark{claude}{permettre de nommer les asserts}
  \item loop invariants (+loop assigns ?)
  \item block behaviors (normal termination only, no goto going
    inside, no goto going outside)
  \end{itemize}

\subsection{Assertions and logical labels} 

\begin{syntax}
  statement ::= "/*@" logical-label "*/" statement \
  logical-label ::= "label" id: ;
  | "assert" pred ";" ;
  | "assert" id ":" pred ";" ;
  | "assert" "for" id ":" pred ";" ;
\end{syntax}

The \texttt{label} id annotation simply allows one to refer to the value of some expression $e$ in the state before the statement, in further annotations, using the constructs \at(e,id)

The \texttt{assert} p clause means that p must hold in the state
before the statement.

The last two constructs allows to give a name to the assertion. In the
case \texttt{assert for} id, id must be a behavior identifier for the
current function. It means that this assertion is meant to be valid
only for the considered behavior.

\remark{Claude}{unifier les 2 derniers cas? car a-t-on besoin de
  nommer un assert en dehors d'un behavior de la fonction?}



TODO: $\at(e,label)$


\subsection{Statement contracts}

TODO

\subsection{Loop annotations}
\label{sec:loop_invariant}

TODO

semantics of loop invariants: in particular for {\tt for} loops

\begin{syntax}
  invariant-clause ::= "loop" "invariant" predicate \
\end{syntax}

loop assigns: semantics?


\section{Pointers and physical adressing}
\label{sec:pointers}

\subsection{Memory blocks and pointer dereferencing}

\begin{itemize}
\item \baseaddr{} base address of an allocated pointer
\[
\baseaddr{} : \alpha {\tt *} \ra {\tt char *}
\]
\item \blocklength{} length of the allocated block of a pointer
\[
\blocklength{} : \alpha {\tt *} \ra {\tt size\_t}
\]

\end{itemize}

Shortcuts:
\begin{itemize}
\item offset(p) returns the offset between p ans its base address

  \begin{eqnarray*}
    offset &:& \alpha {\tt *} \ra {\tt size\_t}  \\
    offset(p) &=& (char*)p - \baseaddr(p)
  \end{eqnarray*}

\item valid(p) tells whether dereferencing p is safe

  \begin{eqnarray*}
    valid : \alpha {\tt *} \ra {\tt boolean} \\
    valid(p) = offset(p) \geq 0 \land offset(p) + sizeof(*p) \leq \blocklength(p)
  \end{eqnarray*}

\item \comparable{} (checks whether two pointers are comparable as defined
  in the ANSI standard: TODO by benjamin)
\[
\comparable{} : \alpha {\tt *} \ra \beta {\tt *} \ra {\tt boolean}
\]
\end{itemize}


\subsection{Separation}

pointer separation :
\[
p \not\equiv q := \baseaddr(p) \neq \baseaddr(q) \lor |(char*)p - (char*)q| \geq \max(\sizeof(p),\sizeof(q))
\]

$\separated(loc1,..,loc_n)$ : means that for if $i\neq j$, if $x\in loc_i$ and $y \in loc_j$ then $\&x \not\equiv \& y$

where each $loc_i$ is a set of memory location as defined in Section~\ref{sec:locations}.

\subsection{Allocation and deallocation}

\experimental

\begin{itemize}
\item built-in predicate \fresh, specifying in a post-condition that a
  pointer was not allocated in the pre-state.
 
\item built-in predicate \freed, specifying in a post-condition that a
  pointer was allocated in the pre-state but not anymore.
\end{itemize}

\section{Termination}

Property of termination concerns both loops and recursive function calls. 
For that purpose, loops can be annotated with \emph{loop variants}\index{loop variant}, and functions can be annotated with such variants too.

\subsection{integer measures}

For loops:
\begin{syntax}
variant-clause ::= "loop variant" e 
\end{syntax}

For functions:
\begin{syntax}
decreases-clause ::= "decreases" e 
\end{syntax}
where $e$ has type integer

\subsection{general measures}

More general case of measures on other types: use the keyword for:

\begin{syntax}
variant-clause ::= "loop variant" e "for" id \
decreases-clause ::= "decreases" e "for" id
\end{syntax}

where $e$ has type $\tau$ and $id$ is a logic predicate of type $\tau,\tau \ra
prop$ (see Section~\ref{sec:logicspec}


\section{Logic specifications}
\label{sec:logicspec}

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth} \input{logic.bnf}
    \end{minipage}}  
  \caption{Grammar for logic declarations}
\label{fig:gram:logic}
\end{figure}

\begin{itemize}
\item logic specifications: introduction of new logic types,
  constants, functions, predicates and axioms.

logic types can be polymorphic: for example
\input{listdecl.pp}

\item recursive definitions: are allowed in logic function and predicate definitions. Example:  
  \input{max_index.pp}

mutual recursion

\item predefined logic specifications can be provided as libraries (see section~\ref{sec:speclibraries}, and imported using
\input{import.pp}

\item higher-order functions: $\lambda$, \Sum, \Max, \numof
\item {\tt enum}, recursive types


\item hybrid functions and predicates: take both C types and logic
  types as arguments.
\item model variables
\end{itemize}


\section{Abnormal termination}

\begin{itemize}
\item C function \verb|exit(n)|. special behavior notation
  \begin{verbatim}
    exit_behavior
       assumes
       assigns
       ensures ...
  \end{verbatim}
    where in ensures clause, \result is bound to n
\end{itemize}


\section{Dependencies information}

\experimental

\begin{verbatim}
assigns Locs from Locs
\end{verbatim}

\section{Functional expressions}

\experimental

trouver une syntaxe pour introduire les noms des fonctions implicites
derriere la construction
\begin{verbatim}
assigns Locs from Locs
\end{verbatim}

\section{Data invariants}
\label{sec:invariants}

\experimental

\begin{itemize}
\item Global invariants: invariants on global variables
\item Type invariants: invariants on struct, union, typedef
\item \verb|initially|: predicates that should hold after global
  variables initialization
\end{itemize}

Examples:
\input{invariants.pp}

\subsection{Semantics}

an invariant is true when ...\cite{barnett04jot}


\section{Ghost variables and statements}
\label{sec:ghost}

\experimental

\remark{Patrick}{les ``ghost statements'' correspondent à des
instructions d'observations des variables du C. Ces instructions
ne peuvent pas modifier les variables du C, mais que les ``ghost
variables''. Cela permet d'écrire plus facilement l'observateur
adéquat à la preuve des propriétés puisque les propriétés peuvent
porter à la fois sur les variables du C et les  ``ghost variables''.
}


\input{ghost.bnf}


\section{Module constructions}

\experimental

how to encapsulate several functions...

\section{Arithmetic, Overflow}

quantification can be either on mathematical \verb|integer| or bounded
types \verb|short|, \verb|char|, etc.

we need macros \verb|\max_range|, \verb|min_range| taking a C integer
type as argument, e.g. \verb|\max_range(unsigned char) = 255|\\

\remark{Patrick}{Ces macros, types et variables sont en principe
définies dans des \texttt{.h} que la norme spécifie en grande partie
(le nom l'est, le type peut y être contraint).
Il faudrait autant que possible se raprocher de ces noms.}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
