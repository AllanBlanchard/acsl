
\chapter{Specification language}
\label{chap:base}

\section{Logic expressions}
\label{sec:expressions}

This first section presents the language of expressions one can use in
the annotations. These are called below \emph{logic expressions}. They
corresponds more or less to pure C expressions, without function
calls, with additional constructs that we introduce one at a time.

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\textwidth} \input{term.bnf}
    \end{minipage}}
  \caption{Grammar of terms and predicates}
\label{fig:gram:term}
\end{figure}

Figure~\ref{fig:gram:term} presents the grammar for logic expressions.
In that grammar, we distinguish between \emph{predicates} and
\emph{terms}, following the usual distinction between propositions and
terms in classical multi-sorted first-order logic.


  \begin{itemize}
  \item values in preceedings states: \old(e) and \at(e,label).

    construct \old{} is only valid in ensures clauses of function
    specification. For loop invariants, one need to put some label and
    use the \at{} construct.
  \item returned value: \result

    valid only in ensures clauses of function
    specification.

  \item quantifications:  $\Forall \tau x; e$ and $\Exists \tau x; e$
  \item \verb|==>|, \verb|<==>|, \verb|^^|

  \item $(\Let \tau x = e \In e$ and $\If e \Then e \Else e$

  \item nommage de formules, de termes

  \item $t_1~relop_1~t_2~relop_2~t_3$ is a shortcut for
    $t_1~relop_1~t_2 \&\& t_2~relop_2~t_3$ 
  \end{itemize}

\subsection{Semantics, typing}

always defined (2-valued logic). Distinction entre booleens et
predicats.  TODO: referer aux travaux de P Chalin ? 
Donner des examples

on veut la logique equationnelle classique, cad que l'axiome
\[
\forall x, x=x
\]
est valide. Donc on ne peut pas introduire de construction
non-déterministe comme  $(\texttt{any} x \mid P)$


Types de la logique (see Section~\ref{sec:logicspec}:
\begin{itemize}
\item types mathematiques: real, integer, boolean
\item types du C
\item types logiques introduits par l'utilisateur
\end{itemize}

Typing rules: TODO

\section{Function contracts}
\label{sec:fn-behavior}



\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\textwidth}
      \input{fn_behavior.bnf}
    \end{minipage}}
    \caption{Grammar of function contracts}
  \label{fig:gram:contracts}
\end{figure}

\remark{Patrick}{pourquoi seuls les ``behavior'' peuvent avoir un
  nom~? Ne peut-t'on pas avoir le ``ident:'' optionnel pour chacune
  des clauses~? Claude: parce que le nommage de behavior doit servir
  pour les associer a des clauses du corps de la fonction, p. ex.
  assert ou lopp invariant. Mais on peut aussi proposer par ailleurs
  de nommer des predicate ou terms, p. ex. avec la notation Caduceus
  (id :: f) }

\remark{Virgile}{Changement du mot-clé des variants pour éviter un
  conflit avec les variants de boucle. Le choix du mot-clé exact reste
  à débattre}

The Figure~\ref{fig:gram:contracts} show a grammar for the function
contracts. The grammars for non-terminals term, predicate and
locations are given later. Informally, term denotes pure C
expressions, predicate denotes pure C boolean expressions, and
locations denotes C l-values.

\subsection{Semantics and typing}

Generally speaking, a function contract as the following
form (restricted to two behaviors for readability):
\begin{flushleft}\ttfamily
/*@ requires $P_1$; \\
~~@ requires $P_2$; \\
~~@ behavior $b_1$: \\
~~@ ~~requires $R_1$; \\
~~@ ~~assumes $A_1$; \\
~~@ ~~assigns $L_1$; \\
~~@ ~~ensures $E_1$; \\
~~@ behavior $b_2$:  \\
~~@ ~~requires $R_2$;  \\
~~@ ~~assumes $A_2$; \\
~~@ ~~assigns $L_2$; \\
~~@ ~~ensures $E_2$; \\
~~@ decreases $m$ for $R$; \\
~~@r*/
\end{flushleft}

The semantics of such a contract is as follows:
\begin{itemize}
\item The caller of the function must guarantee that it is called in a
  state where the property \texttt{$P_1$ \&\& $P_2$ \&\& ($R_1$ || $R_2$)}
  holds.
\item The called function returns a state where the properties
  \texttt{\old($R_i$) \&\& \old($A_i$) ==> $E_i$} hold for each $i$.
\item for each $i$, if the function is called in a pre-state where
  \texttt{$R_i$ \&\& $A_i$} holds, then all memory locations of that
  pre-state that do not belong to the set $L_i$ remain allocated
  are left unchanged in the post-state.
\item If the decreases clause is present, the function can call only
  functions (including itself) which has also a decreases clause with
  the same relation $R$, which are called in a state for which the
  measure expression $m$ is smaller.
\end{itemize}

Notice that the assumes clauses and the requires clause in the
behaviors are proposed mainly to improve readibility (to avoid \old
and some duplications of formulas), since the contract above is
equivalent to the following simplified one:
\begin{flushleft}\ttfamily
/*@ requires $P_1$ \&\& $P_2$ \&\& ($R_1$ || $R_2$); \\
~~@ behavior $b_1$: \\
~~@ ~~assigns $L_1$; \\
~~@ ~~ensures \old($R_1$) \&\& \old($A_1$) ==> $E_1$ \\
~~@ behavior $b_2$:  \\ 
~~@ ~~assigns $L_2$; \\
~~@ ~~ensures \old($R_2$) \&\& \old($A_2$) ==> $E_2$; \\
~~@ decreases $m$ for $R$; \\
~~@*/ 
\end{flushleft}


\subsubsection{Example 1: max of two ints}

\begin{cadre}
  \input{max.pp}
\end{cadre}
\subsubsection{Example 2: conditional assignment}

\begin{cadre}
  \input{cond_assigns.pp}
\end{cadre}
\subsubsection{Example 3: binary search}

\begin{cadre}
  \input{bsearch.pp}
\end{cadre}

See~\ref{sec:loop_invariant} for the body of bsearch

\subsubsection{Remarks}

\remark{Yannick}{JML propose deux modes de spécification des fonctions~:
 soit à base de ``requires'' et ``ensures'', soit à base de
 ``behavior''. JML n'a pas de ``assumes'' dans les
  ``behaviors'', mais des ``requires''. Dans le cas où les deux modes
  peuvent se combiner, la sémantique est la suivante~:}

\begin{verbatim}
  requires P_1
  requires P_2
  ensures  Q_1
  ensures  Q_2
  behavior x_1: requires R_1 ensures E_1
  behavior x_2: requires R_2 ensures E_2
\end{verbatim}


\begin{verbatim}
 pre-condition : P_1 and P_2
             and (R_1 or R_2)
 post-condition: Q_1 and Q_2
             and (\old(R_1) implies E_1)
             and (\old(R_2) implies E_2)
\end{verbatim}

\remark{Patrick}{les ``behavior'' de JML présente l'avantage de
  pouvoir spécifier une fonction par cas (non exclusifs)
  et de vérifier que les cas d'appel sont spécifiés (sinon on ne peut
  vérifier la pré-condition).
  Il semble important à Airbus de pouvoir s'assurer qu'ils ont
  énoncé l'ensemble des cas.}

\remark{Yannick}{avoir ``requires'' en plus des ``assumes'' dans les
  ``behaviors'' semble utile :
la sémantique consiste à rajouter $(A_i \ra R_i)$ en conjonction de la
précondition globale}

\begin{verbatim}
  requires P_1
  requires P_2
  ensures  Q_1
  ensures  Q_2
  behavior x_1: requires R_1 assumes A_1 ensures E_1
  behavior x_2: requires R_2 assumes A_2 ensures E_2
\end{verbatim}


\begin{verbatim}
 pre-condition : P_1 and P_2
             and (A_1 implies R_1)
             and (A_2 implies R_2)
 post-condition: Q_1 and Q_2
             and (\old(A_1) implies E_1)
             and (\old(A_2) implies E_2)
\end{verbatim}

\subsection{Memory locations}
\label{sec:locations}

There are several places where one needs to describe a set of memory locations: \assigns{} clauses, \reads{} clauses.

\begin{figure}
  \fbox{\begin{minipage}{0.97\textwidth}
      \input{loc.bnf}  
    \end{minipage}}
  \caption{Grammar for memory locations}
\label{fig:gram:locations}
\end{figure}

The grammar for denoting such a set of memory locations is given
Figure~\ref{fig:gram:locations}.

The semantics is given as follows, where $s$ denotes any tset:
\begin{itemize}
\item a simple term denotes a singleton
\item $s\ra id$ denotes the set of $x\ra id$ for each $x \in s$
\item $s.id$ denotes the set of $x.id$ for each $x \in s$
\item $*s$ denotes the set of $*x$ for each x in s
\item $s_1[s_2]$ denotes the set of $x_1[x_2]$ for each $x_1 \in s_1$
  and $x_2 \in s_2$
\item $t_1 .. t_2$ denotes the set of integers between $t_1$ and
  $t_2$, included
\item $s_1,s_2$ denotes the union of $s_1$ and $s_2$
\item $s_1+s_2$ denotes the set of $x_1+x_2$ for each $x_1 in s_1$ and $x_2 in s_2$
\item $(s)$ denotes the same set as $s$
\item $\{ s \mid b ; P \}$ denotes set comprehension: set of term denoted by $s$ for each values of binders satisfying predicate $P$. Binders $b$ are bound in $s$ and $P$
\end{itemize}

A \emph{location} is any set of terms denoting a set of lvalues.
Only locations are valid as argument to \assigns{} clauses

Examples:
\input{assigns.pp}

\remark{Patrick}{ne faut-t'il pas étendre les clauses ``assigns'' aux
  clauses ``from'' de CAVEAT prenant en comptes les locations lues, et les
  expressions fonctionnelles~?}

\subsection{Typing rules}

Two judgements:
\begin{itemize}
\item $\Gamma,\Lambda \vdash e : loc \tau$ means e is a set of location of type
  $tau$
\item $\Gamma,\Lambda \vdash e : tset \tau$ means e is a set of terms of type
  $tau$
\end{itemize}
$\Gamma$ is the C environment and $\Lambda$ is the logic environment.

Rules:
\[
\frac{\vdash e:loc \tau}{\vdash e: tset \tau}
\]
\[
\frac{\tau x \in \Gamma}{\vdash x: loc \tau}
\]
\[
\frac{e:tset \tau*}{\vdash *e: loc \tau}
\]
\[
\frac{e_1:tset \tau \quad e_2:tset \tau}{\vdash e_1,e_2: \tau}
\]
\[
\frac{e: tset struct S* \quad e_2:tset \tau}{\vdash e->f : loc \tau}
\]
\[
\frac{b\cup \Lambda \vdash e: tset \tau}{\vdash \{ e \mid b ; P \} : tset \tau }
\]
idem for $loc \tau$

Notes:
\begin{itemize}
\item Quantification can be be made over any type (both C and
  logic types).
\item Quantification over pointers, structures, union, etc.
  are possible too. TODO: the meaning must be carefully defined.
\end{itemize}

\section{Statement annotations}


  \begin{itemize}
  \item \assert, label
    \remark{claude}{permettre de nommer les asserts}
  \item loop invariants (+loop assigns ?)
  \item block behaviors (normal termination only, no goto going
    inside, no goto going outside)
  \end{itemize}

\subsection{Assertions and logical labels} 

\begin{syntax}
  statement ::= "/*@" logical-label "*/" statement \
  logical-label ::= "label" id: ;
  | "assert" pred ";" ;
  | "assert" id ":" pred ";" ;
  | "assert" "for" id ":" pred ";" ;
\end{syntax}

The \texttt{label} id annotation simply allows one to refer to the value of some expression $e$ in the state before the statement, in further annotations, using the constructs \at(e,id)

The \texttt{assert} p clause means that p must hold in the state
before the statement.

The last two constructs allows to give a name to the assertion. In the
case \texttt{assert for} id, id must be a behavior identifier for the
current function. It means that this assertion is meant to be valid
only for the considered behavior.

\remark{Claude}{unifier les 2 derniers cas? car a-t-on besoin de nommer un assert en dehors d'une behvior de la fonction?}

\subsection{Statement contracts}


\subsection{Loop annotations}

semantics of loop invariants: in particular for {\tt for} loops

\begin{syntax}
  invariant-clause ::= "loop" "invariant" predicate \
\end{syntax}

loop assigns: semantics?


\section{Pointers and physical adressing}

\subsection{Memory blocks and pointer dereferencing}

\begin{itemize}
\item \baseaddr{} base address of an allocated pointer
\[
\baseaddr{} : \alpha {\tt *} \ra {\tt char *}
\]
\item \blocklength{} length of the allocated block of a pointer
\[
\blocklength{} : \alpha {\tt *} \ra {\tt size\_t}
\]

\end{itemize}

Shortcuts:
\begin{itemize}
\item offset(p) returns the offset between p ans its base address

  \begin{eqnarray*}
    offset &:& \alpha {\tt *} \ra {\tt size\_t}  \\
    offset(p) &=& (char*)p - \baseaddr(p)
  \end{eqnarray*}

\item valid(p) tells whether dereferencing p is safe

  \begin{eqnarray*}
    valid : \alpha {\tt *} \ra {\tt boolean} \\
    valid(p) = offset(p) \geq 0 \land offset(p) + sizeof(*p) \leq \blocklength(p)
  \end{eqnarray*}

\item \comparable{} (checks whether two pointers are comparable as defined
  in the ANSI standard: TODO by benjamin)
\[
\comparable{} : \alpha {\tt *} \ra \beta {\tt *} \ra {\tt boolean}
\]
\end{itemize}


\subsection{Separation}

pointer separation :
\[
p \not\equiv q := \baseaddr(p) \neq \baseaddr(q) \lor |(char*)p - (char*)q| \geq \max(\sizeof(p),\sizeof(q))
\]

$\separated(loc1,..,loc_n)$ : means that for if $i\neq j$, if $x\in loc_i$ and $y \in loc_j$ then $\&x \not\equiv \& y$

where each $loc_i$ is a set of memory location as defined in Section~\ref{sec:locations}.

\subsection{Allocation and deallocation}

\experimental

\begin{itemize}
\item built-in predicate \fresh, specifying in a post-condition that a
  pointer was not allocated in the pre-state.
 
\item built-in predicate \freed, specifying in a post-condition that a
  pointer was allocated in the pre-state but not anymore.
\end{itemize}

\section{Termination}

Property of termination concerns both loops and recursive function calls. 
For that purpose, loops can be annotated with \emph{loop variants}\index{loop variant}, and functions can be annotated with such variants too.

\subsection{integer measures}

For loops:
\begin{syntax}
variant-clause ::= "loop variant" e 
\end{syntax}

For functions:
\begin{syntax}
decreases-clause ::= "decreases" e 
\end{syntax}
where $e$ has type integer

\subsection{general measures}

More general case of measures on other types: use the keyword for:

\begin{syntax}
variant-clause ::= "loop variant" e "for" id \
decreases-clause ::= "decreases" e "for" id
\end{syntax}

where $e$ has type $\tau$ and $id$ is a logic predicate of type $\tau,\tau \ra
prop$ (see Section~\ref{sec:logicspec}


\section{Logic specifications}
\label{sec:logicspec}

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth} \input{logic.bnf}
    \end{minipage}}  
  \caption{Grammar for logic declarations}
\label{fig:gram:logic}
\end{figure}

\begin{itemize}
\item logic specifications: introduction of new logic types,
  constants, functions, predicates and axioms.

logic types can be polymorphic: for example
\input{listdecl.pp}

\item recursive definitions: are allowed in logic function and predicate definitions. Example:  
  \input{max_index.pp}

mutual recursion

\item predefined logic specifications can be provided as libraries (see section~\ref{sec:speclibraries}, and imported using
\input{import.pp}

\item higher-order functions: $\lambda$, \Sum, \Max, \numof
\item {\tt enum}, recursive types


\item hybrid functions and predicates: take both C types and logic
  types as arguments.
\item model variables
\end{itemize}


\section{Abnormal termination}

\begin{itemize}
\item C function \verb|exit(n)|. special behavior notation
  \begin{verbatim}
    exit_behavior
       assumes
       assigns
       ensures ...
  \end{verbatim}
    where in ensures clause, \result is bound to n
\end{itemize}


\section{Dependencies information}

\experimental

\begin{verbatim}
assigns Locs from Locs
\end{verbatim}

\section{Functional expressions}

\experimental

trouver une syntaxe pour introduire les noms des fonctions implicites
derriere la construction
\begin{verbatim}
assigns Locs from Locs
\end{verbatim}

\section{Data invariants}
\label{sec:invariants}

\experimental

\begin{itemize}
\item Global invariants: invariants on global variables
\item Type invariants: invariants on struct, union, typedef
\item \verb|initially|: predicates that should hold after global
  variables initialization
\end{itemize}

Examples:
\input{invariants.pp}

\subsection{Semantics}

an invariant is true when ...\cite{barnett04jot}


\section{Ghost variables and statements}
\label{sec:ghost}

\experimental

\remark{Patrick}{les ``ghost statements'' correspondent à des
instructions d'observations des variables du C. Ces instructions
ne peuvent pas modifier les variables du C, mais que les ``ghost
variables''. Cela permet d'écrire plus facilement l'observateur
adéquat à la preuve des propriétés puisque les propriétés peuvent
porter à la fois sur les variables du C et les  ``ghost variables''.
}


\input{ghost.bnf}


\section{Module constructions}

\experimental

how to encapsulate several functions...

\section{Arithmetic, Overflow}

quantification can be either on mathematical \verb|integer| or bounded
types \verb|short|, \verb|char|, etc.

we need macros \verb|\max_range|, \verb|min_range| taking a C integer
type as argument, e.g. \verb|\max_range(unsigned char) = 255|\\

\remark{Patrick}{Ces macros, types et variables sont en principe
définies dans des \texttt{.h} que la norme spécifie en grande partie
(le nom l'est, le type peut y être contraint).
Il faudrait autant que possible se raprocher de ces noms.}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
