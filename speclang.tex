%; whizzy-master "main.tex"

\chapter{Specification language}
\label{chap:base}

\section{Lexical rules}

Lexical structure mostly follows that of ANSI C. A few differences
must be noted.
\begin{itemize}
\item The at sign (\verb|@|) is a blank character, thus equivalent
  to a space character.
\item Identifiers may start with the backslash character (\verb|\|).
\item Some UTF8 characters may be used in place of some constructs, as
  shown in the following table:

  \begin{center}
    \begin{tabular}{|l|l|l|}
      \hline
      \verb|>=| & \ensuremath{\geq} & 0x2265 \\
      \hline
      \verb|<=| & \ensuremath{\leq} & 0x2264 \\
      \hline
      \verb|>| & \ensuremath{>} & 0x003E \\
      \hline
      \verb|<| & \ensuremath{<} & 0x003C \\
      \hline
      \verb|!=| & \ensuremath{\not\equiv} & 0x2262 \\
      \hline
      \verb|==| & \ensuremath{\equiv} & 0x2261 \\
      \hline
      \verb|==>| & \ensuremath{\Longrightarrow} & 0x21D2 \\
      \hline
      \verb|<==>| & \ensuremath{\Longleftrightarrow} & 0x21D4 \\
      \hline
      \verb|&&| & \ensuremath{\land} & 0x2227 \\
      \hline
      \verb+||+ & \ensuremath{\lor} & 0x2228 \\
      \hline
      \verb+^^+ & \ensuremath{\oplus} & 0x22BB \\
      \hline
      \verb+!+ & \ensuremath{\neg} & 0x00AC \\
      \hline
      \verb|\forall| & \ensuremath{\forall} & 0x2200 \\
      \hline
      \verb|\exists| & \ensuremath{\exists} & 0x2203 \\
      \hline
    \end{tabular}
  \end{center}
\item Comments can be put inside ACSL annotations. They use the C++
  format, {\it i.e.} begin with \texttt{//} and extend to the end of
  current line.
\end{itemize}

In this document, we use UTF8 characters in the examples, to improve readability.

\section{Logic expressions}
\label{sec:expressions}

This first section presents the language of expressions one can use in
annotations. These are called \emph{logic expressions} in the following. They
correspond to pure C expressions, with additional constructs
that we will introduce progressively.

\begin{figure}[p]
  \fbox{\begin{minipage}{0.97\textwidth} \input{term.bnf}
    \end{minipage}}
  \caption{Grammar of terms and predicates}
\label{fig:gram:term}
\end{figure}

Figure~\ref{fig:gram:term} presents the grammar for the basic
constructs of logic expressions.  In that grammar, we distinguish
between \emph{predicates}\index{predicate} and
\emph{terms}\index{term}, following the usual distinction between
propositions and terms in classical first-order logic.  The grammar
for binders and type expressions is given separately in
Figure~\ref{fig:gram:binders}.

With respect to C pure expressions, the additional constructs are as follows:
\begin{description}
\item[Additional connectives] C operators \verb|&&| (UTF8: $\land$),
  \verb+||+ (UTF8: $\lor$) and \verb|!| (UTF8: $\neg$) are used as logical
  connectives. There are additional connectives \verb|==>| (UTF8:
  $\Longrightarrow$) for implication, \verb|<==>| (UTF8:
  $\Longleftrightarrow$) for equivalence and \verb|^^| (UTF8:
  $\oplus$) for exclusive
  or. These logical connectives all have a bitwise counterpart, either
  C ones like \verb|&|, \verb+|+, \verb|~| and \verb|^|, or additional
  ones like bitwise implication \verb|-->| and bitwise
  equivalence \verb|<-->|.

\item[Quantification] Universal quantification is denoted by $\Forall
  \tau~x_1,\ldots,x_n; e$ and existential quantification by $\Exists
  \tau~ x_1,\ldots,x_n; e$.

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\textwidth} \input{binders.bnf}
    \end{minipage}}
  \caption{Grammar of binders and type expressions}
\label{fig:gram:binders}
\end{figure}

\item[Local binding] \notimplemented{$\Let x~\texttt{=}~e_1~\texttt{;}~e_2$
  introduces the name $x$ for
  expression $e_1$ which can be used in expression $e_2$.
}

\item[Conditional] $c~\verb!?!~e_1~\verb!:!~e_2$. There is a subtlety
  here: the condition may be either a boolean term or a predicate.  In
  case of a predicate, the two branches must be also predicates, so
  that this construct acts as a connective with the following
  semantics: $ c \verb!?! e_1 \verb!:! e_2$ is equivalent to $(c
  \verb|==>| e_1) \verb|&&| (\verb|!| c \verb|==>| e_2)$.

\item[Syntactic naming] $id \verb|:| e$ is a term or a predicate
  equivalent to $e$. It is different from local naming with $\Let$:
  the name cannot be reused in other terms or predicates. It is only
  for readibility purposes.

\item[Functional modifier] The composite element modifier is an additional
  operator in relation to the C structure field and array accessors.
  The expression
  \verb|{| $s$ \verb|for| $id$ \verb|=| $v$ \verb|}|
  denotes the same structure than $s$, except for the field $id$ to be
  modified by $v$.
  The equivalent expression for an array is
  \verb|{| $t$ \verb|for| \verb|[| $i$ \verb|]| \verb|=| $v$ \verb|}|
  which returns the same array than $t$, except for the $i^{th}$ element those value
  is updated to $v$.
  See Section~\ref{sec:func-dep} for an example of use of these operators.

\item[Logic functions] Applications in terms and in propositions are not
applications of C functions, but of logic functions or predicates; see
Section~\ref{sec:logicspec} for detail.

\item[Consecutive comparison operators]
  The construct $t_1~relop_1~t_2~relop_2~t_3 \cdots t_k$ with
  several consecutive comparison operators is a shortcut for
  $(t_1~relop_1~t_2) ~\verb|&&|~ (t_2~relop_2~t_3) ~\verb|&&|~ \cdots $.
  It is required that the $relop_i$ operators must be in
  the same ``direction'', \emph{i.e.} they must all belong either to
  $\{\verb|<|, \verb|<=|, \verb|==|\}$ or to
  $\{\verb|>|,\verb|>=|,\verb|==|\}$. Expressions such as
  \verb|x < y > z| or \verb|x != y != z| are not allowed.

  To enforce the same interpretation as in C expressions, one may need
  to add extra parentheses: $a \verb!==! b \verb!<! c$ is equivalent
  to $a \verb!==! b \verb|&&| b \verb!<! c$, whereas
  $a \verb!==! (b \verb!<! c)$ is
  equivalent to $\Let x \verb!=! b \verb!<! c \verb!;! a \verb!==!
  x$. This situation raises some issues, see example below.


\oldremark{Virgile}{Dans le dernier cas, on pourrait vouloir avoir x, y
  et z deux à deux distincts, et eventuellement un prédicat n-aire
\distinct(x,y,z) comme dans SMT-lib}

\end{description}

There is a subtlety with respect to comparison operators: they are
predicates when used in predicate position, and boolean functions when
used in term position.
\begin{example}
\input{example-lt.pp}
\end{example}





\subsection{Operators precedence}

The precedence of C operators is conservatively extended with
additional operators, as shown in Figure~\ref{fig:precedence}. In this
table, operators are sorted from highest to lowest priority. Operators
of same priority are presented on the same line.


\begin{figure}[t]
  \begin{center}
    \begin{tabular}{|l|l|l|}
      \hline
      class 	& associativity & operators \\
      \hline
      selection & left & $\verb|[|\cdots\verb|]|$ \verb|->| \verb|.| \\
      unary 	& right & \verb|!| \verb|~| \verb|+| \verb|-| \verb|*| \verb|&| (cast) \verb|sizeof| \\
      multiplicative & left & \verb|*| \verb|/|  \verb|%| \\
      additive & left & \verb|+| \verb|-| \\
      shift 	& left & \verb|<<| \verb|>>| \\
      comparison & left & \verb|<| \verb|<=| \verb|>| \verb|>=| \\
      comparison & left & \verb|==| \verb|!=| \\
      bitwise and & left & \verb|&| \\
      bitwise xor & left & \verb|^| \\
      bitwise or & left & \verb+|+ \\
      bitwise implies & left & \verb+-->+ \\
      bitwise equiv & left & \verb+<-->+ \\
      connective and     & left & \verb|&&| \\
      connective xor & left & \verb+^^+ \\
      connective or & left & \verb+||+ \\
      connective implies & right & \verb|==>| \\
      connective equiv & left & \verb|<==>| \\
      ternary connective & right & $\cdots\verb|?|\cdots\verb|:|\cdots$ \\
      binding & left & \Forall{} \Exists{} \Let{} \\
      naming & right & \verb|:| \\
      \hline
    \end{tabular}
  \end{center}
  \caption{Operator precedence}
\label{fig:precedence}
\end{figure}

There is a remaining ambiguity between the connective
\verb|..?..:..| and the labelling operator \verb|:|. Consider for
instance the
expression \verb|x?y:z:t|. The precedence table does not indicate
whether this should be understood as \verb|x?(y:z):t| or \verb|x?y:(z:t)|.
Such a case must be considered as a syntax error, and should be fixed
by explicitly adding parentheses.

\subsection{Semantics}
\label{sec:twovaluedlogic}

The semantics of logic expressions in ACSL is based on
mathematical first-order
logic~\cite{wikipedia-fo-logic}. In
particular, it is a 2-valued logic with only total functions. Consequently,
expressions are never ``undefined''.
This is an important design choice and the specification writer should
be aware of that. (For a discussion about the issues raised by such
design choices, in similar specification languages such as JML, see
the comprehensive list compiled by Patrice
Chalin~\cite{chalin05ftfjp,chalin07icse}.)

Having only total functions implies than one can write
terms such as \verb|1/0|, or \verb|*p| when \verb!p! is null (or more
generally
when it points to a non-properly allocated memory cell). In
particular, the predicates
\begin{eqnarray*}
  \verb!1/0! &\verb|==|& \verb!1/0! \\\relax
  \verb!*p! &\verb|==|& \verb!*p!
\end{eqnarray*}
are valid, since they are instances of the axiom $\forall x,
x=x$ of first-order logic. Of course, there is no way to deduce
anything useful about such terms.
\oldremark{Anonyme}{Donc on ne peut pas introduire de construction
non-déterministe comme  $(\texttt{any} x \mid P)$
}
As usual, it is up to the specification designer to write
consistent assertions. For example, when introducing the following lemma
(see Section~\ref{sec:logicspec}):
\input{div_lemma.pp}
a premise is added to require \verb|y| to be non zero.


\subsection{Typing}\label{sec:typing}

The language of logic expressions is typed (as in \emph{multi-sorted}
first-order logic). Types are either C types or \emph{logic types}
defined as follows:
\begin{itemize}
\item ``mathematical'' types: \verb|integer|\indexttbs{integer} for
  unbounded, mathematical integers, \verb|real|\indexttbs{real} for
  real numbers, \verb|boolean|\indexttbs{boolean} for booleans (with
  values written \verb|\true|\indexttbs{true} and
  \verb|\false|\indexttbs{false});
\item logic types introduced by the specification writer (see
  Section~\ref{sec:logicspec}).
\end{itemize}
There are implicit coercions for numeric types:
\begin{itemize}
\item C integral types \verb|char|, \verb|short|, \verb|int| and
  \verb|long|, signed or unsigned, are all subtypes of type \verb|integer|;
\item \verb|integer| is itself a subtype of type \verb|real|;
\item C types \verb|float| and \verb|double| are subtypes of type \verb|real|.
\end{itemize}
Notes:
\begin{itemize}
\item There is a distinction between booleans and predicates. The
  expression $x<y$ in term position is a boolean, and the same expression
  is also allowed in predicate position.
\item Unlike in C, there is a distinction between booleans and
  integers. There is an implicit promotion from integers to booleans,
  thus one may write \verb|x && y| instead of \verb|x != 0 && y != 0|.
  If the reverse conversion is needed, an explicit cast\index{cast} is
  required, \emph{e.g.} \texttt{(int)(x>0)+1}, where \verb|\false| becomes 0
  and \verb|\true| becomes 1.
\item Quantification can be made over any type: logic types and C
  types. Quantification over pointers must be used carefully,
  since it depends on the memory state where dereferencing is done (see
  Section~\ref{sec:quantification} and
  Section~\ref{sec:logicalstates}).
\end{itemize}

Formal typing rules for terms are given in appendix~\ref{sec:typingrules}.


\subsection{Integer arithmetic and machine integers}

The following integer arithmetic operations apply to
\emph{mathematical integers}: addition, subtraction, multiplication,
unary minus. The value of a C variable of an integral type is promoted
to a mathematical integer. As a consequence, there is no such thing as
``arithmetic overflow'' in logic expressions.

Division and modulo are also mathematical operations, which coincide
with the corresponding C operations on C machine integers, thus
following the ANSI C99 conventions. In particular, these are not the
usual mathematical Euclidean division and remainder.
Generally speaking, division
rounds the result towards zero. The results are not specified if
divisor is zero; otherwise if $q$ and $r$ are the quotient and the
remainder of $n$ divided by $d$ then:
\begin{itemize}
\item $|d\times q| \leq |n|$, and $|q|$ is maximal for this property;
\item $q$ is zero if $|n|<|d|$;
\item $q$ is positive if $|n|\geq|d|$ and $n$ and $d$ have the same sign;
\item $q$ is negative if $|n|\geq|d|$ and $n$ and $d$ have opposite signs;
\item $q\times d+r = n$;
\item $|r|<|d|$;
\item $r$ is zero or has the same sign as $d$.
\end{itemize}

\begin{example}
  The following examples illustrate the results of division and modulo
  depending on the sign of their arguments:
  \begin{itemize}
  \item \verb|5/3| is 1 and \verb|5%3| is 2;
  \item \verb|(-5)/3| is -1 and \verb|(-5)%3| is -2;
  \item \verb|5/(-3)| is -1 and \verb|5%(-3)| is 2;
  \item \verb|(-5)/(-3)| is 1 and \verb|(-5)%(-3)| is -2.
  \end{itemize}
\end{example}

\subsubsection{Hexadecimal and octal constants}

Hexadecimal and octal constants are always non-negative. Suffixes
\texttt{u} and \texttt{l} for C constants are allowed but meaningless.

\subsubsection{Casts and  overflows}\index{cast}

In logic expressions, casting from mathematical integers
to an integral C type $t$ (such as \texttt{char}, \texttt{short},
\texttt{int}, etc.) is allowed and is
interpreted as follows: the result is the unique value of the
corresponding type that is congruent to the mathematical result modulo
the cardinal of this type, that is $2^{8\times\sizeof(t)}$.
\begin{example}
  \texttt{(unsigned char)1000} is $1000 \bmod 256$ i.e. $232$.
\end{example}


To express in the logic the value of a C
expression, one has to add all the necessary casts. For
example, the logic expression denoting the value of the C expression
$x*y+z$ is \texttt{(int)((int)(x*y)+z)}.
\oldremark{Claude}{Si la conjecture suivante est vraie, alors il
  faudrait en parler: Si e1 et e2 sont des expressions d'un type
  entier de C, quels qu'ils soient et si op est une operation binaire
  sur entiers, alors l'operation C $e1~op~e2$ (de type $\tau$),donne
  le meme resultat que l'expression logique $(\tau)(e_1~op~e_2)$ ou
  $op$ est l'operation logique sur $Z$. Ce cast permet donc a
  l'utilisateur de parler du resultat du calcul C d'une expressions
  dans la logique
}
Note that there is no implicit cast from integers to C integral types.
\input{integer-cast.pp}



\subsubsection{Quantification on C integral types}
\label{sec:quantification}

Quantification over a C integral type corresponds to integer
quantification over the corresponding interval.
\begin{example}
Thus the formula
  \begin{center}
    \verb|\forall char c; c <= 1000|
  \end{center}
is equivalent to
\begin{center}
  \verb|\forall integer c; -128 <= c <= 127 ==> c <= 1000|
\end{center}
\end{example}


\subsubsection{Size of C integer types}

Remark that the size of C types is architecture-dependent. ACSL does
not enforce these sizes either, hence the semantics of terms involving
such types is also architecture-dependent. The
\texttt{sizeof}\index{sizeof} operator may be used in the logic and is
assumed to be consistent with the C code. For instance, it should be
possible to verify the following code: \input{sizeof.pp}

Constants giving maximum and minimum values of those types may be
given in a library.

\oldremark{Claude}{we need macros \texttt{max\_range} \texttt{min\_range}
  taking a C integer type as argument, e.g.
  \texttt{max\_range(unsigned char) = 255} Ces macros, types et
  variables sont en principe définies dans des \texttt{.h} que la
  norme spécifie en grande partie (le nom l'est, le type peut y être
  contraint).  Il faudrait autant que possible se raprocher de ces
  noms.
}

\subsubsection{Enum types}

Enum types are also interpreted as mathematical integers. Casting\index{cast}
an integer into an enum in the logic must give the same result as if it
was in the C code.

\subsubsection{Bitwise operations}

Like arithmetic operations, bitwise operations apply to any
mathematical integer: any mathematical integer has a unique infinite
2-complement binary representation with infinitely many zeros (for
non-negative numbers) or ones (for negative numbers) on the left. Then
bitwise operations apply to this representation.
\begin{example} ~
  \begin{itemize}
  \item \verb|7 & 12| = $\cdots 00111$ \verb|&| $\cdots 001100$ =
    $\cdots 00100$ = 4
  \item \verb+-8 | 5+ = $\cdots 11000$ \verb+|+ $\cdots 00101$ = $\cdots
    11101$ = -3
  \item \verb+~5+ = \verb|~| $\cdots 00101$ = $\cdots 111010$ = -6
  \item \verb+-5 << 2+ = $\cdots 11011$ \verb|<<| $2$ = $\cdots
    11101100$ = -20
  \item \verb+5 >> 2+ = $\cdots 00101$ \verb|>>| $2$ = $\cdots 0001$ = 1
  \item \verb+-5 >> 2+ = $\cdots 11011$ \verb|>>| $2$ = $\cdots 1110$ =
    -2
  \end{itemize}
\end{example}

\subsubsection{Transcendental functions}

Classical mathematical operations like exponential, sine, cosine,
etc. are supposed to be available in some library (see
Section~\ref{sec:libreal}).

\oldremark{All}{  syntaxe pour abs et power ? a priori non, on peut
  fournir une library pour les reels avec abs(), power(), mais
  proposer des syntaxes speciales parait difficile

  mais: on pourrait permettre des definition d'operateurs infixes

}


\subsection{Real numbers and floating point numbers}

Floating-point constants and operations are interpreted as
mathematical real numbers: a C variable of type float or double is
implicitly promoted to a real. Integers are promoted to reals if necessary.
\begin{example}
$2 * 3.5$ is equal to the real number 7
\end{example}
Unlike the promotion of C integer types to mathematical integers,
there are special float values which do not naturally map to a real
number, namely NaN, +Infinity and -Infinity. Since we want a logic
with total functions, we consider that there are implicit promotion
functions \verb|real_of_float|\indextt{real\_of\_float} and
\verb|real_of_double|\indextt{real\_of\_double} whose results
on the 3 values above is left unspecified.

Usual operators for comparison are interpreted as real operators
too. In particular, equality operation $\equiv$ of float (or double)
expressions means equality of the real numbers they represent
respectively. Or equivalently, $x \equiv y$ for $x,y$ two float
variables means $\verb|real_of_float|(x) \equiv
\verb|real_of_float|(y)$ with the mathematical equality of real
numbers.

Special predicates are also available to express the comparison
operators of float (resp. double) numbers as in C:
\verb|\eq_float|\indexttbs{eq\_float}\indexttbs{eq\_double},
\verb|\gt_float|\indexttbs{gt\_float}\indexttbs{gt\_double},
\verb|\ge_float|\indexttbs{ge\_float}\indexttbs{ge\_double},
\verb|\le_float|\indexttbs{le\_float}\indexttbs{le\_double},
\verb|\lt_float|\indexttbs{lt\_float}\indexttbs{lt\_double},
\verb|\ne_float|\indexttbs{ne\_float}\indexttbs{ne\_double} (resp. for double).



\oldremark{DP+all}{

  Il faut de toute facon detailler les constructions de le spec pour
  parler des flottants: reprend-on celles de Caduceus ? exact(...)

  On peut laisser la main a JCF pour ce point

}

\subsubsection{Casts, infinity and NaNs}

Casting\index{cast} from a C integer type or a float type to a float or a double is
as in C: the same conversion operations apply.

Conversion of real numbers to float or double values indeed depends on
various possible rounding modes defined by the IEEE~754
standard~\cite{float-std,wikipedia-float}. These modes are defined by
a logic type (see section~\ref{sec:concrete-logic-types}):
\begin{flushleft}\ttfamily
/*@ type rounding\_mode =  \\
\quad  Nearest\_even | To\_zero | Round\_up | Round\_down | Nearest\_away\\
*/
\end{flushleft}
Then rounding a real number can be done explicitly using functions
\begin{flushleft}\ttfamily
  logic float \verb|\round_float|\indexttbs{round\_float}(rounding\_mode m, real x); \\
  logic double \verb|\round_double|\indexttbs{round\_double}(rounding\_mode m, real x);
\end{flushleft}
Cast operators \verb|(float)| and \verb|(double)| applied to a
mathematical integer or real number $x$ are equivalent to apply
rounding functions above with the nearest-even rounding mode (which is
the default rounding mode in C programs)
%(see IEEE 754 norm), which is the closest to $x$ real number
%which is representable in the float (resp. double) type.
If the source real number is too large, this may also result into one
of the special values +infinity and -infinity.
\begin{example}
  We have
  $\verb|(float)0.1| \equiv 13421773 \times 2 ^{-27}$ which is equal to
  $0.10000000149006473916$
\end{example}
Notice also that unlike for integers, suffixes $f$ and $l$ are
meaningful, because they implicitly add a cast operator as above.

% \begin{remark}{Claude}
%   ne devrait-on pas ajouter le suffixe d dans la logique ?

%   par ex. 0.1d -> (double)0.1

% \end{remark}

This semantics of casts ensures that the float result $r$ of a C operation
$e_1 op e_2$ on floats, if there is no overflow and if the default
rounding mode is not changed in the program, has the same real value
as the logic expression $(float)(e_1 op e_2)$. Notice that this is not
true for the equality \verb|\eq_float| of floats: \verb|-0.0 + -0.0|
in C is equal to the float number \verb|-0.0|, which is not
\verb|\eq_float| to \verb|0.0|, which is the value of the logic
expression \verb|(float)(-0.0 + -0.0)|.

Finally, two additional predicates are provided on float and double
numbers,which check that their argument is NaN or a
finite number respectively:
\begin{flushleft}\ttfamily
predicate \verb|\is_nan_float|\indexttbs{is\_nan\_float}(float x); \\
predicate \verb|\is_nan_double|\indexttbs{is\_nan\_double}(double x); \\
predicate \verb|\is_finite_float|\indexttbs{is\_finite\_float}(float x); \\
predicate \verb|\is_finite_double|\indexttbs{is\_finite\_double}(double x);
\end{flushleft}

\oldremark{Claude}{

on pourrait enonce un certain nombre de proprietes:

\is_finite_float(x) ==> (float)(\real_of_float(x)) == x

}

\subsubsection{Quantification}

Quantification over a variable of type \verb|real| is of course usual
quantification over real numbers.

Quantification over float (resp. double) types is allowed too, and is
supposed to range over all real numbers representable as floats (resp
doubles). In particular, this does not include NaN, +infinity and
-infinity in the considered range.


\oldremark{JCF+All}{
\subsubsection{Exact computations}

built-in \texttt{exact}: a definir TODO

Que deviennent les champs modeles de caduceus ?

Il faudrait les integrer a une traitement plus general des modeles
pour des types de donnees

}


\section{Function contracts}
\label{sec:fn-behavior}
\index{function contract}\index{contract}


\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\textwidth}
      \input{fn_behavior.bnf}
    \end{minipage}}
    \caption{Grammar of function contracts}
  \label{fig:gram:contracts}
\end{figure}

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\textwidth}
      \input{oldandresult.bnf}
    \end{minipage}}
    \caption{\old and \result in terms}
  \label{fig:gram:oldandresult}
\end{figure}



Figure~\ref{fig:gram:contracts} shows a grammar for function
contracts. Non-terminal \textsl{location}
is defined later in Section~\ref{sec:locations} (informally, \textsl{location}
denotes a set of C l-values\index{l-value}).

This section is organized as follows.
First, the grammar for terms is extended with two new constructs.
Then Section~\ref{sec:simplecontracts}
introduces \emph{simple contracts}.
Finally, Section~\ref{subsec:behaviors} defines more general contracts
involving \emph{named behaviors}
The \verb|decreases| and \verb|terminates| clauses are presented later in
Section~\ref{sec:termination}.

\oldremark{Patrick}{pourquoi seuls les ``behavior'' peuvent avoir un
  nom~? Ne peut-t'on pas avoir le ``ident:'' optionnel pour chacune
  des clauses~? Claude: parce que le nommage de behavior doit servir
  pour les associer a des clauses du corps de la fonction, p. ex.
  assert ou loop invariant. Mais on peut aussi proposer par ailleurs
  de nommer des predicate ou terms, p. ex. avec la notation Caduceus
  (id : f)
}

\subsection{Built-in constructs \old{} and \result{}}

Post-conditions usually require to refer to function results and
values in the pre-state. Thus terms are extended with the following new
constructs (shown in Figure~\ref{fig:gram:oldandresult}).
\begin{itemize}
\item $\old(e)$\indexttbs{old} denotes the value of $e$ in the
pre-state of the function.
\item \result\indexttbs{result} denotes the returned value of the function.
\end{itemize}

$\old(e)$ and $\result$ can be used only in \ensures{} clauses, since
the other clauses already refer to the pre-state.
% See Section~\ref{sec:at} for more details on scoping rules for labels.

\subsection{Simple function contracts}
\label{sec:simplecontracts}

A simple function contract, having no named behavior, has the following
form:
\indextt{requires}\indextt{assigns}\indextt{ensures}
\begin{flushleft}\ttfamily
/*@ requires $P_1$; requires $P_2$; \dots \\
~~@ assigns $L_1$;  assigns $L_2$;  \dots \\
~~@ ensures $E_1$;  ensures $E_2$;  \dots \\
~~@*/
\end{flushleft}
The semantics of such a contract is as follows:
\begin{itemize}
\item The caller of the function must guarantee that it is called in a
  state where the property $P_1 \verb|&&| P_2 \verb!&&! \dots$ holds.
\item The called function returns a state where the property
  $E_1 \verb|&&| E_2 \verb!&&! \dots$ holds.
\item All memory locations of the pre-state that do not belong to the
  set $L_1 \cup L_2 \cup \dots$ remain allocated and are left unchanged in the
  post-state. The set $L_1 \cup L_2 \cup \dots$ itself is interpreted in the
  pre-state.
\end{itemize}

% TODO : donner une vision plus symétrique appelant/appelé d'un contrat

Notice that the multiplicity of clauses are proposed mainly to improve
readibility since the contract above is equivalent to the following
simplified one:
\begin{flushleft}\ttfamily
/*@ requires $P_1$ \verb|&&| $P_2$ \verb!&&! $\dots$; \\
~~@ assigns $L_1,L_2,\dots$; \\
~~@ ensures $E_1$ \verb|&&| $E_2$ \verb!&&! $\dots$; \\
~~@*/
\end{flushleft}
If no clause \requires\ is given, it defaults to
\verb!\true!, and similarly for \ensures\ clause. Giving no \assigns\ clause
means that locations assigned by the function are not specified, so
the caller has no information at all on this function's side
effects. See Section~\ref{sec:multiplecontracts} for more details on
default status of clauses.

\oldremark{Colaco}{

  les assigns doivent etre exhaustifs, et doivent etre prouve corrects
  selon le corps de la function.

}

\begin{example}
  The following function is given a simple contract for computation of
  the integer square root.

  \input{isqrt.pp}
%
  The contract means that the function must be called with a
  nonnegative argument, and returns a value satisfying
  the conjunction of the three \ensures{} clauses.
% [Patrick B.] START proposition:
  Inside these \ensures{} clauses, the use of the construct $\old(x)$
  is not necessary, even if the function modifies the formal operand
  $x$, because function calls modify a copy of the effective operands,
  and the effective operands remain unaltered.  In fact, $x$ denotes
  the effective operand of $isqrt$ calls which has the same value
  interpreted in the pre-state than in the post-state.
% END proposition

\end{example}

\begin{example}
  The following function is given a contract to specify that it increments
  the value pointed to by the pointer given as argument.

  \input{incrstar.pp}
%
  The contract means that the function must be called with a pointer
  \texttt{p} that points to a safely allocated memory location (see
  Section~\ref{sec:pointers} for details on the $\valid$ built-in
  predicate). It does not modify any memory location but the one
  pointed to by \texttt{p}. Finally, the \ensures\ clause specifies that
  the value \verb!*p! is incremented by one.
\end{example}

\subsection{Contracts with named behaviors}
\label{subsec:behaviors}
\index{function behavior}\index{behavior}
The general form of a function contract contains several named
behaviors (restricted to two behaviors, in the following, for readability).
\begin{flushleft}\ttfamily
/*@ requires $P$; \\
% ~~@ assigns $L$; \\
% ~~@ ensures $E$; \\
~~@ behavior $b_1$: \\
~~@ ~~assumes $A_1$; \\
~~@ ~~\notimplemented{requires $R_1$}; \\
~~@ ~~assigns $L_1$; \\
~~@ ~~ensures $E_1$; \\
~~@ behavior $b_2$:  \\
~~@ ~~assumes $A_2$; \\
~~@ ~~\notimplemented{requires $R_2$};  \\
~~@ ~~assigns $L_2$; \\
~~@ ~~ensures $E_2$; \\
% ~~@ decreases $m$ for $R$; \\
~~@*/
\end{flushleft}
The semantics of such a contract is as follows:
\begin{itemize}
\item The caller of the function must guarantee that the call is
  performed in a state where the property
  $P \verb|&&| (A_1 \verb|==>| R_1) \verb|&&| (A_2 \verb|==>| R_2)$ holds.
\item The called function returns a state where
% the property $E$ holds  and
the properties $\old(A_i) \verb|==>| E_i$ hold for each $i$.
\item For each $i$, if the function is called in a pre-state where
  $A_i$ holds, then each memory location of that pre-state that does not
  belong to the set $L_i$ remains allocated and is left unchanged
  in the post-state.
% In any case, locations of $L$ are unchanged.
\end{itemize}

Notice that the \requires{} clauses in the behaviors are proposed
mainly to improve readibility (to avoid some duplication of
formulas), since the contract above is equivalent to the following
simplified one:
\begin{flushleft}\ttfamily
/*@ requires $P \verb|&&| (A_1 \verb|==>| R_1) \verb|&&| (A_2 \verb|==>| R_2)$; \\
% ~~@ assigns $L$; \\
% ~~@ ensures $E$; \\
~~@ behavior $b_1$: \\
~~@ ~~assumes $A_1$; \\
~~@ ~~assigns $L_1$; \\
~~@ ~~ensures $E_1$; \\
~~@ behavior $b_2$:  \\
~~@ ~~assumes $A_2$; \\
~~@ ~~assigns $L_2$; \\
~~@ ~~ensures $E_2$; \\
% ~~@ decreases $m$ for $R$; \\
~~@*/
\end{flushleft}
Note that a simple contract such as
\begin{flushleft}\ttfamily
/*@ requires $P$; assigns $L$; ensures $E$; */
\end{flushleft}
is actually equivalent to a single named behavior as follows:
\begin{flushleft}\ttfamily
/*@ requires $P$; \\
~~@ behavior \textsl{<any name>}: \\
~~@ ~~assumes \verb|\true|; \\
~~@ ~~assigns $L$; \\
~~@ ~~ensures $E$; \\
~~@*/
\end{flushleft}
Similarly, global \assigns\ and \ensures\ clauses are equivalent to a
single named behavior. More precisely,
\begin{flushleft}\ttfamily
/*@ requires $P$; \\
~~@ assigns $L$; \\
~~@ ensures $E$; \\
~~@ behavior $b_1$: \dots \\
~~@ behavior $b_2$: \dots \\
~~@ \vdots \\
~~@*/
\end{flushleft}
is equivalent to
\begin{flushleft}\ttfamily
/*@ requires $P$; \\
~~@ behavior \textsl{<any name>}: \\
~~@ ~~assumes \verb|\true|; \\
~~@ ~~assigns $L$; \\
~~@ ~~ensures $E$; \\
~~@ behavior $b_1$: \dots \\
~~@ behavior $b_2$: \dots \\
~~@ \vdots \\
~~@*/
\end{flushleft}

\begin{example}
\label{ex:bsearch}
In the following, \texttt{bsearch($t,n,v$)} searches for element $v$
in array $t$ between indices $0$ and $n-1$.

\input{bsearch.pp}
%
The precondition requires array $t$ to be allocated at least from indices $0$
to $n-1$. The two named behaviors
correspond respectively to the successful behavior and the failing
behavior.

Since the function is performing a binary search, it requires the
array $t$ to be sorted in increasing order: this is the purpose of the
predicate named \texttt{t\_is\_sorted} in the \assumes\ clause of the
behavior named \verb|failure|.

See~\ref{sec:loop_annot} for a continuation of this example.
\end{example}

\begin{example}
  The following function illustrates the importance of different
  \assigns{} clauses for each behavior.

  \input{cond_assigns.pp}
%
  Its contract means that it assigns values pointed to by $p$ or by $q$,
  conditionally on the sign of $n$.
\end{example}


\subsubsection{Completeness of behaviors}
\label{sec:compl-behav}
Notice that in a contract with named behaviors, it is not required that
the disjunction of the $A_i$ is true, \emph{i.e.} it is not mandatory to
provide a ``complete'' set of behaviors.
If such a condition is seeked, it is possible to add the following clause
to a contract:
\index{complete behaviors}
\begin{flushleft}\ttfamily
/*@ ... \\
~~@ complete behaviors $b_1,\ldots,b_n$; \\
~~@*/
\end{flushleft}
It specifies that the set of behaviors $b_1,\ldots,b_n$ is complete \emph{i.e.}
that
\[
R \Rightarrow \bigvee_{1\leq i \leq n} A_i
\]
holds, where $R$ is the precondition of the contract. The
simplified version of that clause
\begin{flushleft}\ttfamily
/*@ ... \\
~~@ complete behaviors; \\
~~@*/
\end{flushleft}
means that all behaviors given in the contract should be taken into account.

Similarly, it is not required that two distinct behaviors are disjoint.
If desired, this can be specified with the following clause:
\index{disjoint behaviors}
\begin{flushleft}\ttfamily
/*@ ... \\
~~@ disjoint behaviors $b_1,\ldots,b_n$; \\
~~@*/
\end{flushleft}
It means that the given behaviors are pairwise disjoint \emph{i.e.}
that, for all distinct $i$ and $j$,
\[
R \Rightarrow \lnot (A_i \land A_j)
\]
holds. The simplified version of that clause
\begin{flushleft}\ttfamily
/*@ ... \\
~~@ disjoint behaviors; \\
~~@*/
\end{flushleft}
means that all behaviors given in the contract should be taken into account.

\oldremark{Abandonne}{

  2) on veut faire des behaviors differents suivant le post-state
     -> clause 'post assumes'

  exemples : (voir aussi annexe (Error Handling without exception))

  3) On pourrait avoir envie de specifier que les behavior sont
     mutuellement exclusifs et/ou couvrent tous les cas SELON
     LEURS CLAUSES "post assumes".

     ON NE TRAITE PAS CE CAS S'IL N'Y A PAS DE BESOIN, et il est
     alors interdit d'utiliser les clauses "complete behavior" et
     "disjoint behavior" sur des behavior contenant des "post assumes"

     la semantique serait:

    La condition de d'exclusion mutuelle des cas de behaviors
    est: pour toute paire de behavior $B_1$ et $B_2$ : postcondition
    supplementaire
\[
           not ((\old(assumes_1) et postassume_1)
                 et
                (\old(assumes_2) et postassume_2))
\]
    La condition de couverture des cas de behaviors est :

    la disjunction des $(\old(assumes_i) et postassume_i)$ est une postconditionn supplementaire

}


\oldremark{SD+Patrick}{
  Stephane confirme qu'AIRBUS utilise dans leur methodologie la notion
  d'assumes, mais pas celle de post-assumes.

  La possibilité d'ecrire des assumes permettra de reduire la taille
  des postconditions actuelles et conduira a moins de repetitions des
  conditions de behaviors.
  Par contre, placer les actuelles preconditions dans des behaviors
  devrait conduire a plus de repetitions dans les clauses requires.
  Il est important pour AIRBUS de pouvoir eviter les repetitions de termes
  dans les proprietes.

  Ne serait-il pas possible de définir dans les contrats de fonctions
  des prédicats ou termes parlant des operandes de la fonction, sans
  passer par des fonctions logiques auxquelles on passerait en
  argument les operandes de la fonctions ?

  Ces predicats ou termes aurait une portee locale a la fonction.
}


% \subsubsection{Error cases}

% See Section~\ref{sec:errorhandling} for a discussion about
% behaviors related to error cases.

\subsection{Memory locations}
\label{sec:locations}

There are several places where one needs to describe a set of memory
locations: in \assigns{} clauses of function contracts, or
in \verb|\separated| predicate (see Section~\ref{sec:separated}). More
generally, we introduce syntactic constructs to denote \emph{sets of
  terms}. A \emph{memory location} is then any set of terms denoting a set of
l-values\index{l-value}. Moreover, a location given as argument to
an \assigns{} clause must be a set of modifiable l-values, as described in
Section~\ref{sec:glossary}.

\oldremark{PB+VP}{
  préciser le statut de \textbackslash{}result: est-ce une modifiable
  l-value ou pas? D'un côté, ce n'en est pas vraiment une en C, mais
  on aimerait peut-être pouvoir écrire des assigns un peu raffinés
  comme \texttt{assigns \textbackslash{}result.a \textbackslash{}from i = i;}}

\begin{figure}
  \fbox{\begin{minipage}{0.97\textwidth}
      \input{loc.bnf}
    \end{minipage}}
  \caption{Grammar for sets of terms}
\label{fig:gram:locations}
\end{figure}

The grammar for sets of terms is given in
Figure~\ref{fig:gram:locations}. The semantics is given below,
where $s$ denotes any \textsl{tset}.
\begin{itemize}
\item \verb|\empty|\indexttbs{empty} denotes the empty set.
\item a simple term denotes a singleton set.
\item $s\ra id$ denotes the set of $x\ra id$ for each $x \in s$.
\item $s.id$ denotes the set of $x.id$ for each $x \in s$.
\item $*s$ denotes the set of $*x$ for each $x \in s$.
\item $\&s$ denotes the set of $\&x$ for each $x \in s$.
\item $s_1[s_2]$ denotes the set of $x_1[x_2]$ for each $x_1 \in s_1$
  and $x_2 \in s_2$.
\item $t_1 .. t_2$ denotes the set of integers between $t_1$ and
  $t_2$, included. If $t_1 > t_2$, this the same as \verb+\empty+
\item $\union(s_1,\ldots,s_n)$\indexttbs{union}
  denotes the union of $s_1,s_2,\ldots $ and $s_n$;
\item $\inter(s_1,\ldots,s_n)$\indexttbs{inter} denotes the intersection of
  $s_1,s_2,\ldots $ and $s_n$;
\item $s_1+s_2$ denotes the set of $x_1+x_2$ for each $x_1 \in s_1$
  and $x_2 \in s_2$;
\item $(s)$ denotes the same set as $s$;
\item $\{ s \mid b ; P \}$ denotes set
  comprehension\index{comprehension},
  that is the union of the sets denoted by $s$ for each value $b$ of binders
  satisfying predicate $P$ (binders $b$ are bound in both $s$ and $P$).
\end{itemize}

Note that \verb|\assigns \nothing| is equivalent to
\verb|\assigns \empty|; it is left for convenience.

\begin{example}
  The following function sets to 0 each cell of an array.

  \input{assigns_array.pp}
%
  It is annotated with three equivalent \assigns{} clauses, each one
  specifying that only the set of cells $\{t[0],\ldots,t[n-1]\}$ is modified.
\end{example}

\begin{example}
  \label{ex:locations-list}
  The following function increments each value stored in a linked
  list.

  \input{assigns_list.pp}
%
  The \assigns{} clause specifies that the set of modified memory
  locations is the set of fields $q\verb|->hd|$ for each pointer $q$
  reachable from \verb|p| following \verb|next| fields. See
  Section~\ref{sec:inductivepredicates} for details about the
  declaration of the predicate \texttt{reachable}.
\end{example}

\subsection{Default contracts, multiple contracts}
\label{sec:multiplecontracts}

A C function can be defined only once but declared several times.
It is allowed to annotate each of these declarations with contracts.
Those contracts are seen as a single contract with the union of the
\requires\ clauses and behaviors.

On the other hand a function may have no contract at all, or a
contract with missing clauses. Missing \verb|requires| and
\verb|ensures| clauses default to \verb!\true!.
If no \verb|assigns| clause is given, it remains unspecified. If the
function under consideration has only a declaration but no body, then
it means that it potentially modifies ``everything'', hence in practice
it will be impossible to verify anything about programs calling that
function; in other words giving it a contract is in practice
mandatory. On the other hand, if that function has a body, giving no
\verb|assigns| clause means in practice that it is left to tools to
compute an over-approximation of the sets of assigned locations.


\oldremark{Claude}{

  Attention, cette semantique est dangereuse car si en pratique on
  inclut une partie seulement du contrat, on peut oublier de verifier
  un requires.

  Autres solutions:

  1) interdire les contrats multiples

  2) proposer une syntaxe pour distinguer les contrats initiaux, et
     les contrats complementaires (comme le also de JML)

}

\section{Statement annotations}
\index{annotation}
\oldremark{Claude}{
  Il faut absolument ajouter des regles de portee, a plusieurs
  endroits dans ce document

  Note c'est maintenant fait pour les \at
}

Annotations on C statements are of three kinds:
\begin{itemize}
\item Assertions: \index{assertion}allowed before any C statement or
  at end of blocks.
\item\index{annotation!loop}\index{loop annotation}
  Loop annotations: invariant, assigns clause, variant; allowed
  before any loop statement: \verb|while|, \verb|for|, and
  \verb|do...while|.
\item\index{statement contract}\index{contract}
  Statement contracts: allowed before any C statement, specifying
  their behavior in a similar manner to C function contracts.
\end{itemize}

\subsection{Assertions}
\indextt{assert}

\begin{figure}[t]
  \begin{cadre}
    \input{assertions.bnf}
  \end{cadre}
  \caption{Grammar for assertions}
  \label{fig:gram:assertions}
\end{figure}

The syntax of assertions is given in Figure~\ref{fig:gram:assertions},
as an extension of the grammar of C statements.

\begin{itemize}
\item
  $\texttt{assert}~p$  means that $p$ must hold in the current state
  (the sequence point where the assertion occurs).

\item The variant $\texttt{for}~id_1,\ldots,id_k:~\texttt{assert}~p$
  associates the assertion to the named behaviors $id_i$, each
  of them being a behavior identifier for the current function (or a
  behavior of an enclosing block as defined later in
  Section~\ref{sec:statement_contract}).  It means that this assertion
  must hold only for the considered behaviors.
\end{itemize}

\oldremark{Claude}{unifier les 2 derniers cas? car a-t-on besoin de
  nommer un assert en dehors d'un behavior de la fonction? Surtout que
  l'on peut deja ecrire assert (id : p)
}

\subsection{Loop annotations}
\label{sec:loop_annot}

\begin{figure}[t]
  \begin{cadre}
    \input{loops.bnf}
  \end{cadre}
  \caption{Grammar for loop annotations}
  \label{fig:gram:loops}
\end{figure}

The syntax of loop annotations is given in Figure~\ref{fig:gram:loops},
as an extension of the grammar of C statements.

\subsubsection{Loop invariants}
\index{invariant}
The semantics of loop invariants is defined as follows: a loop
annotation of the form
\begin{flushleft}\ttfamily
/*@ loop invariant $I$; \\
~~@ loop assigns $L$; \\
% ~~@ loop variant $m$ for $R$; \\
~~@*/ \\
...
\end{flushleft}
specifies that the following conditions hold.
\begin{itemize}
\item The predicate $I$ holds before entering the loop
  (in the case of a
  \verb|for| loop, this means right after the initialization expression).
\item The predicate $I$ is an inductive invariant, that is if $I$ is
  assumed true in some state where the condition $c$ is also true, and
  if execution of the loop body in that state ends normally at the end
  of the body or with a \texttt{continue} statement, $I$ is true in
  the resulting state. If the loop condition has side
  effects, these are included in the loop body in a suitable way:
  \begin{itemize}
  \item for a $\verb|while|~(c)~s$ loop, $I$ must be preserved by the
    side-effects of $c$ followed by $s$;
  \item for a $\verb|for|(init;c;step)~s$ loop, $I$ must be preserved
    by the side-effects of $c$ followed by $s$ followed by step;
  \item for a $\verb|do|~s~\verb|while|~(c);$ loop, $I$ must be
    preserved by $s$ followed by the side-effects of $c$.
  \end{itemize}

\item At any loop iteration, any location that was allocated before
  entering the loop, and is not member of $L$ (interpreted in the
  current state), must remain allocated and has the same value as
  before entering the loop.
% [Patrick B.] START proposition:
  In fact, the \texttt{loop assigns} clause specifies an inductive
  invariant for the locations wich are not member of $L$.
% END proposition:
\end{itemize}

\paragraph{Remarks}
\begin{itemize}
\item \notimplemented[This is not checked]{The $\old$ construct is not
    allowed} in loop annotations. The \verb|\at| form should be used to
  refer to another state (see Section~\ref{sec:at}).
\item When a loop exits with \texttt{break} or \texttt{return} or
  \texttt{goto}, it is not required that the loop invariant holds.
% [Patrick B.] START proposition:
  In such cases, locations that are not member of $L$ can be disallocated
  or assigned between the end of the previous iteration and the exit statement.
% END proposition:
\end{itemize}

\begin{example}
\label{ex:bsearch2}
Here is a continuation of example~\ref{ex:bsearch}. Note the use of
a loop invariant associated to a function behavior.

\input{bsearch2.pp}

\end{example}

\subsubsection{Loop variants}
\index{variant}\index{termination}

Optionally, a loop annotation may include a loop variant of the form
\begin{flushleft}\ttfamily
/*@ loop variant $m$; \\
~~@*/ \\
...
\end{flushleft}
where $m$ is a term of type \verb|integer|.

The semantics is as follows: for each loop iteration that terminates
normally or with \texttt{continue}, the value of $m$ at end of the
iteration must be smaller that its value at the beginning of the
iteration. Moreover, its value at the beginning must be nonnegative.
Note that the value of $m$ at loop exit might be
negative. It does not compromise termination of the
loop. Here is an example:
\begin{example}
  \label{ex:loopvariant}
  \input{loopvariantnegative.pp}
\end{example}

It is also possible to specify termination orderings other than the
usual order on integers, using the additional \verb|for|
modifier. This is explained in Section~\ref{sec:termination}.

\subsubsection{General inductive invariants}
\index{invariant}
It is actually allowed to pose an inductive invariant
anywhere inside a loop body.
For example, it makes sense for a \texttt{do $s$
  while $(c)$;} loop to contain an invariant right after statement
$s$. Such an invariant is a kind of assertions, as
shown in Figure~\ref{fig:advancedinvariants}.

\begin{figure}[t]
  \begin{cadre}
    \input{generalinvariants.bnf}
  \end{cadre}
  \caption{Grammar for general inductive invariants}
  \label{fig:advancedinvariants}
\end{figure}

\begin{example}
  In the following example, the natural invariant holds at this point
  (\verb!\max! and \verb!\lambda! are introduced later in
  Section~\ref{sec:higherorder}).
  It would be less convenient to set an invariant at the beginning
  of the loop.
  \input{dowhile.pp}
\end{example}

More generally, loops can be introduced by \verb|goto|s.
As a consequence, such invariants may occur anywhere
inside a function's body. The meaning is that the invariant
holds at that point, much like an \texttt{assert}. Moreover, the
invariant must be inductive, \emph{i.e.} it must be preserved across a
loop iteration. Several invariants are allowed at different places in
a loop body. These extensions are useful when dealing with complex
control flows.

\oldremark{Claude}{TODO(citer une ref
a propos des invariants inductifs)
}

\begin{example}
Here is a program annotated with an invariant inside the loop body:
\input{advancedloopinvariants.pp}
The control-flow graph of the code is as follows
\begin{center}
\includegraphics{cfg.mps}
%\begin{tikzpicture}
%\path (0,4) node[fill=yellow,draw](n1){1}
%      (0,2) node[fill=yellow,draw](n2){2};
%\draw[->,very thick] (n1.south) -- (n2.north);
% \filldraw[fill=green!20] ellipse (1cm and 4mm);
% \path (-2,2) node[fill=yellow,draw] (eb) {Expected behavior}
%       (-2,1) node[fill=yellow,draw] (fs) {Formal Specification}
%       (0,0) node (proof) {Proofs}
%       (2,1) node[fill=blue!30,draw] (pm) {Program Model}
%       (2,2) node[fill=blue!30,draw] (prog) {Program};
% \draw[->,very thick] (eb.south) -- (fs.north);
% \draw[->,very thick,shorten >=5mm] (fs.south) -- (proof.north);
% \draw[->,very thick] (prog.south) -- (pm.north);
% \draw[->,very thick,shorten >=5mm] (pm.south) -- (proof.north);
%\end{tikzpicture}
\end{center}
The invariant is inductively preserved by the two paths that go from
node ``inv'' to itself.
\end{example}

\begin{example}
\input{inductiveloopinvariants.pp}
\end{example}

\subsection{Built-in construct \at{}}
\label{sec:at}
\indexttbs{at}
Statement annotations usually need another additional construct
$\at(e,id)$ referring to the value of the expression $e$ in the
state at label $id$. The label $id$ can be either a regular C label,
or a label added within a ghost statement as described in
Section~\ref{sec:ghost}. This label must be declared in the same
function as the occurrence of $\at(e,id)$, but unlike \texttt{goto}s,
more restrictive scoping rules must be respected:
\begin{itemize}
\item the label $id$ must occur before the occurrence of  $\at(e,id)$
  in the source;
\item the label $id$ must not be inside an inner block.
\end{itemize}
These rules are exactly the same rules as for the visibility of local
variables within C statements (see~\cite{KR88}, Section A11.1)

\subsubsection*{Default logic labels}
\indextt{Pre}\indextt{Here}\indextt{Old}\indextt{Post}
There are four predefined logic labels: \verb|Pre|, \verb|Here|,
\verb|Old| and \verb|Post|. $\old(e)$\indexttbs{old} is in fact syntactic sugar for $\at(e,Old)$.

\begin{itemize}

\item The label \verb|Here| is visible in all statement annotations,
  where it refers to the state where the annotation appears; and in
  all contracts, where it refers to the pre-state for the \texttt{requires} and the \texttt{assumes, variant, terminates, ...}
  clause and the post-state for other clauses.
It is also visible in data invariants, presented in Section~\ref{sec:invariants}.
\item The label \verb|Old| is visible in \verb|assigns| and
  \verb|ensures| clauses of all contracts (both for functions and for
  statement contracts described below in
  Section~\ref{sec:statement_contract}), and refers to the pre-state
  of this contract.
% [Patrick B.] START remarque:
% ``Old'' peut également s'utiliser dans les clauses relatives aux
% terminaisons abruptes des contrats d'instructions. Ce n'est pas dit ici.
% END remarque
\item The label \verb|Pre| is visible in all statement annotations,
  and refers to the pre-state of the function it occurs in.
\item The label \verb|Post| is visible in \verb|assigns| and \verb|ensures| clauses.

\end{itemize}

Note that no logic label is visible in global logic declarations
such as lemmas, axioms, definition of predicate or logic
functions. When such an annotation needs to refer to a given memory
state, it has to be given a label binder: this is described in
Section~\ref{sec:logicalstates}.

\begin{example}
  The code below implements the famous extended Euclid's algorithm
  for computing the greatest common divisor of two integers $x$ and
  $y$, while computing at the same time two \emph{B\'ezout coefficients} $p$
  and $q$ such that $p\times x+q\times y = \gcd(x,y)$.
  The loop invariant for the B\'ezout property needs to refer to the
  value of $x$ and $y$ in the pre-state of the function.
  \input{euclide.pp}
\end{example}

\begin{example}
  Here is a toy example illustrating tricky issues with \verb|\at| and
  labels: 

  \input{oldat.pp} 

  The two \verb|ensures| clauses are equivalent. The simpler clause
  \verb|t[i] == \old(t[i]) + 1| would be wrong because in
  \verb|\old(t[i])|, \verb|i| denotes the value of $i$ n the
  pre-state.

  Also, the \verb|assigns| clause \verb|i,t[i]| would be wrong too because
  again in \verb|t[i]|, the value of $i$ in the pre-state is
  considered.

\end{example}

\subsection{Statement contracts}
\label{sec:statement_contract}
\index{statement contract}\index{contract}
\begin{figure}[t]
  \begin{cadre}
    \input{st_contracts.bnf}
  \end{cadre}
  \caption{Grammar for statement contracts}
  \label{fig:gram:stcontracts}
\end{figure}

The grammar for statement contracts is given in
Figure~\ref{fig:gram:stcontracts}. It is similar to function
contracts, but without \decreases{} clause. Additionally, a statement contract
may refer to enclosing named behaviors, with the form \texttt{for $id$:\ldots}.
Such contracts are only valid for the
corresponding behaviors, in particular only under the
corresponding \assumes{} clause.

The clauses \texttt{breaks}, \texttt{continues} and \texttt{returns}
state properties on the program state which hold when the
annotated statement terminates abruptly with the corresponding
statement (\texttt{break}, \texttt{continue} or \texttt{return}).
% [Patrick B.] START proposition:
Inside these clauses, the construct $\old(e)$\indexttbs{old} is
allowed and denotes, like for statement contracts \texttt{assigns}
and \texttt{ensures}, the value of $e$ in the pre-state of the statement.
% END proposition
For the \texttt{returns} case, the \result\indexttbs{result} construct is allowed and
bounds to the returned value (if not a \texttt{void} function).

\begin{example}
  Here is an example which illustrates each of these special
  clauses for statement contracts.
  \input{abrupt_termination.pp}
\end{example}



\oldremark{PC+Claude}{

This allows to pose an assertion on function's state just before it
returns, (whatever way that return occurs) where it is still possible
to refer to local variables.

  avoir la meme chose sur toute fin de bloc.

  Mais il semble que c'est deja prevu... -> A VERIFIER qu'on la bien dit.

  De toute facon, il faut detailler

  Garder l'idee principale: on veut des annotations qui parlent a la
  fois de \result et des variables locales.

  A-t-on besoin de mettre cela pour toute expression ?

  exemple : x = x + (f(..) //@ assert ...\result...) REFUSE'

}




\section{Termination}
\label{sec:termination}
\index{termination}
The property of termination concerns both loops and recursive function
calls.
% For that purpose, loops can be annotated with a \texttt{loop
%  variant}\index{loop variant} clause, and functions can be annotated
%with a \decreases{} clause.
Termination is guaranteed by attaching a measure function to each loop
and each recursive function.
By default, a measure is an
integer expression, and measures are compared using the usual ordering
over integers (Section~\ref{sec:integermeasures}). It is also possible
to define
measures into other domains and/or using a different ordering relation
(Section~\ref{sec:generalmeasures}).

\subsection{Integer measures}
\label{sec:integermeasures}
\indexttbs{decreases}\indexttbs{variant}
Functions are annotated with integer measures with the syntax
\begin{flushleft}\ttfamily
//@ decreases $e$ ;
\end{flushleft}
and loops are annotated similarly with the syntax
\begin{flushleft}\ttfamily
//@ loop variant $e$;
\end{flushleft}
where the logic expression $e$ has type \verb|integer|. For recursive
calls, or for loops, this expression must decrease for the relation
$R$ defined by
\[
R(x,y) ::= x > y ~\verb|&&|~ x \geq 0
\]
In other words, the measure must be a decreasing sequence of integers
which remain nonnegative, except possibly for the last value of the
sequence (See example~\ref{ex:loopvariant}).

\begin{example}
  In Example~\ref{ex:bsearch2}, a loop variant \verb|u-l| decreases
  at each iteration, and remains nonnegative, except at the last
  iteration where it may become negative.
\end{example}

\subsection{General measures}
\label{sec:generalmeasures}

More general measures on other types can be provided, using the
keyword \verb|for|. For functions it becomes
\begin{flushleft}\ttfamily
//@ decreases $e$ for $R$;
\end{flushleft}
and for loops
\begin{flushleft}\ttfamily
//@ loop variant $e$ for $R$;
\end{flushleft}
In those cases, the logic expression $e$ has some type $\tau$ and $R$
must be relation on $\tau$, that is a binary predicate declared as
\begin{flushleft}\ttfamily
//@ predicate $R(\tau~x,~\tau~y) \cdots$
\end{flushleft}
(see Section~\ref{sec:logicspec} for details). Of course, to guarantee
termination, it must be proved that $R$ is a well-founded relation.

\begin{example}
  The following example illustrates a variant annotation
  using a pair of integers, ordered lexicographically.
  \input{lexico.pp}
\end{example}

\subsection{Recursive function calls}

The precise semantics of measures on recursive calls, especially in
the general case of mutually recursive functions, is given as follows.
We call \emph{cluster} a set of mutually recursive functions which
is a strongly connected component of the call graph.
Within each cluster, each function must be annotated with a \decreases\
clause with the same relation $R$ (syntactically). Then, in the body
of any function $f$ of that cluster, any recursive call to a function
$g$ must occur in a state where the measure attached to $g$ is smaller
(w.r.t $R$) than the measure of $f$ in the pre-state of $f$. This also
applies when $g$ is $f$ itself.

\begin{example}
  Here are the classical factorial and Fibonacci functions:
  \input{fact.pp}
\end{example}

\begin{example}
  This example illustrates mutual recursion:
  \input{mutualrec.pp}
\end{example}

% \subsection{Function termination}

% TODO: a mettre plutot dans les contrats

% clause 'terminates P' specifie que si P est vrai dans le pre-state,
% alors la fonction ou le statement objet du contrat se termine en temps
% fini.

% pas de valeur par defaut

% Patrick propose plutot la negation: 'diverges P' car ce que l'on veut
% specifier c'est que la fonction ne boucle indefiniment.

% en faveur de prendre 'diverges' : c'est comme ca en JML.


\subsection{Non-terminating functions}
\label{sec:non-term-funct}
\indextt{terminates}
\experimental

There are cases where a function is not supposed to terminate. For
instance, the \verb|main| function of a reactive program might be a
\verb|while(1)| which indefinitely waits for an event to process. More
generally, a function can be expected to terminate only if some
preconditions are met. In those cases, a \verb|terminates| clause can
be added to the contract of the function, under the following form:

\begin{flushleft}\ttfamily
//@ terminates $p$;
\end{flushleft}

The semantics of such a clause is as follows: if $p$ holds, then the
function is guaranteed to terminate (more precisely, its
termination must be proved). If such a clause is not present (and in
particular if there is no function contract at all), it
defaults to \verb|terminates \true;| that is the function is supposed
to always terminate, which is the expected behavior of most
functions.

Note that nothing is specified for the case where $p$ does not hold:
the function may terminate or not. In particular,
\verb|terminates \false;| does not imply that the function loops
forever. A possible specification for a function that never terminates
is the following:
\begin{verbatim}
/*@ ensures \false;
    terminates \false;
*/
void f() { while(1); }
\end{verbatim}

\begin{example}
  A concrete example of a function that may not always terminate is
  the \verb|incr_list| function of example \ref{ex:locations-list}. In
  fact, another acceptable contract for this function is the following one:

\input{terminates_list.pp}
\end{example}


\section{Logic specifications}
\label{sec:logicspec}
\index{logic specification}\index{specification}
\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth} \input{logic.bnf}
    \end{minipage}}
  \caption{Grammar for global logic definitions}
\label{fig:gram:logic}
\end{figure}

The language of logic expressions used in annotations can be extended
by declarations of new logic types, and new constants, logic functions
and predicates. These declarations follows the classical setting of
\emph{algebraic specifications}.
The grammar for these declarations is given in Figure~\ref{fig:gram:logic}.

\subsection{Predicate and function definitions}

New functions and predicates can be \emph{defined} by explicit
expressions, given after an equal sign.

\begin{example}
  The following definitions \input{signdef.pp} illustrates the
  definition of a new predicate \texttt{is\_positive} with an integer
  parameter, and a new logic function \texttt{sign} with a real
  parameter returning an integer.
\end{example}

\subsection{Lemmas}

Lemmas are user-given propositions, a facility that might help theorem
provers to establish validity of ACSL specifications.

\begin{example}
  The following lemma
  \input{mean.pp}
  is a useful hint for program like binary search.
\end{example}

Of course, a complete verification of an ACSL specification has to
provide a proof for each lemma.


\subsection{Inductive predicates}
\label{sec:inductivepredicates}
\index{inductive predicates}

A predicate may also be defined by an inductive definition. The
grammar for those style of definitions is given on
Figure~\ref{fig:gram:inductive}.
\index{inductive definitions}
\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth} \input{inductive.bnf}
    \end{minipage}}
  \caption{Grammar for inductive definitions}
\label{fig:gram:inductive}
\end{figure}

In general, an inductive definition of a predicate $P$ has the form
\begin{flushleft}\ttfamily
/*@ inductive $P(x_1,\ldots,x_n)$ \{ \\
~~@   case $c_1$ : $p_1$; \\
...\\
~~@   case $c_k$ : $p_k$; \\
~~@ \}
~~@*/ \\
\end{flushleft}
where each $c_i$ is an identifier and each $p_i$ is a proposition.

The semantics of such a definition is that $P$ is the least fixpoint
of the cases, i.e. is the smallest predicate (in the sense that it is
false the most often) satisfying the propositions $p_1,\ldots,p_k$.
With this general form, the existence of a least fixpoint is not
guaranteed, so tools might enforce syntactic conditions on the form of
inductive definitions. A standard syntactic restriction could be to
allow only propositions $p_i$ of the form
\begin{flushleft}\ttfamily
\verb|\forall| $y_1,\ldots,y_m$, $h_1$ ==> $\cdots$ ==> $h_l$ ==> $P(t_1,\ldots,t_n)$
\end{flushleft}
where $P$ occurs only positively in hypotheses $h_1,\ldots,h_l$
(definite Horn clauses,
\url{http://en.wikipedia.org/wiki/Horn_clause}).

\begin{example}
  The following introduce a predicate $\texttt{isgcd}(x,y,d)$ meaning
  that $d$ is the greatest common divisor of $x$ and $y$.
  \input{isgcd.pp}
  This definition uses definite Horn clauses, hence is consistent.
\end{example}

Example~\ref{ex:locations-list} already introduced an inductive definition of
reachability in linked-lists, and was also bases on definite Horn
clauses thus consistent.

\subsection{Axiomatic definitions}

Instead of an explicit definition, one may introduce an
\emph{axiomatic} definitions for a set of types, predicates and logic
functions, which amounts to declare the expected profiles and a set of
axioms. The grammar for those constructions is given on
Figure~\ref{fig:gram:logicdecl}.

\index{axiomatic}
\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth} \input{logicdecl.bnf}
    \end{minipage}}
  \caption{Grammar for axiomatic declarations}
\label{fig:gram:logicdecl}
\end{figure}

\begin{example}
  The following axiomatization introduce a theory of finite lists of
  integers a la LISP.
  \input{intlists.pp}  
\end{example}

Like inductive definitions, there is no syntactic conditions which
would guarantee axiomatic definitions to be consistent. It is usually
up to the user to ensure that the introduction of axioms does not lead
to a logical inconsistency.

\begin{example}
  The following axiomatization
  \input{sign.pp}
  is inconsistent since
  it implies \texttt{sign(0.0) == 1} and \texttt{sign(0.0) == -1},
  hence \texttt{-1 == 1}
\end{example}

\subsection{Polymorphic logic types}\label{sec:polym-logic-types}
\index{type!polymorphic}
\index{polymorphism}
\experimental

We consider here an algebraic specification setting based on
multi-sorted logic, where types can be \emph{polymorphic} that is
parametrized by other types. For example, one may declare the type of
polymorphic lists as
\input{listdecl.pp}
One can then consider for
instance list of integers (\texttt{list <integer>}), list of pointers
(e.g. \texttt{list <char*>}), list of list of reals (\texttt{list
  <list <real> >}\footnote{In this latter case, note that the two
  '\texttt{>}' must be separated by a space, to avoid confusion with
  the shift operator.}), etc.

The grammar of Figure~\ref{fig:gram:logic} contains rules for
declaring polymorphic types and using polymorphic type
expressions.
%Notice that type variables are identifiers preceded by
%the quote character.


\subsection{Recursive logic definitions}
\index{recursion}
Explicit definitions of logic functions and predicates can be
recursive. Declarations in the same bunch of logic declarations are
implicitly mutually recursive, so that mutually recursive functions are
possible too.

\begin{example}
  The following logic declaration
  \input{max_index.pp}
  defines a logic function which returns the maximal index $i$ between
  $0$ and $n-1$ such that $t[i]=0$.
\end{example}

%\begin{example} The following introduce $n$-ary trees using list of children.
%  \input{mutualrec.pp}
%\end{example}

Notice that there is no syntactic condition on such recursive
definitions, such as limitation to primitive recursion. In essence, a
recursive definition of the form \verb+f(args) = e;+ where \verb+f+
occurs in expression \verb+e+ is just a shortcut for axiomatic declaration of
\verb+f+ with an axiom \verb+\forall args; f(args) = e+.  In
other words, recursive definitions are not guaranteed to be
consistent, in the same way that axiomatics may introduce
inconsistency. Of course, tools might provide a way to check
consistency.

\subsection{Higher-order logic constructions}
\label{sec:higherorder}

\experimental

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth}
      \input{higherorder.bnf}
    \end{minipage}}
  \caption{Grammar for higher-order constructs}
\label{fig:gram:higherorder}
\end{figure}

Figure~\ref{fig:gram:higherorder} introduces new term constructs for
higher-order logic.
\begin{description}
\item[Abstraction]\indexttbs{lambda}
  The term $\bslambda~\tau_1~x_1,\ldots,\tau_n~x_n ~;~ t$
  denotes the $n$-ary logic function which maps $x_1,\ldots,x_n$ to
  $t$. It has the same precedence as \Forall and \Exists
\item[Extended quantifiers]
  Terms
  $\backslash quant(t_1,t_2,t_3)$
  where $quant$ is \texttt{max}\indexttbs{max}
  \texttt{min}\indexttbs{min}
  \texttt{sum}\indexttbs{sum}
  \texttt{product}\indexttbs{product}
  or \texttt{numof}\indexttbs{numof}
  are extended quantifications. $t_1$ and $t_2$ must have type
  \verb|integer|, and $t_3$ must be a unary function with an integer
  argument, and a numeric value (integer or real) except for
  \verb|\numof| for which it should have a boolean value. Their
  meanings are given as follows:
  \begin{eqnarray*}
    \verb|\max|(i,j,f) &=& \max \{ f(i),f(i+1), \ldots, f(j) \} \\
    \verb|\min|(i,j,f) &=& \min \{ f(i),f(i+1), \ldots, f(j) \} \\
    \verb|\sum|(i,j,f) &=& f(i)+f(i+1)+\cdots+f(j) \\
    \verb|\product|(i,j,f) &=& f(i)\times f(i+1) \times \cdots \times f(j) \\
    \verb|\numof|(i,j,f) &=& \# \{ k \mid i \leq k \leq j ~\verb|&&|~ f(k) \} \\
&=& \verb|\sum|(i,j,\verb|\lambda|~\verb|integer|~k ; f(k) ? 1 : 0)
  \end{eqnarray*}
  If $i>j$ then \verb|\sum| and \verb|\numof| above are 0,
  \verb|\product| is 1, and \verb|\max| and \verb|\min| are
  unspecified (see Section~\ref{sec:twovaluedlogic}).
\end{description}


\begin{example}
  \label{ex:higherorder}
  Function that sums the element of an array of doubles.
  \input{sum.pp}
\end{example}

\subsection{Concrete logic types}\label{sec:concrete-logic-types}
\index{type!concrete}
\experimental

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth}
      \index{record}\index{sum}
      \input{logictypedecl.bnf}
    \end{minipage}}
  \caption{Grammar for concrete logic types and pattern-matching}
\label{fig:gram:logictype}
\end{figure}

\oldremark{SD6+All}{

  faire une analogie avec les types sommes (de Caml, des spec algebriques)

  c'est plutot des types avec constructeurs dans les spec algebriques


}


Logic types may not only be declared but also be given a
definition. Defined logic types can be either under record
types\index{record}\index{type!record}, or sum
types\index{sum}\index{type!sum}. These definitions may be recursive.
For record types, the field access notation $t.id$ can be used, and
for sum types, a pattern-matching construction is available. The
grammar rules for these additional constructions are given in
Figure~\ref{fig:gram:logictype}

\oldremark{All}{

TODO: ajouter les types tableaux logiques: tableaux fonctionnels.

sucre syntaxique: t[i] pour select(t,i),  et dans le cas de code ghost, t[i] = e pour t = store(t,i,e)

Example: n-reines.


}

\begin{example}
  The declaration
  \input{listdef.pp}
  introduces a concrete definition of finite lists. The logic definition
  \input{listlengthdef.pp}
  defines the length of a list by recursion and pattern-matching.
\end{example}


\subsection{Hybrid functions and predicates}
\label{sec:logicalstates}
\index{hybrid!function}
\index{hybrid!predicate}

Logic functions and predicates may take both (pure) C types and logic
types arguments. Such an hybrid predicate (or function)
can either be defined with the same syntax as before (or axiomatized).

Be it defined either directly by an expression or through a set of axioms,
an hybrid function (or predicate) usually depends on one or
more program points, because it depends upon memory states, \emph{via}
expressions such as:
\begin{itemize}
\item pointer dereferencing: \verb|*p|, \verb|p->f|;
\item array access: \verb|t[i]|;
\item address-of operator: \verb|&x|;
\item built-in predicate depending on memory: \valid
% \item others ?
\end{itemize}
To make such a definition safe, it is mandatory to add after the
declared identifier a set of labels, between curly braces, as shown on
Figure~\ref{fig:gram:logiclabels}. Expressions
as above must then be enclosed into the \at{} construct to refer to a
given label. However, to ease reading of such logic expressions, it
is allowed to omit a label whenever there is only one label in the
context.

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth}
      \input{logiclabels.bnf}
    \end{minipage}}
  \caption{Grammar for logic declarations with labels}
\label{fig:gram:logiclabels}
\end{figure}


\begin{example}
  The following annotations declare a function which returns the
  number of occurrences of a given double in an array of doubles
  between the given indexes, together with the related axioms.  It
  should be noted that without labels, this axiomatization would be
  inconsistent, since the function would not depend on the values
  stored in t, hence the two last axioms would say both that $a=b+1$
  and $a=b$ for some $a$ and $b$.  
  \input{nb_occ.pp}
\end{example}

\begin{example}
  This second example defines a predicate which indicates whether two
  arrays of the same size are a permutation of each other. It
  illustrates the use of more than a single label. Thus, the \verb+\at+
  operator is mandatory here. Indeed the two arrays
  may come from two distinct memory states. Typically, one of the post
  condition of a sorting function would be \verb+permut{Pre,Post}(t,t)+.
  \input{permut.pp}
\end{example}

\oldremark{Claude}{Obsolete

\subsection{\texttt{reads} clauses}

declaration can be augmented with a \reads{} clause, with
the syntax given in Figure~\ref{fig:gram:logicreads}, which extends the
one of Figure~\ref{fig:gram:logic}. This feature is useful when a
function or a predicate is not easily definable, but can be more
easily axiomatized.

% VP: exemple redondant avec le suivant.
% \begin{example}
%   The following annotations declare a function which returns the number of
%   positive elements in an array of doubles between the given indexes
%   and the related axioms.
%   \input{num_of_pos.pp}
%   It should be noted that without the reads
%   clauses, this axiomatization would be inconsistent, since the
%   function would not depend on the values stored in t, hence the two
%   last axioms would say both that $a=b+1$ and $a=b$ for some $a$ and
%   $b$.

%   \oldremark{Claude}{
%     expliquer mieux

%     De plus, si l'on oublie la clause reads ça reste
%     correct, donc il faudrait prevoir un warning pour un predicat avec un
%     type pointeur en argument sans reads...
%   }
% \end{example}


\begin{example}
  The following annotations declare a function which returns the
  number of occurrences of a given double in an array of doubles
  between the given indexes, together with the related axioms.
  It should be noted that without the reads
  clauses, this axiomatization would be inconsistent, since the
  function would not depend on the values stored in t, hence the two
  last axioms would say both that $a=b+1$ and $a=b$ for some $a$ and
  $b$.
  \input{nb_occ_reads.pp}
\end{example}

\begin{example}
  This second example defines a predicate which indicates whether two
  arrays of the same size are a permutation of each other. It
  illustrates the use of more than a single label. Thus, the \verb+\at+
  operator is mandatory here. Indeed the two arrays
  may come from two distinct memory states. Typically, one of the post
  condition of a sorting function would be \verb+permut{Pre,Here}(t,t)+.
  \input{permut_reads.pp}
\end{example}

\oldremark{SD7+All}{

  As shown above, hybrid predicates and functions declared with reads
  clauses should be used with caution, since they do not depend only
  on the values of their parameters but also in an implicit way on the
  values stored in memory.

  reutiliser l'exemple en question ? (en le faisant mieux)

}
}

\subsection{Specification Modules}
\label{sec:specmodules}
\index{module}

\notimplemented{Specification modules can be provided} to encapsulate
several logic definitions, for example
\input{listmodule.pp}
Module components are then accessible using a qualified notation like
\notimplemented{\texttt{List::length}}.

Predefined algebraic specifications can be provided as
libraries\index{library} (see
section~\ref{chap:lib}), and imported using a construct like
\input{import.pp} where the file \verb|list.acsl| contains logic
definitions, like the \verb|List| module above.



\section{Pointers and physical adressing}
\label{sec:pointers}

\subsection{Memory blocks and pointer dereferencing}
\label{subsec:memory}
The following built-in functions and predicate allows to deal with the
memory state:
\begin{itemize}
\item \baseaddr{}\indexttbs{baseaddr}
returns the base address of an allocated pointer
\[
\baseaddr{} : \verb|`a *| \ra \verb|char*|
\]
\item \blocklength{}\indexttbs{blocklength}
  returns the length of the allocated block of a pointer
\[
\blocklength{} : \verb|`a *| \ra \verb|size_t|
\]

\item $\valid$\indexttbs{valid}
  applies to a set of terms (see Section~\ref{sec:locations})
  of some pointer type. $\valid(s)$ holds if and only if dereferencing any
  $p\in s$ is safe. In particular, $\valid(\verb+\empty+)$ holds.
\end{itemize}
Some shortcuts are provided:
\begin{itemize}
\item $\verb|\null|$\indexttbs{null} is an
  extra notation for the
  null pointer (\emph{i.e.} a shortcut for \verb|(void*)0|). Note that
  as in C itself (see \cite{standardc99}, par. 6.3.2.3),
  the constant \verb|0| can have any pointer type.
% \footnote{or to \texttt{NULL}, if
%    annotations are pre-processed are the appropriate inclusion of
%    \texttt{stddef.h} is added}
\item \notimplemented{$\offset(p)$}\indexttbs{offset}
  returns the offset between $p$ and its base address

  \begin{eqnarray*}
    \offset &:& \verb|`a *| \ra \verb|size_t|  \\
    \offset(p) &=& (\verb|char*|)p - \baseaddr(p)
  \end{eqnarray*}
  the following property holds: for any set of pointers $s$, $\valid(s)$ if and only if for all $p\in s$:
  \[
    \offset(p) \geq 0 \land \offset(p) + \verb|sizeof|(*p) \leq \blocklength(p)
\]

\end{itemize}

\subsection{Separation}
\label{sec:separated}

%pointer separation :
%\[
%p \not\equiv q := \baseaddr(p) \neq \baseaddr(q) \lor |(\verb|char*|)p - (\verb|char*|)q| \geq \max(\sizeof(p),\sizeof(q))
%\]

\experimental

$\separated(loc_1,..,loc_n)$\indexttbs{separated}
means that for each
$i\neq j$, the intersection of $loc_i$ and $loc_j$ is empty. Each
$loc_i$ is a set of terms as defined in Section~\ref{sec:locations}.



\subsection{Allocation and deallocation}

\experimental

\oldremark{PC}{

quid de la pile -> a voir

}
The following built-in predicates allow to deal with allocation and
deallocation of memory blocks. They can be used in a postcondition
\begin{itemize}
\item $\fresh(p)$\indexttbs{fresh}
indicates that $p$ was not allocated in the pre-state.

\item \notimplemented{$\freed(p)$\indexttbs{freed}},
  indicates that $p$ was allocated in the pre-state but that it is not
  the case in the post-state.
\end{itemize}

\section{Sets as first-class values}
\index{location}
Sets of terms, as defined in Section~\ref{sec:locations},
can be used as first-class values in
annotations. All the elements of such a set must share the same type
(modulo the usual implicit conversions).
Sets have the built-in type $set<A>$\index{set@\texttt{set} type}
where $A$ is the type of terms contained in the set.

In addition, it is possible to consider sets of pointers to values of
different types. In this case, \notimplemented[Currently mixing
pointers of different types in such a set leads to a \texttt{set<void*>}
value. The expansion must be done manually.]{the set is of type $set<char*>$ and
each of its elements $e$ is converted to $(char*)e + (0..sizeof(*e)-1)$}.

\begin{example}
  Here is an example where we defined the \emph{footprint} of a
  structure, that is the set of locations that can be accessed from an
  object of this type.

  \input{footprint.pp}

  Notice that in the first definition, since union is made with a set<char*> and a set<int*>,
  the result is a set<char*> (accordingly to typing of union). In
  other words, the two definitions above are equivalent.

  This logic function can be used as argument of \separated or in
  assigns clause.
\end{example}

Thus, the \separated predicate satisfies the following property:
\[
\begin{array}{l}
\separated(l_1 : set<\tau_1*>,l_2 : set<\tau_2*>) \texttt{<==>} \\
\quad \forall \tau_1* p; \forall \tau_2* q;
   p \in l_1 \land q \in l_2 \ra \\
\qquad    \forall \integer i,j;
      0 \leq i < \sizeof(\tau_1) \land 0 \leq j < \sizeof(\tau_2) \ra
      (\verb|char*|)p + i \neq (\verb|char*|)q + j
    \end{array}
\]
and a clause \verb+assigns+ $l_1,..,l_n$ is equivalent
to the postcondition
\[
\forall char* p; \separated(\union(\&l_1,..,\&l_n),p) ==> *p == \old(*p)
\]


\section{Abnormal termination}

\experimental

It is used to give behavioral properties to the \verb|main| function
or to any function that may exit the program, \emph{e.g.} by calling
the \verb|exit| function.
Such a behavior can be written under the following form:

\input{exitbehavior.bnf}

In an \textsl{ensures-clause}, \result is bound to the return code,
\emph{e.g} the value returned by \verb|main| or the argument passed
to \verb|exit|.

\oldremark{PC}{

  utilite de la clause assigns ?

}

\section{Dependencies information}
\label{sec:func-dep}

\experimental

An extended syntax of \assigns clauses, described in
Figure~\ref{fig:gram:dep} allows to specify data
dependencies\index{dependency} and
\emph{functional expressions}\index{functional expression}.

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth}
      \input{dependencies.bnf}
    \end{minipage}}
  \caption{Grammar for dependencies information}
\label{fig:gram:dep}
\end{figure}

Such a clause indicates that the assigned values can only depend upon
the locations mentioned in the \verb+\from+ part of the
clause. Again, this is an over-approximation: all of the locations
involved in the computation of the modified values must be present,
but some of locations might not be used in practice. If the
\verb+from+ clause is absent, all of the locations reachable at the
given point of the program are supposed to be used.
Moreover, for a single location, it is possible to give the precise
relation between its final value and the value of its
dependencies. This expression is evaluated in the pre-state of the
corresponding contract.

\begin{example}
  The following example is a variation over the \verb+array_sum+
  function in example~\ref{ex:higherorder}, in which the values of
  the array are added to a global variable \verb+total+.

  \input{sum2.pp}

\end{example}


\begin{example}
  % This exemple is referenced in a previous section.
  The composite element modifier operators are useful additional constructs for such functional expressions.
  \input{modifier.pp}
\end{example}

\oldremark{All}{

  Ceci n'est pas au bon endroit, et n'est peut-etre pas du tout utile

\begin{itemize}
\item functional  of array : \notimplemented{$\{ t {\tt for} [i] {\tt:} e \} $}
\item functional update of struct : \notimplemented{$\{ s {\tt for} f {\tt:} e \} $}

\item arrays or structs given extensionaly, syntax like for C
  initializers :  \notimplemented{$\{ t_1, \ldots, t_n \}$}
\end{itemize}
%trouver une syntaxe pour introduire les noms des fonctions implicites
%derriere la construction
}

\oldremark{PC}{

  Ne comprends pas ce que ca veut dire

}

\section{Data invariants}
\label{sec:invariants}
\index{data invariant}\index{global invariant}\index{type invariant}
\index{invariant!data}\index{invariant!global}\index{invariant!type}
Data invariants are properties on data that are supposed to hold
permanently during the lifetime of these data. In ACSL, we distinguish
between:
\begin{itemize}
\item \emph{global} invariants and \emph{type} invariants: the former
  only apply to specified global variables, whereas the latter are
  associated to a static type, and apply to any variables of
  the corresponding type;
\item \emph{strong} invariants and \emph{weak} invariants:
  \index{invariant!strong}\index{invariant!weak}
  strong
  invariants must be valid at any time during program execution
  (more precisely at any \emph{sequence point} as defined in the C
  standard), whereas weak invariants must be valid at \emph{function
    boundaries} (function entrance and exit) but can be violated in
  between.
\end{itemize}

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth}
      \input{data_invariants.bnf}
    \end{minipage}}
  \caption{Grammar for declarations of data invariants}
\label{fig:gram:datainvariants}
\end{figure}

The syntax for declaring data invariants is given in
Figure~\ref{fig:gram:datainvariants}. The strength modifier defaults
to \texttt{weak}.


\begin{example}
  In the following example, we declare
  \begin{enumerate}
  \item a weak global invariant \verb|a_is_positive| which specifies that
    global variable \texttt{a} should remain positive (weakly, so
    this property might be violated temporarily between functions
    calls);
  \item a strong type invariant for variables of type \verb|temperature|;
  \item a weak type invariant for variables of type \verb|struct S|.
  \end{enumerate}
  \input{invariants.pp}
\end{example}

\oldremark{SD8}{

  montrer un example qui exprime des proprietes d'initialisation de
  variables globales, i.e un tableau contient des valeurs distinctes 2
  a 2.

}

\subsection{Semantics}

The distinction between strong and weak invariants has to do with the
sequence points where the property is supposed to hold. The distinction
between global and type invariants has to do with the set of values on
which they are supposed to hold.

\begin{itemize}
\item Weak global invariants are properties which apply to global
  data and hold at any function entrance and function exit.

\item Strong global invariants are properties which apply to global
  data and hold at any step during execution (starting after
  initialization of these data).

\item A weak type invariant on type $\tau$ must hold at any function
  entrance and exit, and applies to any global variable or formal
  parameter which has static type $\tau$. If the result of the
  function is of type $\tau$, the result must also satisfy its
  weak invariant at function exit. Notice that it says nothing of fields,
  array elements, memory locations, etc. of type $\tau$.

  \oldremark{Claude}{

    et les var locales d'une fonction appelante ?

  }
\item A strong type invariant on type $\tau$ must hold at any step
  during execution, and applies to any global variable, local
  variable, or formal parameter which has static type $\tau$. If the
  result of the function is of type $\tau$, the result must also
  satisfy its strong invariant at function exit. Again, it says
  nothing of fields, array elements, memory locations, etc. of type
  $\tau$.

\end{itemize}


\begin{example}
  The following example illustrates the use of a data invariant on a local static variable.

  \input{out_char.pp}
\end{example}



\oldremark{PC}{

  remise en cause de la politique d'invariants



Weak invariants do not hold in any state but can be temporarily violated.
Such invariants are allowed under some sound policy~\cite{barnett04jot}.

}

\oldremark{Claude}{

  il faut decider comment sont lies les declarations d'invariants et
  les type associe'.

Example:


typedef struct S {
  int x;
} S;

void reset(S *p) {
  p->x = 0;
}

//@ type invariant I(S *p) { p.x > 0 }

-> reset ne respecte pas cet invariant
}

\begin{example}
  Here is a longer example, the famous Dijkstra's Dutch flag algorithm.\\
  \input{flag.pp}
\end{example}

\subsection{Model variables and model fields}
\index{model} \notimplemented{A \emph{model variable} is a variable
  introduced in the specification with the keyword
  {\texttt{model}}}. Its type must be a logic type. Analogously,
\notimplemented {structures may have \emph{model fields}}.  These are
used to provide abstract specifications to functions whose concrete
implementation must remain private.

\begin{figure}[b]
  \fbox{\begin{minipage}{0.97\linewidth}
      \input{model.bnf}
    \end{minipage}}
  \caption{Grammar for declarations of model variables and fields}
\label{fig:gram:model}
\end{figure}


The precise syntax for declaring model variables and fields is given
in Figure~\ref{fig:gram:model}. It is presented as additions to the
regular C grammar for variable declarations and structure field
declarations.

Informal semantics of model variables is as follows.
\begin{itemize}
\item Model variables can only appear in specifications. They are not
  lvalues, thus they cannot be assigned directly (unlike ghost variables,
  see below).
\item Nevertheless, a function contract might say that a model variable
  is assigned.
\item When a function contract mentions model variables:
  \begin{itemize}
  \item the precondition is implicitly existentially quantified over
    those variables;
  \item the postconditions are universally quantified over the old
    values of model variables, and existentially quantified over the new values.
  \end{itemize}
\end{itemize}
Thus, in practice, the only way to prove that a function body
satisfies a contract with model variables is to provide an invariant
relating model variables and concrete variables, as in the example
below.

\begin{example}\label{ex:model}
  Here is an example of a specification for a function which generates
  fresh integers. The contract is given in term of a model variable
  which is intended to represent the set of ``forbidden'' values,
  e.g. the values that have already been generated.
  \input{gen_spec_with_model.pp}
  The contract is expressed abstractly, telling that
  \begin{itemize}
  \item the forbidden set of values is modified;
  \item the value returned is not in the set of forbidden values, thus
    it is ``fresh'';
  \item the new set of forbidden values contains both the value
    returned and the previous forbidden values.
  \end{itemize}
  An implementation of this function might be as follows, where a
  decision has been made to generate values in increasing order, so
  that it is sufficient to record the last value generated. This decision
  is made explicit by an invariant.
  \input{gen_code.pp}
\end{example}

\paragraph{Remarks}

Although the syntax of model variables is close to JML model
variables, they differ in the sense that the type of a model variable
is a logic type, not a C type. Also, the semantics above is closer to
the one of B machines~\cite{abrial96:_b_book}. It has to be noticed
that program verification with model variables does not have a
well-established theoretical background~\cite{marche07,leavens07}, so
we deliberately do not provide a precise semantics in this document .

\section{Ghost variables and statements}
\label{sec:ghost}
\index{ghost}
Ghost variables and statements are like C variables and statements,
but visible only in the specifications. They are introduced by the
\verb|ghost| keyword at the beginning of the annotation
(i.e. \verb|/*@ ghost ... */| or \verb|//@ ghost ...| for a one-line
ghost code, as mentionned in section~\ref{sec:gener-about-annot}).
The grammar is given in Figure~\ref{fig:gram:ghost}, in which only the
first form of annotation is used. In this figure, the \textit{C-*}
non-terminals refer to the corresponding grammar rules of the ISO standard,
without any ACSL extension. Any non terminal of the form
\textit{ghost-non-term} for which no definition is given in the figure
represents the corresponding \textit{C-non-term} entry, in which any
\textit{entry} is substituted by \textit{ghost-entry}.

The variations with respect to the C
grammar are the following:
\begin{itemize}
\item Comments must be introduced by \verb|//| and extend until the
  end of the line (the ghost code itself is placed inside a C
  comment. \verb|/* ... */| would thus lead to incorrect C code).
\item It is however possible to write multi-line annotations for ghost
  code. These annotations are enclosed between \notimplemented{{\texttt{/*@}} and
  {\texttt{*/}}}. As in normal annotations, \verb|@|s at the beginning of a
  line and at the end of the comment (before the final \verb|*/|) are
  considered as blank.
  \oldremark{Claude}{
    faudrait supprimer ca. Je propose de maniere generale que le code
    annote sans les "/*@ ..*/" doit etre parsable aussi, meme s'il
    n'est pas parsable par un compilo.
}
\item \notimplemented{Logical types, such as {\texttt{integer}} or {\texttt{real}} are authorized in ghost code}.
\item \notimplemented{A non-ghost function can take ghost
    parameters}.
  If such a ghost
  clause is present in the declarator, then the list of ghost
  parameters must be non-empty and fixed (no vararg ghost). The call
  to the function must then provide the appropriate number of ghost parameters.
\item Any non-ghost \textit{if-statement} which does not have a non-ghost
  \verb|else| clause \notimplemented{can be augmented with a ghost
    one}. Similarly, a non-ghost
  \verb|switch| can have \notimplemented{a ghost {\texttt{default:}}
    clause}
  if it does not have a non-ghost one
  (there are however semantical restrictions for valid
  ghost labelled statements in a switch, see next paragraph for details).
\end{itemize}

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth}
      \input{ghost.bnf}
    \end{minipage}}
  \caption{Grammar for ghost statements}
\label{fig:gram:ghost}
\end{figure}


\paragraph{Semantics of Ghost Code}
\label{sec:semantics-ghost-code}
The question of semantics is essential for ghost code.
\notimplemented[Not checked in the current implementation]{Informally, the
semantics requires that ghost statements do not change the regular
program execution} This implies several conditions, including e.g:
\begin{itemize}
\item Ghost code cannot modify a non-ghost C variable.
\item Ghost code cannot modify a non-ghost structure field.
\item If $p$ is a ghost pointer pointing to a non-ghost memory location, then it is forbidden to assign $*p$.
\item Body of a ghost function is ghost code, hence do not modify
  non-ghost variables or fields.
\item If a non-ghost C function is called in ghost code, it must not
  modify non-ghost variables or fields.
\item If a structure has ghost fields, the \texttt{sizeof} of the
  structure is the same has the structure without ghost fields. Also,
  alignment of fields remains unchanged.
\item The control-flow graph of a function must not be altered by
  ghost statements. In particular, no ghost \verb|return| can appear
  in the body of a non-ghost function. Similarly, ghost
  \verb|goto|, \verb|break|, and continue \verb|continue| cannot jump
  outside of the innermost non-ghost enclosing block.
\end{itemize}

Semantics is specified as follows. First, one has to think that
program execution with ghost code involves a \emph{ghost memory heap}
and a \emph{ghost stack}, disjoint from the regular heap and stack.
Ghost variables lie in the ghost heap, so as the ghost field of
structures. Thus, every memory side-effect can be classified as ghost
or non-ghost. Then, the semantics is that memory side-effects of ghost
code must always be in the ghost heap or the ghost stack.

Notice that this semantics is not statically decidable.
\notimplemented{It is left to tools to provide approximations},
correct in the sense that any code
statically detected as ghost must be semantically ghost.

\begin{example}
  The following example shows some invalid assignments of ghost pointers:
  \input{ghostpointer.pp}
\end{example}

\begin{example}
  The following example shows some invalid ghost statements:
  \input{ghostcfg.pp}
\end{example}

\oldremark{Claude}{
  d'autres exemples, valides ou non valides, serait bienvenus
}

\oldremark{All}{

On veut des tableaux ghost de taille infinie -> cf tableaux fonctionnels de la section sur les assigns from

}

\paragraph{Differences between model variables and ghost variables}


A ghost variable is an additional specification variable which is
assigned in ghost code like any C variable. On the other hand, a model
variable cannot be assigned, but one can state it is modified and can
express properties about the new value, in a non-deterministic way,
using logic assertions and invariants.
In other words, one can say that specifications using ghost
variables modifications are executable.

\begin{example}
  \label{ex:gen_code}
  The example~\ref{ex:model} can also be specified with a ghost
  variable instead of a model variable:

  \input{gen_spec_with_ghost.pp}

\end{example}

\subsection{Volatile variables}\label{sec:volatile-variables}
\index{volatile}
\experimental

Volatile variables can not be used in logic terms, since reading such
a variable may have a side effect, in particular two successive reads
may return different values.

\begin{figure}[h]
  \fbox{\begin{minipage}{0.97\linewidth}
      \input{volatile-gram.bnf}
    \end{minipage}}
  \caption{Grammar for volatile constructs}
\label{fig:gram:volatile}
\end{figure}

Specifying properties of a volatile variable may be done via a
specific construct to attach two ghost functions to it. This
construct, described by the grammar of Figure~\ref{fig:gram:volatile}, has
the following shape:
\begin{flushleft}\ttfamily
volatile $\tau$ x;\\
\notimplemented{//@ volatile x reads f writes g;}
\end{flushleft}
where \verb|f| and \verb|g| are ghost functions with the following prototypes:
\begin{flushleft}\ttfamily
$\tau$ f(volatile $\tau$* p); \\
$\tau$ g(volatile $\tau$* p, $\tau$ v);
\end{flushleft}
This must be understood as a special construct to instrument the C
code, where each access to the variable \verb|x| is replaced by a call
to \verb|f(&x)|, and each assignment to \verb|x| of a value \verb|v|
is replaced by \verb|g(&x,v)|.

\begin{example}
  The following code is instrumented in order to inject fixed values
  at each read of variable \verb|x|, and collect written values.
  \input{volatile.pp}
\end{example}

\section{Undefined values, dangling pointers}

\subsection{Initialization}
\indexttbs{initialized}
\notimplemented{\texttt{\textbackslash{}initialized}} is a predicate taking a set of l-values as
argument and means that each l-value in this set is initialized.

\begin{example}
  In the following, the assertion is true.
  \input{initialized.pp}
\end{example}

\subsection{Unspecified values}
\indexttbs{specified}
\notimplemented{\texttt{\textbackslash{}specified}}
is a predicate taking a set of l-values as
argument and means that each l-value in this set has a \emph{specified
  value}: its value is not a dangling pointer (that is the address of
a local variable which is not in the scope anymore)

\begin{example}
  In the following, the assertion is not true.
  \input{specified.pp}
\end{example}



%\section{Module constructions}
%
%\experimental
%
%how to encapsulate several functions...


%\section{Attribute annotations}
%\label{sec:attribute_annot}
%
%\experimental
%
%These are annotations allowing to add attributes on variables, like regular C attributes (const, volatile, restrict).

% The purpose of these are various:
% \begin{itemize}
% \item specific verifications, like \url{http://www.cs.umd.edu/~jfoster/cqual}
% \item specific analyses, like region
%   analyses~\cite{hubert07hav} a la Cyclone~\cite{grossman02pldi}.
% \item allowing to attach model variables/fields to types that are not
%   structures~\cite{filliatr07queens}.
% \end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: "main"
%%% End:
