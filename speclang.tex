
\chapter{Specification language}
\label{chap:base}

\section{Lexical rules}

Lexical structure mostly follows that of ANSI C. A few differences
must be noted:
\begin{itemize}
\item the character \verb|'@'| is a blank character, thus equivalent
  to a space character.
\item the identifiers may start with the backslash character.
\end{itemize}

\experimental

\begin{itemize}
\item Some UTF8 characters may be used in place of some constructs: $\leq$ for \verb|<=|, $\forall$ for \Forall, etc.
\end{itemize}

\section{Logic expressions}
\label{sec:expressions}

This first section presents the language of expressions one can use in
annotations. These are called below \emph{logic expressions}. They
correspond to pure C expressions, with additional constructs
that we will introduce progressively.

\begin{figure}[p]
  \fbox{\begin{minipage}{0.97\textwidth} \input{term.bnf}
    \end{minipage}}
  \caption{Grammar of terms and predicates}
\label{fig:gram:term}
\end{figure}

Figure~\ref{fig:gram:term} presents the grammar for the basic
construction of logic expressions.  In that grammar, we distinguish
between \emph{predicates} and \emph{terms}, following the usual
distinction between propositions and terms in classical first-order
logic.  The grammar for binders and type expression is given
separately in Figure~\ref{fig:gram:binders}.

Remarks:
\begin{itemize}
\item The construct $t_1~relop_1~t_2~relop_2~t_3 \cdots t_k$ with
  several consecutive comparison operators is a shortcut for
  $t_1~relop_1~t_2 ~\verb|&&|~ t_2~relop_2~t_3 ~\verb|&&|~ \cdots $.

\item Function and predicate application are not applications of C
  functions, but of logic functions or predicates: see
  Section~\ref{sec:logicspec} for detail.
\end{itemize}


With respect to C pure expressions, the additional constructs are as follows:
\begin{description}
\item[Additional connectives]
  C operators \verb|&&|, \verb+||+ and \verb|!| are used as
  logical connectives. There are additional connectives \verb|==>| for
  implication, \verb|<==>| for equivalence and \verb|^^| for exclusive
  or. These logical connectives all have a bitwise counterpart, either
  C ones like \verb|&|, \verb+|+, \verb|~| and \verb|^|, or additional
  ones like the bitwise implication \verb|-->| and the bitwise
  equivalence \verb|<-->|.

\item[Quantification] Universal quantification is denoted by $\Forall
  \tau~x_1,\ldots,x_n; e$ and existential quantification by $\Exists
  \tau~ x_1,\ldots,x_n; e$.

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\textwidth} \input{binders.bnf}
    \end{minipage}}
  \caption{Grammar of binders and type expressions}
\label{fig:gram:binders}
\end{figure}

\item[Local binding] $\Let x = e_1 ; e_2$ introduces the name $x$ for
  expression $e_1$ which can be used in expression $e_2$.

\item[Conditional] $\If c \Then e_1 \Else e_2$. There is a subtlety
  here: the condition may be either a boolean term or a predicate.  In
  case of a predicate, the two branches must be also predicates, so
  that this construct acts as a connective with the following
  semantics: $\If c \Then e_1 \Else e_2$ is equivalent to $(c
  \verb|==>| e_1) \verb|&&| (\verb|!| c \verb|==>| e_2)$

\item[Syntactic naming] $id \verb|:| e$ is a term or a predicate
  equivalent to $e$. It is different from local naming with $\Let$:
  the name cannot be reused in other terms of predicates. It is only
  for readibility purposes.
\end{description}

\subsection{Operator precedence}

The precedence of C operators is conservatively extended with additional operators, as shown Figure~\ref{fig:precedence}. In this table, operators are sorted from highest to lowest priority. Operators of same priority are presented on the same line.


\begin{figure}[t]
  \begin{center}
    \begin{tabular}{|l|l|l|}
      \hline
      class 	& associativity & operators \\
      \hline
      selection & left & $\verb|[|\cdots\verb|]|$ \verb|->| \verb|.| \\
      unary 	& right & \verb|!| \verb|~| \verb|+| \verb|-| \verb|*| \verb|&| (cast) \verb|sizeof| \\
      multiplicative & left & \verb|*| \verb|/|  \verb|%| \\
      additive & left & \verb|+| \verb|-| \\
      shift 	& left & \verb|<<| \verb|>>| \\
      comparison & left & \verb|<| \verb|<=| \verb|>| \verb|>=| \\
      comparison & left & \verb|==| \verb|!=| \\
      bitwise and & left & \verb|&| \\
      bitwise xor & left & \verb|^| \\
      bitwise or & left & \verb+|+ \\
      bitwise implies & left & \verb+-->+ \\
      bitwise equiv & left & \verb+<-->+ \\
      connective and     & left & \verb|&&| \\
      connective xor & left & \verb+^^+ \\
      connective or & left & \verb+||+ \\
      connective implies & right & \verb|==>| \\
      connective equiv & left & \verb|<==>| \\
      ternary connective & right & $\cdots\verb|?|\cdots\verb|:|\cdots$ \\
      quantification & left & \Forall{} \Exists{} \\
      \hline
    \end{tabular}
  \end{center}
  \caption{Operator precedence}
\label{fig:precedence}
\end{figure}

\oldremark{Claude}{Le if ternaire a une precedence inferieure a
  l'equivalence, comme en JML, et contrairement a Caduceus, ou il est
  entre le ou et l'implication. Choix a valider, en particulier par
  Jean-Christophe}

\subsection{Semantics}
\label{sec:twovaluedlogic}

The semantics of logic expressions in ACSL is based on
mathematical first-order
logic~(\url{http://en.wikipedia.org/wiki/First_order_logic}), thus it
is a 2-valued logic with only total functions. Consequently,
expressions are never ``undefined''.

This design choice has to be emphasized because it is not
straightforward, and specification writer should be aware of that. The
issues are shared with specification languages with similar purposes,
like JML. A comprehensive list of issues has been compiled by Patrice
Chalin~\cite{chalin05ftfjp,chalin07icse}.

The choice of having only total functions allows to write for example
the term \verb|1/0|, or \verb|*p| when p is null (or more generally
when it points to a non-properly allocated memory cell). In
particular, the predicates
\begin{eqnarray*}
  1/0 &\verb|==|& 1/0 \\\relax
  *p &\verb|==|& *p
\end{eqnarray*}
are true, since they are instances of the general axiom $\forall x,
x\verb|==|x$ of first-order logic.
\oldremark{Anonyme}{Donc on ne peut pas introduire de construction
non-déterministe comme  $(\texttt{any} x \mid P)$}

So, it is up to the writer of specification to take care of writing
consistent assertions. For example, one might want to pose the lemma
(see Section~\ref{sec:logicspec}):
\input{div_lemma.pp}
where care is taken to have a premise requiring \verb|y| not zero.


\subsection{Typing}

The language of logic expressions is typed (as for \emph{multi-sorted}
first-order logic). Logic types are:
\begin{itemize}
\item ``Mathematical'' types: \verb|integer| for unbounded,
  mathematical integers; \verb|real| for real numbers, \verb|boolean|
  for booleans (with values written $\{ \verb|\true|, \verb|\false| \}$.
\item C types
\item Logic types introduced by specification writer (see
  Section~\ref{sec:logicspec}).
\end{itemize}
There are implicit coercions for numeric types:
\begin{itemize}
\item C integer-like types \verb|char|, \verb|short|, \verb|int| and
  \verb|long|, signed or unsigned, are all subtypes of type \verb|integer|,
\item \verb|integer| is itself a subtype of type \verb|real|,
\item C types \verb|float| and \verb|double| are subtypes of type \verb|real|.
\end{itemize}
Notes:
\begin{itemize}
\item There is a distinction between booleans and predicates. An
  expression like $x<y$, in a term position returns a boolean, and is
  also allowed in a predicate position.
\item Unlike in C, there is a distinction between booleans and
  integers. There is an implicit promotion from integers to booleans,
  thus one may writes \verb|x && y| instead of \verb|x != 0 && y != 0|.
  If the reverse conversion is needed, an explicit cast is
  required, e.g. \texttt{(int)(x>0)+1}, where false becomes 0 and true
  becomes 1.
\item Quantification can be made over any type: logic types and any C
  types. Quantification over pointers must be carefully designed,
  regarding the memory state where dereferencing is done: see
  Section~\ref{sec:quantification} and
  Section~\ref{sec:logicalstates}.
\end{itemize}

Formal typing rules for terms are given in appendix~\ref{sec:typingrules}


\subsection{Integer arithmetic and machine integers}

\begin{remark}{SD?}
  Preciser les architecture-dependant features: taille des int, etc.
\end{remark}

The following integer arithmetic operations apply to
\emph{mathematical integers}: addition, subtraction, multiplication,
unary minus. The value of a C variable of an integer type is promoted
to a mathematical integer. As a consequence, there is no such thing as
``overflow'' in logic expressions.

Division and modulo are also mathematical operations, whose results
are identical to those of C operations on C machine integers, thus
following the ANSI C99 conventions:
\begin{itemize}
\item if a b positive, a / b is ...
\item if a negative, b positive ...
\item TODO
\end{itemize}


\begin{todo}
  hexadecimal and octal constants: always non-negative. Suffixes u and
  l are allowed but meaningless.
\end{todo}

\subsubsection*{Casts and overflow}

In logic expressions, casting operations towards a C integer type $t$
(among \texttt{char}, \texttt{short}, \texttt{int} and \texttt{long},
signed or unsigned) is allowed, and is interpreted as follows: the
result is the unique value of the corresponding type that is congruent
to the mathematical result modulo the cardinal of this type (that is 2
to $8\times\sizeof(t)$). Example:
\begin{itemize}
\item (unsigned char)1000 is $1000 \bmod 256 = 232$
\end{itemize}

\oldremark{Claude}{Si la conjecture suivante est vraie, alors il
  faudrait en parler: Si e1 et e2 sont des expressions d'un type
  entier de C, quels qu'ils soient et si op est une operation binaire
  sur entiers, alors l'operation C $e1~op~e2$ (de type $\tau$),donne
  le meme resultat que l'expression logique $(\tau)(e_1~op~e_2)$ ou
  $op$ est l'operation logique sur $Z$. Ce cast permet donc a
  l'utilisateur de parler du resultat du calcul C d'une expressions
  dans la logique}

If one wants to express, in the logic, the result of the C
computations of an expression, one should add all necessary casts. For
example, the logic expression which denotes the result of C
computation of $x*y+z$ is $(int)((int)(x*y)+z)$

Important: implicit casts from integers to C integer type are forbidden.
Example:
\begin{flushleft}
  logic int f(int x) \{ x+1 \}
\end{flushleft}
is forbidden because the result (mathematical integer 0) must be cast to int.
Either write
\begin{flushleft}
  logic integer f(int x) \{ x+1 \}
\end{flushleft}
or
\begin{flushleft}
  logic int f(int x) \{ (int)(x+1) \}
\end{flushleft}
if you really want to return an int.



\begin{remark}{SD?}

  commentaire SD3: problem de perte de signe sur les entiers
  mathematiques -> demander des precisions.

\end{remark}

\subsubsection*{Quantification}
\label{sec:quantification}

Quantification can be either on mathematical \verb|integer| or bounded
types \verb|short|, \verb|char|, etc. In the latter case,
quantification corresponds to integer quantification over the
corresponding interval. Example
\begin{flushleft}

\end{flushleft}





\subsubsection*{Size of C integer types}

As in C, we do not specify the size of integer types. The sizeof
operator may be used in the logic. Constants giving maximum and minimum values of those types may be given in a library.


\oldremark{Claude}{we need macros \texttt{max\_range} \texttt{min\_range}
  taking a C integer type as argument, e.g.
  \texttt{max\_range(unsigned char) = 255} Ces macros, types et
  variables sont en principe définies dans des \texttt{.h} que la
  norme spécifie en grande partie (le nom l'est, le type peut y être
  contraint).  Il faudrait autant que possible se raprocher de ces
  noms.}

\subsubsection*{Enum types}

Enum types are also interpreted as mathematical integers. Casting of
an integer to a enum in the logic must give the same result as if it
was in the C code.

\subsubsection*{Bitwise operations}

Like arithmetic operations, bitwise operations apply to any
mathematical integers: any mathematical integer as a unique infinite
2-complement binary representation with infinitely many 0 (for
non-negative numbers) or 1 (for negative numbers) on the left. Then bitwise operations apply to these representation. Example:
\begin{itemize}
\item \verb|7 & 12| = $\cdots 00111 \verb|&| \cdots 001100$ = $\cdots 00100$ = 4
\item \verb+-8 | 5+ = $\cdots 11000 \verb+|+ \cdots 00101$ = $\cdots 11101$ = -3
\item \verb+~5+ = $\verb|~|\cdots 00101$ = $\cdots 111010$ = -6
\item \verb+-5 << 2+ = $\cdots 11011 \verb|<<| 2$ = $\cdots 11101100$ = -20
\item \verb+5 >> 2+ = $\cdots 00101 \verb|>>| 2$ = $\cdots 0001$ = 1
\item \verb+-5 >> 2+ = $\cdots 11011 \verb|>>| 2$ = $\cdots 1110$ = -2
\end{itemize}

\subsection{Real numbers and floating point numbers}

Floating-point constants and operations are interpreted as
mathematical real numbers. A C variable of type float or double is
implicitly promoted to a real. Integers are promoted to reals if necessary.
Example:
\begin{itemize}
\item $2 * 3.5$ is equal to the real number 7
\end{itemize}

Comparisons operators are interpreted as real operators too.

TODO: syntaxe pour abs et power ?

\begin{remark}{DP}
  Il faut de toute facon detailler les constructions de le spec pour
  parler des flottants: reprend-on celles de Caduceus ? exact(...)
  On peut laisser la main a JCF pour ce point

\end{remark}

\subsubsection*{Cast}

Casting from an integer type or a float type to a float or a double is
as in C: same conversion operations applies.

Casting a real number $x$ to a float or a double results in a real
number $y$ which is the closest to $x$ real number which is
representable in the target type.
\begin{itemize}
\item Example: (float)0.1 = TODO
\end{itemize}


\subsubsection*{Quantification}

Quantification over a variable of type \verb|real| is of course usual
quantification over real numbers.

Quantification sur (float) et (double) : meme probleme que
quantification sur les structures, etc.

\subsubsection*{Exact computations}

built-in \verb|exact|: a definir TODO

\begin{remark}{JCF}

Que deviennent les champs modeles de caduceus ?

Il faudrait les integrer a une traitement plus general des modeles
pour des types de donnees

\end{remark}


\section{Function contracts}
\label{sec:fn-behavior}



\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\textwidth}
      \input{fn_behavior.bnf}
    \end{minipage}}
    \caption{Grammar of function contracts}
  \label{fig:gram:contracts}
\end{figure}

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\textwidth}
      \input{oldandresult.bnf}
    \end{minipage}}
    \caption{\old and \result in terms}
  \label{fig:gram:oldandresult}
\end{figure}



The Figure~\ref{fig:gram:contracts} show a grammar for the function
contracts. The grammars for non-terminal locations is given later,
informally, they denotes C lvalues. We also introduce additional constructs
for terms as given on figure~\ref{fig:gram:oldandresult}. These are the following:
\begin{itemize}
\item $\old(e)$ denotes the value of $e$ in the pre-state of the function.
\item \result{} denotes the returned value of the function.
\item $\at(e,id)$ refer to the value of the expression $e$ in the
  state at label $id$, which has to appear before. Adding labels in
  annotations is also possible as ghost statements, see
  Section~\ref{sec:ghost}.

\end{itemize}


$\old(e)$ and \result{} can be used only in \ensures{} clauses,
whereas $\at(e,id)$ can be used everywhere.

\begin{remark}{Patrick}

 veut des $\old$ partout: designe toujours le pre-state de la function.

\end{remark}

\begin{remark}{Patrick}

donner des regles de portee pour les labels mentionnes dans les $\at$
\end{remark}


\oldremark{Patrick}{pourquoi seuls les ``behavior'' peuvent avoir un
  nom~? Ne peut-t'on pas avoir le ``ident:'' optionnel pour chacune
  des clauses~? Claude: parce que le nommage de behavior doit servir
  pour les associer a des clauses du corps de la fonction, p. ex.
  assert ou lopp invariant. Mais on peut aussi proposer par ailleurs
  de nommer des predicate ou terms, p. ex. avec la notation Caduceus
  (id : f) }

\subsection{Simple function contracts}

A simple function contract, having no named behavior, has the following
form:
\begin{flushleft}\ttfamily
/*@ requires $P_1$; \\
~~@ requires $P_2$; \\
~~@ assigns $L_1$; \\
~~@ assigns $L_2$; \\
~~@ ensures $E_1$; \\
~~@ ensures $E_2$; \\
~~@ decreases $m$ for $R$; \\
~~@*/
\end{flushleft}

The semantics of such a contract is as follows:
\begin{itemize}
\item The caller of the function must guarantee that it is called in a
  state where the property $P_1 \verb|&&| P_2$ holds.
\item The called function returns a state where the property
  $E_1 \verb|&&| E_2$ holds.
\item All memory locations of the pre-state that do not belong to the
  set $L_1 \cup L_2$ remain allocated and are left unchanged in the
  post-state.
\item If the decreases clause is present, the function can call only
  functions (including itself) which have also a decreases clause with
  the same relation $R$, which are called in a state for which the
  measure expression $m$ is smaller.

  \begin{remark}{PC}
    Attention, seule
    les fonctions appelees qui sont dans la meme composante fortement
    connexe du graphe d'appel sont concernant

    cad, les fonctions qui sont dans le meme paquet de fonctions
    mutuellement recursive.

    Dire qu'Il s'agit du meme R syntaxiquement


    Exemple: code jouet avec terminaison lexico sur une paire d'entiers

  \end{remark}


\begin{remark}{PC}

  ``je suis surpris par le melange entre l'ordre et la restriction de
  l'ensemble'' on a pas compris...

\end{remark}

\begin{remark}{Patrick}
 commencer par le cas sans R, avec la mesure naturelle
    sur les entiers
  \end{remark}

\end{itemize}

Notice that the multiplicity of clauses are proposed mainly to improve
readibility since the contract above is equivalent to the following
simplified one:
\begin{flushleft}\ttfamily
/*@ requires $P_1 \verb|&&| P_2$; \\
~~@ assigns $L_1,L_2$; \\
~~@ ensures $E_1 \verb|&&| E_2$; \\
~~@ decreases $m$ for $R$; \\
~~@*/
\end{flushleft}
Also, if no clause \requires is given, it defaults to requiring
`true', and similarly for \ensures clause. No clause \assigns means
potentially assigns ``everything''.

\begin{example}
  The following function is given a simple contract for computation of
  integer square root, rounded to the floor.

  \input{isqrt.pp}

  The contract means that the function must not be called with a
  negative argument, and in return the result satisfies the
  conjunction of the three predicates given in \ensures{} clauses.
\end{example}

\begin{example}
  The following function is given a contract to specify it increments
  the value pointed by the pointer given as argument.

  \input{incrstar.pp}

  The contract means that the function must be called with a pointer
  $p$ that points to a safely allocated memory location (See
  Section~\ref{sec:pointers} for details on $\valid$ built-in
  predicate). It modifies only the value pointed by $p$, and more
  precisely it increments it by one.
\end{example}

\subsection{Contracts with named behaviors}
\label{subsec:behaviors}

More generally, a function contract has the following form with named
behaviors (restricted to two behaviors for readability):
\begin{flushleft}\ttfamily
/*@ requires $P$; \\
~~@ assigns $L$; \\
~~@ ensures $E$; \\
~~@ behavior $b_1$: \\
~~@ ~~assumes $A_1$; \\
~~@ ~~requires $R_1$; \\
~~@ ~~assigns $L_1$; \\
~~@ ~~ensures $E_1$; \\
~~@ behavior $b_2$:  \\
~~@ ~~assumes $A_2$; \\
~~@ ~~requires $R_2$;  \\
~~@ ~~assigns $L_2$; \\
~~@ ~~ensures $E_2$; \\
~~@ decreases $m$ for $R$; \\
~~@*/
\end{flushleft}

The semantics of such a contract is as follows:
\begin{itemize}
\item The caller of the function must guarantee that it is called in a
  state where the property $P \verb|&&| (A_1 \verb|==>| R_1) \verb|&&|
  (A_2 \verb|==>| R_2)$ holds.
\item The called function returns a state where the property $E$ holds
  and the properties $\old(A_i) \verb|==>| E_i$ hold for each $i$.
\item For each $i$, if the function is called in a pre-state where
  $A_i$ holds, then all memory locations of that pre-state that do not
  belong to the set $L \cup L_i$ remain allocated and are left unchanged
  in the post-state. In any case, locations of $L$ are unchanged.
\end{itemize}

Notice that the \requires{} clauses in the behaviors are proposed
mainly to improve readibility (to avoid some duplication of
formulas), since the contract above is equivalent to the following
simplified one:
\begin{flushleft}\ttfamily
/*@ requires $P \verb|&&| (A_1 \verb|==>| R_1) \verb|&&| (A_2 \verb|==>| R_2)$; \\
~~@ assigns $L$; \\
~~@ ensures $E$; \\
~~@ behavior $b_1$: \\
~~@ ~~assumes $A_1$; \\
~~@ ~~assigns $L_1$; \\
~~@ ~~ensures $E_1$; \\
~~@ behavior $b_2$:  \\
~~@ ~~assumes $A_2$; \\
~~@ ~~assigns $L_2$; \\
~~@ ~~ensures $E_2$; \\
~~@ decreases $m$ for $R$; \\
~~@*/
\end{flushleft}

Notice that the contract does not impose that the disjunction of the
$A_i$ is true, that is it is not mandatory to provide a ``complete''
set of behaviors\footnote{Although, some tools might provide a way to check such a completeness}.

\begin{remark}{DP et SD}
\begin{verbatim}
  Preciser ce point, mieux que par une footnote

  discuter sur les points:

  . qu'est-ce qu'une spec complete : exhaustivite' des behaviors

  . behavior disjoint 2 a 2 ?

  proposition de claude : un equivalent de 'assumes' portant sur le
  post-state.

  behavior success:
    postassumes result >= 0

  behavior failure:
    postassumes result == -1

  alors la completude serait :
     disjunction des post_assumes = vrai

  MAIS remarque de Patrick: pourquoi ne pas parler de la disjonction
  des assumes ?


Decision du 24 octobre 2007:


  1) On peut avoir envie de specifier que les behavior sont
     mutuellement exclusifs et/ou couvrent tous les cas SELON
     LEURS CLAUSES "assumes".


     ajouter une clause supplementaire a un contrat de function:

     "disjoint behaviors"
     ou plus generalement
     "disjoint behaviors b1,...,bn"

     semantique: pour tout i,j, i !=j, not (assumes_i /\ assumes_j)

     et

     "complete behaviors"
     ou plus generalement
     "complete behaviors b1,...,bn"

     semantique: disj_{1<=i<=n} assumes_i (est valide)


  2) on veut faire des behaviors differents suivant le post-state
     -> clause 'post assumes'


  exemples : (voir aussi annexe (Error Handling without exception))



  /*@ behavior normal:
    @   post assumes \result == nmemb;
    @ behavior error:
    @   post assumes \result < nmemb ;
    @*/
  size_t fwrite(const  void  *ptr,  size_t  size,  size_t  nmemb,  FILE
       *stream);


  /*@ behavior normal:
    @   post assumes \result != NULL;
    @   ensures \valid( (char*)\result + (0..size-1))
    @ behavior error:
    @   post assumes \result == NULL ;
    @*/
  void *malloc(size_t size);


  3) On pourrait avoir envie de specifier que les behavior sont
     mutuellement exclusifs et/ou couvrent tous les cas SELON
     LEURS CLAUSES "post_assumes".

     ON NE TRAITE PAS CE CAS S'IL N'Y A PAS DE BESOIN, et il est
     alors interdit d'utiliser les clauses "complete behavior" et
     "disjoint behavior" sur des behavior contenant des "post assumes"

     la semantique serait:

    La condition de d'exclusion mutuelle des cas de behaviors
    est: pour toute paire de behavior B_1 et B_2 : post-condition
    supplementaire

           not ((\old(assumes_1) et \postassume_1)
                 et
                (\old(assumes_2) et \postassume_2))

    La condition de couverture des cas de behaviors est :

    la disjunction des (\old(assumes_i) et \postassume_i) est une post-conditionn supplementaire



\end{verbatim}
\end{remark}


\begin{example}
\label{ex:bsearch}
In the following, \texttt{bsearch($t,n,v$)} searches for element $v$ in array $t$ between indices $0$ and $n-1$.
\input{bsearch.pp}

\begin{remark}{Claude}Revoir la spec, quantifier sur des integer, mettre des ints a la place des shorts
\end{remark}

\begin{remark}{SD5}

  ajouter 'ensures -1 <= \result < n'

\end{remark}


The intention is to perform a binary search, which requires that the
array $t$ is sorted in increasing order: this is the purpose of the
predicate named \texttt{t\_is\_sorted} in the precondition. The
remaining of the precondition is to require that the array is safely
allocated for at least the index from $0$ to $n-1$. The two named
behaviors correspond respectively to the succesful behavior and the
failing behavior.

See~\ref{sec:loop_annot} for a continuation of this example.
\end{example}

\begin{example}
  The following function illustrates the importance of different
  \assigns{} clauses for each behavior.

  \input{cond_assigns.pp}

  Its contract means that it assigns values pointed by $p$ or by $q$,
  conditionally on the sign of $n$.
\end{example}







\begin{remark}{PC et YM}

  discuter les behavior specifiquement lies a des cas d'erreur

\end{remark}

\subsection{Memory locations}
\label{sec:locations}

There are several places where one needs to describe a set of memory locations:  in the above \assigns{} clauses of functions' contracts, or in the \reads{} clauses of Section~\ref{sec:logicspec}.

\begin{figure}
  \fbox{\begin{minipage}{0.97\textwidth}
      \input{loc.bnf}
    \end{minipage}}
  \caption{Grammar for memory locations}
\label{fig:gram:locations}
\end{figure}

The grammar for denoting such a set of memory locations is given
Figure~\ref{fig:gram:locations}.

The semantics is given as follows, where $s$ denotes any tset:
\begin{itemize}
\item a simple term denotes a singleton
\item $s\ra id$ denotes the set of $x\ra id$ for each $x \in s$
\item $s.id$ denotes the set of $x.id$ for each $x \in s$
\item $*s$ denotes the set of $*x$ for each $x \in s$
\item $s_1[s_2]$ denotes the set of $x_1[x_2]$ for each $x_1 \in s_1$
  and $x_2 \in s_2$
\item $t_1 .. t_2$ denotes the set of integers between $t_1$ and
  $t_2$, included.
\item $s_1,s_2$ denotes the union of $s_1$ and $s_2$
\item $s_1+s_2$ denotes the set of $x_1+x_2$ for each $x_1 \in s_1$ and $x_2 \in s_2$
\item $(s)$ denotes the same set as $s$
\item $\{ s \mid b ; P \}$ denotes set comprehension: set of term
  denoted by $s$ for each values of binders satisfying predicate $P$.
  Binders $b$ are bound in $s$ and $P$
\end{itemize}

A \emph{location} is any set of terms denoting a set of lvalues.
Only locations are valid as argument to \assigns{} clauses

\begin{example}
  The following function sets to 0 each cell of an array.

  \input{assigns_array.pp}

  It is annotated with three equivalent \assigns{} clauses, each one
  specifying that only the set of cells $\{t[0],\ldots,t[n-1]\}$ are modified.
\end{example}

\begin{example}
  The following function increments each values stored in a linked
  list.

  \input{assigns_list.pp}

  The \assigns{} clause specifies that the set of modified memory
  locations is the set of fields $q\verb|->hd|$ for each pointer $q$
  reachable from \verb|p| following \verb|next| fields. See
  Section~\ref{sec:logicspec} for details about the declaration of the
  logic predicate \texttt{reachable}.


\end{example}


\subsection{Contract variables}

\experimental

Binding variables over a complete behavior.

\subsection{Default contracts, multiple contracts}
\label{sec:multiplecontracts}

\begin{todo}rediger

  Default contract: requires true, assigns ``every locations''

  \footnote{Of course, tools might provide ways to generate more
    precise default contracts, e.g. by computing an over-approximation
    of the assigned memory locations from the body of the function}

\end{todo}

\begin{remark}{Claude}
  Limiter cela aux fonctions dont on n'a pas le corps.

  Cela revient a dire: pour une fonction dont on n'a pas le corps: il
  faut mettre une spec.

  par contre, pour les fonctions dont on a le corps, alors, il ne faut
  pas imposer cette spec par defaut car on perdrait de l'information.

\end{remark}

In C, a function can be defined only once but declared several times.
It is allowed to annotate each of these declarations with contracts.
Those contracts are seen as a single contract with the union of the
requires clauses and the behaviors.

\begin{remark}{Claude}

  Attention, cette semantique est dangereuse car si en pratique on
  inclut une partie seulement du contrat, on peut oublier de verifier
  un requires.

  Autres solutions:

  1) interdire les contrats multiples

  2) proposer une syntaxe pour distinguer les contrats initiaux, et
     les contrats complementaires (comme le also de JML)


\end{remark}


\section{Statement annotations}

\begin{remark}{Claude}

  Il faut absolument ajouter des regles de portee, a plusieurs
  endroits dans ce document

\end{remark}

Annotations on C statements are of three kinds:
\begin{itemize}
\item Loop annotations: invariant, assigns clause, variant; allowed
  before any loop statement: \verb|while|, \verb|for|, and
  \verb|do...while|.
\item Assertions and logic labels; allowed before any C statement or
  at end of blocks.
\item Statement contracts; allowed before any C statement, specifying
  their behavior in a similar manner as C functions.
\end{itemize}

\subsection{Loop annotations}
\label{sec:loop_annot}


\begin{figure}[t]
  \begin{cadre}
    \input{loops.bnf}
  \end{cadre}
  \caption{Grammar for loop annotations}
  \label{fig:gram:loops}
\end{figure}

\begin{remark}{Colaco}
  Expliquer d'abord le cas loop variant sans for

  Oui, le for devrait etre dans une sous-section avancee, avec un exemple.

\end{remark}

The syntax of loop annotations is given Figure~\ref{fig:gram:loops}
under the form of an addition to the grammar of C statements.

The semantics of loop invariants is defined as follows: a loop
annotation of the form
\begin{flushleft}\ttfamily
/*@ loop invariant $I$; \\
~~@ loop assigns $L$; \\
~~@ loop variant $m$ for $R$; \\
~~@*/ \\
...
\end{flushleft}
specifies that
\begin{itemize}
\item The predicate $I$ is initially true, that is true in the state
  before entering the loop (more precisely, in the case of a
  \verb|for| loop: after the initialization expression).
\item The predicate $I$ is an inductive invariant, that is if $I$ is
  assumed true in some state where the condition $c$ is also true, and
  if execution of the loop body in that state ends normally at the end
  of the body or with a \texttt{continue} statement, $I$ is true in
  the resulting state. Notice that if the loop condition has side
  effects, these are included in the loop body in a suitable way:
  \begin{itemize}
  \item for a $\verb|while|~(c)~s$ loop, $I$ must be preserved by the side-effects of $c$ followed by $s$
  \item for a $\verb|for|(init;c;step)~s$ loop, $I$ must be preserved by the side-effects of $c$ followed by $s$ followed by step
  \item for a $\verb|do|~s~\verb|while|~(c);$ loop, $I$ must be preserved by $s$ followed by the side-effects of $c$

  \item At any loop iteration, any location that was allocated before
    entering the loop, and is not member of $L$ in the current state,
    must be remain allocated and have to same value as before entering
    the loop.
  \item For each loop iteration that terminates normally or with
    \texttt{continue}, the value of $m$ at end of the iteration must be
    smaller that its value at the beginning of the iteration, with
    respect to relation $R$.
  \end{itemize}
\end{itemize}

Remarks:
\begin{itemize}
\item The $\old$ construct is not allowed in loop annotations. The \verb|at| form should be used to refer to another state.
\item When a loop exists with \texttt{break} or \texttt{return} or
  \texttt{goto}, it is not required that the loop invariant holds.
\end{itemize}

\begin{example}
\label{ex:bsearch2}
Here is a continuation of example~\ref{ex:bsearch}. Notice the use of
a loop invariant associated to a function behavior.

\input{bsearch2.pp}

\begin{remark}{PC}
  probleme de lecture : u-l confondu avec u-1
\end{remark}

\end{example}

\subsection*{Advanced loop invariants}

\experimental

It is allowed to pose a loop invariant not only at the beginning of
the loop iteration. For example, it make senses for a \texttt{do $s$
  while $(c)$;} loop to pose a loop invariant just after the loop body
$s$.

\begin{example}
  In the following, the loop invariant is correct, but it would not be
  correct if placed at the beginning of the loop.
  \input{dowhile.pp}
\end{example}

More generally, a loop invariant may occur anywhere inside the loop
body. The meaning is just that the invariant is true at that point,
much like an \texttt{assert}, but moreover impose that it is
inductive, i.e. is preserved by a loop iteration.  Several loop
invariants are allowed at different places in the loop body. These
advanced extensions can be useful for complex control flows, in
particular with \verb|goto|s.


\begin{remark}{PC}

  discuter la difference entre un loop invariant place arbitrairement
  dans le corps de boucle et un assert au meme endroit ? idee d'invariant inductif

\end{remark}

\subsection*{More about termination}

Property of termination concerns both loops and recursive function
calls.  For that purpose, loops can be annotated with a \texttt{loop
  variant}\index{loop variant} clause, and functions can be annotated
with a \decreases{} clause.

\subsubsection*{Integer measures}

Functions are annotated with integer measures with the form
\begin{flushleft}\ttfamily
//@ decreases $e$ ;
\end{flushleft}
and loops are annotated similarly with the form
\begin{flushleft}\ttfamily
//@ loop variant $e$;
\end{flushleft}
where the logic expression $e$ has type \verb|integer|. For recursive calls, or for loops, this expression must decrease for the relation $R$ defined by
\[
R(x,y) ::= x > y ~\verb|&&|~ x \geq 0
\]
In other words, the measure must be a decreasing sequence of integers
which remain non-negative, except possibly for the last value of the
sequence.

\begin{example}
  In Example~\ref{ex:bsearch2}, the loop variant \verb|u-l| decreases
  at each iteration, and remains non-negative, except at the last
  iteration where it may become negative.
\end{example}

\subsubsection*{General measures}

More general measures on other types can be provided, using the keyword \verb|for|. For function it becomes
\begin{flushleft}\ttfamily
//@ decreases $e$ for $R$;
\end{flushleft}
and for loops:
\begin{flushleft}\ttfamily
//@ loop variant $e$ for $R$;
\end{flushleft}
In those cases, the logic expression $e$ has some type $\tau$ and $R$ must be relation on $\tau$, that is a logic binary predicate declared by the form
\begin{flushleft}\ttfamily
//@ predicate $R(\tau~x,\tau~y) \cdots$
\end{flushleft}
(see Section~\ref{sec:logicspec} for details). Of course, to guarantee termination, it must be proved that $R$ is a well-founded relation.



\subsection{Assertions}

\begin{figure}[t]
  \begin{cadre}
    \input{assertions.bnf}
  \end{cadre}
  \caption{Grammar for assertions}
  \label{fig:gram:assertions}
\end{figure}

The syntax of those annotations is given Figure~\ref{fig:gram:assertions} under the form of a addition to the grammar of C statements.

\begin{itemize}
\item  The $\texttt{assert}~p$ clause means that $p$ must hold in the state
  before the statement.

\item The form $\texttt{for}~id_1,\ldots,id_k:~\texttt{assert}~p$
  variant associates the assertion to the named behaviors $id_i$, each
  of them being a behavior identifier for the current function (or a
  behavior of an enclosing block as defined later in
  Section~\ref{sec:statement_contract}).  It means that this assertion
  is meant to be valid only for the considered behaviors.
\end{itemize}

\oldremark{Claude}{unifier les 2 derniers cas? car a-t-on besoin de
  nommer un assert en dehors d'un behavior de la fonction? Surtout que l'on peut deja ecrire assert (id : p)}

\subsection*{Assertions on return}

\experimental

This allows to pose an assertion on function's state just before it
returns, (whatever way that return occurs) where it is still possible
to refer to local variables.

\begin{remark}{PC}

  avoir la meme chose sur toute fin de bloc.

  Mais il semble que c'est deja prevu... -> A VERIFIER qu'on la bien dit.

  De toute facon, il faut detailler

  Garder l'idee principal: on veut des annotations qui parlent a la
  fois de \result et des variables locales.

  A-t-on besoin de mettre cela pour toute expression ?

  exemple : x = x + (f(..) //@ assert ...\result...) REFUSE'

  par contre, c'est un cas particulier de clause ``returns'' de la section suivante
\end{remark}


\subsection{Statement contracts}
\label{sec:statement_contract}


\begin{figure}[t]
  \begin{cadre}
    \input{st_contracts.bnf}
  \end{cadre}
  \caption{Grammar for statement contracts}
  \label{fig:gram:stcontracts}
\end{figure}


The grammar for statement contracts is given in
Figure~\ref{fig:gram:stcontracts}. It is very similar to function
behaviors, but without \decreases{} clause. Additionally, behavior can
refer to enclosing named behaviors, with the form \texttt{for $id$ :
  \ldots}. Such behaviors are meant to be valid only for the
corresponding function behavior, in particular only under the
corresponding \assumes{} clause.

\begin{example}
  %\input{}
\end{example}

\begin{remark}{Claude}

  clauses ``breaks'' ``continues'' et ``returns''

\end{remark}

\section{Logic specifications}
\label{sec:logicspec}

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth} \input{logic.bnf}
    \end{minipage}}
  \caption{Grammar for logic declarations}
\label{fig:gram:logic}
\end{figure}

The language of logic expressions used in annotations can be extended
by declaration of new logic types, and new constants, logic functions
and predicates. These declarations follows the classical setting of
\emph{algebraic specifications}, in particular new functions and
predicates may be either \emph{defined} by explicit expressions, or
\emph{axiomatized} by a set of axioms. The grammer for these declarations is given Figure~\ref{fig:gram:logic}.

\oldremark{Claude}{``logic typedef'' au lieu de ``logic type'' ? Non ``type'' et c'est tout}

The difference between a lemma and an axiom is that a lemma is
supposed to be deductible from axioms: a redundant axioms in some sense.

\subsection{Polymorphic logic types}

\experimental

We consider here an algebraic specification setting based on
multi-sorted logic, where types can be \emph{polymorphic} that is
parameterized by other types. For example, one may declare the type of
polymorphic lists as \input{listdecl.pp} and then can consider for
example list of integers (\texttt{list <integer>}), list of pointers
(e.g. \texttt{list <char*>}), list of list of reals (\texttt{list
  <list <real> >}), etc.

The grammar of Figure~\ref{fig:gram:logic} contains the additional
rules for declaring polymorphic types, and for polymorphic type
expressions. Notice that type variables are identifiers preceded by
the quote character.

\subsection{Recursive logic definitions}

The explicit definitions of logic functions and predicates can be
recursive. Declarations in the same bunch of logic declarations are
implcitely mutually recursive, so mutually recursive functions are
possible too.

\begin{example}
  The following logic declaration
  \input{max_index.pp}
  defines a logic function which returns the maximal index $i$ between
  $0$ and $n-1$ such that $t[i]=0$.
\end{example}

%\begin{example} The following introduce $n$-ary trees using list of children.
%  \input{mutualrec.pp}
%\end{example}

\begin{remark}{PC}

  critere autorisant la recursion: primitive... NON

  -> a discuter

\end{remark}

\subsection{Higher-order logic constructions}

\experimental

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth}
      \input{higherorder.bnf}
    \end{minipage}}
  \caption{Grammar for higher-order constructs}
\label{fig:gram:higherorder}
\end{figure}

Figure~\ref{fig:gram:higherorder} introduces new term constructs for
higher-order logic.
\begin{description}
\item[Abstraction] The term $\verb|\lambda|~\tau~x_1,\ldots,x_n ~;~ t$
  denotes the $n$-ary logic function which maps $x_1,\ldots,x_n$ to
  $t$. It has the same precedence as \Forall and \Exists
\item[Extended quantifiers] Terms $quant(t_1,t_2,t_3)$ where $quant$
  is \verb|max|, \verb|min|, \verb|sum|, \verb|product|,or
  \verb|num_of|, are extended quantifications. $t_1$ and $t_2$ must
  have type \verb|integer|, and $t_3$ must be a unary function with an
  integer argument, and a numeric value (integer or real) except for
  \verb|\num_of| for which it should have a boolean value. Their
  meanings are given as follows:
  \begin{eqnarray*}
    \verb|\max|(i,j,f) &=& \max \{ f(i),f(i+1), \ldots, f(j) \} \\
    \verb|\min|(i,j,f) &=& \min \{ f(i),f(i+1), \ldots, f(j) \} \\
    \verb|\sum|(i,j,f) &=& f(i)+f(i+1)+\cdots+f(j) \\
    \verb|\product|(i,j,f) &=& f(i)\times f(i+1) \times \cdots \times f(j) \\
    \verb|\num_of|(i,j,f) &=& \# \{ k \mid i \leq k \leq j ~\verb|&&|~ f(k) \} \\
&=& \verb|\sum|(i,j,\verb|\lambda|~\verb|integer|~k ; f(k) ? 1 : 0)
  \end{eqnarray*}
  If $i>j$ then \verb|\sum| and \verb|num_of| above are 0,
  \verb|\product| is 1, and \verb|\max| and \verb|\min| are
  unspecified (see Section~\ref{sec:twovaluedlogic}).
\end{description}


\begin{example}
  Function that sums the element of an array of doubles.
  \input{sum.pp}
\end{example}

\subsection{Concrete logic types}

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth}
      \input{logictypedecl.bnf}
    \end{minipage}}
  \caption{Grammar for concrete logic types and pattern-matching}
\label{fig:gram:logictype}
\end{figure}

\begin{remark}{SD6}

  faire une analogie avec les types sommes (de Caml, des spec algebriques)

  c'est plutot des types avec constructeurs dans les spec algebriques

\end{remark}

\experimental

Logic types may not only be declared but also defined concretely, either under thr form of record types, or of sum types. These definitions may be recursive.
With record types, the field access notation $t.id$ can be used, and for sum types, a pattern-matching construction is available. The grammar rules for these additional constructions are given Figure~\ref{fig:gram:logictype}

\begin{example}
  The declaration
  \input{listdef.pp}
  introduce a concrete definition of finite lists. The logic definition
  \input{listlengthdef.pp}
  defines the length of a list by recursion and pattern-matching.
\end{example}


\begin{remark}{PC}

  proposer des syntaxes concretes pour des types logiques standards:
  ensemble en particulier, style ZB

\end{remark}

\subsection{Hybrid functions and predicates}
\label{sec:logicalstates}

These are functions or predicates which take both C types and logic
types as arguments. Such a predicate can either be defined with the
same syntax as before, or simply declared, but in the latter case the
declaration should usually be augmented with a \reads{} clause, with
the syntax given on Figure~\ref{fig:gram:logicreads} which extend the
one of Figure~\ref{fig:gram:logic}. This feature is useful when a
function or a predicate is not easily definable, but can be more
easily axiomatized. The specification writer should be very cautious
because the meaning of the axioms depends on the reads clause (see
example below)

It also allowed to put a reads clause on a definition, although in
such a case tools should provide a way to check that the reads clause
is compatible with the definition.



Expressions that relate to a program point are
\begin{itemize}
\item pointer dereferencing: *p, p ->f
\item array accesses: t[i]
\item address operator: \&x
\item built-in predicates: \valid, others ?
\item others ?
\end{itemize}

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth}
      \input{logicreads.bnf}
    \end{minipage}}
  \caption{Grammar for logic declarations with reads clauses}
\label{fig:gram:logicreads}
\end{figure}


\begin{example}
  The following declares a predicate which tells the number of
  positive elements in an array of doubles, between given indexes
  \input{num_of_pos.pp}
  It should be noticed that without the reads
  clauses, this axiomatization would be inconsistent, since the
  predicate would not depend on the values stored in t, hence the two
  last axioms would say both that $a=b+1$ and $a=b$ for some $a$ and
  $b$.
\end{example}

\begin{example}

  \input{nb_occ.pp}

  \input{permut.pp}

\end{example}

As examplified above, hybrid predicates and functions should be used
with caution, since they do not depend only on the values of their
parameters but also in an implicit way on the values stored in memory.

\begin{remark}{SD7}

  reutiliser l'exemple en question ? (en le faisant mieux)

\end{remark}

\subsection{Model variables and fields}

\experimental

Similar as JML's model variables, with the restriction that their type must be a logic type.

%\begin{example}
%  \todo{example}
%\end{example}

\subsection{Libraries of algebraic specifications}
\label{sec:specmodules}

\experimental

Specification modules can be provided to encapsulate several logic
definitions, for example
\input{listmodule.pp}
Module components are then accessible using a qualified notation like
\verb|List::length|.

Predefined algebraic specifications can be provided as libraries (see
section~\ref{chap:lib}), and imported using a construct like
\input{import.pp} where the file \verb|list.acsl| contains logic
definitions, like the \verb|List| module above.



\section{Pointers and physical adressing}
\label{sec:pointers}

\subsection{Memory blocks and pointer dereferencing}
\label{subsec:memory}

\begin{itemize}
\item \baseaddr{} base address of an allocated pointer
\[
\baseaddr{} : \verb|`a *| \ra \verb|char*|
\]
\item \blocklength{} length of the allocated block of a pointer
\[
\blocklength{} : \verb|`a *| \ra \verb|size_t|
\]

\item $\valid$ is a built-in predicate which applies to a set of terms
  of some pointer type. $\valid(s)$ is true whenever dereferencing any
  $p\in s$ is safe.
\end{itemize}
Some shortcuts are provided:
\begin{itemize}
\item $\verb|\null|$ is an extra notation for the null pointer (i.e. a shortcut for \verb|(void*)0|)
% \footnote{or to \texttt{NULL}, if
%    annotations are pre-processed are the appropriate inclusion of
%    \texttt{stddef.h} is added}
\item $\offset(p)$ returns the offset between p and its base address

  \begin{eqnarray*}
    \offset &:& \verb|`a *| \ra \verb|size_t|  \\
    \offset(p) &=& (\verb|char*|)p - \baseaddr(p)
  \end{eqnarray*}
  the following property holds: for any set of pointers $s$, $\valid(s)$ if and only if for all $p\in s$:
  \[
    \offset(p) \geq 0 \land \offset(p) + \verb|sizeof|(*p) \leq \blocklength(p)
\]

\end{itemize}


\subsection{Separation}

%pointer separation :
%\[
%p \not\equiv q := \baseaddr(p) \neq \baseaddr(q) \lor |(\verb|char*|)p - (\verb|char*|)q| \geq \max(\sizeof(p),\sizeof(q))
%\]

\experimental

$\separated(loc_1,..,loc_n)$ : means that for each $i\neq j$, the intersection of $loc_i$ and $loc_j$ is empty. Each $loc_i$ is a set of terms as defined in
Section~\ref{sec:locations}.

\subsection{Allocation and deallocation}

\experimental

\begin{remark}{PC}

quid de la pile -> a voir

\end{remark}

\begin{itemize}
\item built-in predicate \fresh, specifying in a post-condition that a
  pointer was not allocated in the pre-state.

\item built-in predicate \freed, specifying in a post-condition that a
  pointer was allocated in the pre-state but not anymore.
\end{itemize}

\section{Abnormal termination}

\experimental

It is used to give behavioral properties to the \verb|main| function
or to any function that may exit the program, e.g. calling \verb|exit|
function.

Such a behavior can be written with the form
\begin{verbatim}
  exit_behavior
    assumes
    assigns
    ensures ...
\end{verbatim}
where in ensures clause, \result is bound to the return code, e.g the
value returned by \verb|main| or the argument passed to \verb|exit|.

\begin{remark}{PC}

  utilite de la clause assigns ?

  probleme de l'exclusion avec les autres comportements. -> postassumes...


\end{remark}

\section{Dependencies information}

\oldremark{Patrick}{ne faut-t'il pas étendre les clauses ``assigns'' aux
  clauses ``from'' de CAVEAT prenant en comptes les locations lues, et les
  expressions fonctionnelles~?}

\experimental

An extended syntax of \assigns clauses allows to give dependencies:
\begin{flushleft}
//@ assigns $loc_1,\ldots,loc_n$ from $loc'_1,\ldots,loc'_k$ ;
\end{flushleft}
Moreover, dependencies can be made precise using \emph{functional expressions}:
\begin{flushleft}
//@ assigns $loc$ from $loc'_1,\ldots,loc'_k$ = term ;
\end{flushleft}

\experimental

Useful additional constructs for such functional expressions are constructions  of functional arrays :
\begin{itemize}
\item functional update of array : $\{ t[i] \verb|<-| e \} $
\item functional update of struct : $\{ s.f \verb|<-| e \} $
\item arrays or structs given extensionaly, syntax like for C initializers : $\{ t_1, \ldots, t_n \}$
\end{itemize}
%trouver une syntaxe pour introduire les noms des fonctions implicites
%derriere la construction

\begin{remark}{PC}

  Ne comprends pas ce que ca veut dire

\end{remark}

\section{Data invariants}
\label{sec:invariants}

\begin{remark}{SD8}

  montrer un example qui exprime des proprietes d'initialisation de
  variables globales, i.e un tableau contient des valeurs distinctes 2
  a 2.

\end{remark}

\experimental

\begin{itemize}
\item Global invariants: invariants on global variables
\item Type invariants: invariants on struct, union, typedef
\item \verb|initially|: predicates that should hold after global
  variables initialization
\end{itemize}

Examples:
\input{invariants.pp}

\subsection{Semantics}

\begin{itemize}
\item Global invariants: at any state of execution (after
  initialisation of global static data), the invariant holds.
\item Type invariants: at any state of execution, an allocated object
  of the corresponding static type satisfies the invariant.
\end{itemize}

\experimental

Weak invariants do not hold in any state but can be temporarily violated.
Such invariants are allowed under some sound policy~\cite{barnett04jot}.

\begin{remark}{PC}

  remise en cause de la politique d'invariants

\end{remark}

\section{Ghost variables and statements}
\label{sec:ghost}

\begin{remark}{SD9}

  illustrer l'utilisation de ghost pour specifier des proprietes temporelles


\end{remark}

\begin{remark}{JCF et CM}

les ghosts pourrait etre des types logiques.

et quid de prendre l'addresse d'une variable dans les formules logiques ?
autorise' ?

et de toute facon il y a besoin de critere de separation qui assure
que le code ghost ne change pas la semantique du code C. Cas de champ
ghost dans les structures -> change


\end{remark}

\experimental

\oldremark{Patrick}{les ``ghost statements'' correspondent à des
instructions d'observations des variables du C. Ces instructions
ne peuvent pas modifier les variables du C, mais que les ``ghost
variables''. Cela permet d'écrire plus facilement l'observateur
adéquat à la preuve des propriétés puisque les propriétés peuvent
porter à la fois sur les variables du C et les  ``ghost variables''.
}

  \oldremark{Patrick}{on a besoin de ``ghost braces'' pour
      écrire du ``ghost code''. Dans ce cas on n'en fait pas un point
      à part entière ici, on en parlera dans la section~\ref{sec:ghost}.
      Par contre, on a besoin de ``logic braces'' afin de créer un
      ``logic statement'' auquel on désire associer un ``statement
      behavior''. Faut'il en parler ici, comme on a parlé des
      ``logic label'' plus haut~?}

Ghost variables and statements are like C variables and statements, but visible only in the specifications. The grammar is given in Figure~\ref{fig:gram:ghost}.
\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth}
      \input{ghost.bnf}
    \end{minipage}}
  \caption{Grammar for ghost statements}
\label{fig:gram:ghost}
\end{figure}

\begin{remark}{DD4}

  Cette grammaire autorise de mettre des ghost dans les ghost, a refaire.

\end{remark}

The semantics requires that ghost statements do not change the regular
program execution, hence ghost statements modify only ghost variables.


\subsection{Volatile variables}

\begin{remark}{DD1}

  attacher des fonctions de lecture et d'ecriture a une variable volatile

\end{remark}

%\section{Module constructions}
%
%\experimental
%
%how to encapsulate several functions...


%\section{Attribute annotations}
%\label{sec:attribute_annot}
%
%\experimental
%
%These are annotations allowing to add attributes on variables, like regular C attributes (const, volatile, restrict).

% The purpose of these are various:
% \begin{itemize}
% \item specific verifications, like \url{http://www.cs.umd.edu/~jfoster/cqual}
% \item specific analyses, like region
%   analyses~\cite{hubert07hav} a la Cyclone~\cite{grossman02pldi}.
% \item allowing to attach model variables/fields to types that are not
%   structures~\cite{filliatr07queens}.
% \end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: "main"
%%% End:
