
\chapter{Specification language}
\label{chap:base}

\section{Logic expressions}
\label{sec:expressions}

This first section presents the language of expressions one can use in
the annotations. These are called below \emph{logic expressions}. They
corresponds more or less to pure C expressions, without function
calls, with additional constructs that we will introduce progressively.

\begin{figure}[p]
  \fbox{\begin{minipage}{0.97\textwidth} \input{term.bnf}
    \end{minipage}}
  \caption{Grammar of terms and predicates}
\label{fig:gram:term}
\end{figure}

Figure~\ref{fig:gram:term} presents the grammar for the basic
constructions of logic expressions.  In that grammar, we distinguish
between \emph{predicates} and \emph{terms}, following the usual
distinction between propositions and terms in classical first-order
logic.  The grammar for binders and type expression is given
separately Figure~\ref{fig:gram:binders}.

Remarks:
\begin{itemize}
\item The construct $t_1~relop_1~t_2~relop_2~t_3 \cdots t_k$ with
  several consecutive comparison operators is a shortcut for
  $t_1~relop_1~t_2 ~\verb|&&|~ t_2~relop_2~t_3 ~\verb|&&|~ \cdots $.

\item Function and predicate application are not applications of C
  functions, but of logic functions or predicates: see
  Section~\ref{sec:logicspec} for detail.
\end{itemize}


With respect to C pure expressions, the additional constructs are as follows:
\begin{description}
\item[Additional connectives]
  C operators \verb|&&|, \verb+||+ and \verb|!| are used as
  logical connectives. There are additional connectives \verb|==>| for
  implication, \verb|<==>| for equivalence, \verb|^^| for exclusive
  or.

\item[Quantification] Universal quantification is denoted by $\Forall
  \tau x_1,\ldots,x_n; e$ and existential quantification by $\Exists
  \tau x_1,\ldots,x_n; e$.  

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\textwidth} \input{binders.bnf}
    \end{minipage}}
  \caption{Grammar of binders and type expressions}
\label{fig:gram:binders}
\end{figure}

\item[Local binding] $\Let x = e_1 ; e_2$ introduce the name $x$ for
  expression $e_1$ which can be used in expression $e_2$.

\item[Conditional] $\If c \Then e_1 \Else e_2$. There is a subtlety
  here: the condition may be either a boolean term or a predicate.  In
  case of a predicate, the two branches must be also predicates, so
  that this construct acts as a connective with the following
  semantics: $\If c \Then e_1 \Else e_2$ is equivalent to $(c
  \verb|==>| e_1) \verb|&&| (\verb|!| c \verb|==>| e_2)$

\item[Syntactic naming] $id \verb|:| e$ is a term or a predicate
  equivalent to $e$. It is different from local naming with $\Let$:
  the name cannot be reused in other terms of predicates. It is only
  for readibility purposes.
\end{description}

\subsection{Operator precedence}

The precedence of C operators is conservatively extended with additional operators, as shown Figure~\ref{fig:precedence}. In this table, operators are sorted from highest to lowest priority. Operators of same priority are presented on the same line. 


\begin{figure}[t]
  \begin{center}
    \begin{tabular}{|l|l|l|}
      \hline
      class 	& associativity & operators \\
      \hline
      selection & left & $\verb|[|\cdots\verb|]|$ \verb|->| \verb|.| \\
      unary 	& right & \verb|!| \verb|~| \verb|+| \verb|-| \verb|*| \verb|&| (cast) \verb|sizeof| \\
      multiplicative & left & \verb|*| \verb|/|  \verb|%| \\
      additive & left & \verb|+| \verb|-| \\
      shift 	& left & \verb|<<| \verb|>>| \\
      comparison & left & \verb|<| \verb|<=| \verb|>| \verb|>=| \\
      comparison & left & \verb|==| \verb|!=| \\
      bitwise and & left & \verb|&| \\
      bitwise xor & left & \verb|^| \\
      bitwise or & left & \verb+|+ \\
      bitwise implies & left & \verb+-->+ \\
      bitwise equiv & left & \verb+<-->+ \\
      connective and     & left & \verb|&&| \\
      connective xor & left & \verb+^^+ \\
      connective or & left & \verb+||+ \\
      connective implies & right & \verb|==>| \\
      connective equiv & left & \verb|<==>| \\
      ternary connective & right & $\cdots\verb|?|\cdots\verb|:|\cdots$ \\
      quantification & left & \Forall{} \Exists{} \\
      \hline
    \end{tabular}
  \end{center}
  \caption{Operator precedence}
\label{fig:precedence}
\end{figure}

\remark{Claude}{Le if ternaire a une precedence inferieure a
  l'equivalence, comme en JML, et contrairement a Caduceus, ou il est
  entre le ou et l'implication. Choix a valider, en particulier par
  Jean-Christophe}

\subsection{Semantics}
\label{sec:twovaluedlogic}

The semantics of the logic expressions in ACSL is, as in classical
first-order logic, a 2-valued logic with only total functions, hence
expressions are never ``undefined''.

This design choice has to be emphasized because it is not
straightforward, and specification writer should be aware of that. The
issues are shared with specification languages with similar purposes,
like JML. A comprehensive list of issues has been compiled by Patrice
Chalin~\cite{chalin05ftfjp,chalin07icse}.

The choice of having only total functions allows to write for example
the term \verb|1/0|, or \verb|*p| when p is null (or more generally
when it points to a non-properly allocated memory cell). In
particular, the predicates
\begin{eqnarray*}
  1/0 &\verb|==|& 1/0 \\
  *p &\verb|==|& *p
\end{eqnarray*}
are true, since they are instances of the general axiom $\forall x,
x\verb|==|x$ of first-order logic.
\oldremark{Anonyme}{Donc on ne peut pas introduire de construction
non-déterministe comme  $(\texttt{any} x \mid P)$}

So, it is up to the writer of specification to take care of writing
consistent assertions. For example, one might want to pose the lemma
(see Section~\ref{sec:logicspec}):

\input{div_lemma.pp}

where care is taken to have a premise requiring \verb|y| not zero.

\todo{Distinction entre booleens et predicats. Est-ce que $x<y$ retourne un boolean et pas un entier. }

Notes:
\begin{itemize}
\item Quantification can be be made over any type (both C and
  logic types).
\item Quantification over pointers, structures, union, etc.
  are possible too. \todo{the meaning must be carefully defined: this is not only the allocated structures.}
\end{itemize}

\subsection{Typing}

The language of logic expression is typed. Logic types are:
\begin{itemize}
\item ``Mathematical'' types: \verb|integer| for unbounded,
  mathematical integers; \verb|real| for real numbers, \verb|boolean|
  for booleans $\{ \verb|true|, \verb|false| \}$.
\item C types
\item Logic types introduced by specification writer (see
  Section~\ref{sec:logicspec}.
\end{itemize}

There are implicit coercions for numeric types:
\begin{itemize}
\item C integer-like type \verb|char|, \verb|short|, \verb|int| and \verb|long|, signed or unsigned, are also of type \verb|integer|
\item \verb|integer| is itself a subtype of \verb|real|
\item \verb|float| and \verb|double| are also of type \verb|real|
\end{itemize}

\subsection*{Typing rules for terms}

\[
\frac{}{\Gamma \vdash id : \tau} \mbox{ if $id:\tau\in\Gamma$}
\]
\[
\frac{\Gamma \vdash t : \integer}{\Gamma \vdash op~t : \integer} \mbox{ if $op\in \{+,-,\tilde\}$}
\]
\[
\frac{\Gamma \vdash t : \boolean}{\Gamma \vdash !~t : \boolean} 
\]
\[
\frac{\Gamma \vdash t : \tau*}{\Gamma \vdash *t : \tau} 
\]
\[
\frac{\Gamma \vdash t : \tau}{\Gamma \vdash \&t : \tau*} 
\]
\[
\frac{\Gamma \vdash t_1 : \integer\qquad\Gamma \vdash t_2 : \integer}{\Gamma \vdash t_1~op~t_2 : \integer} \mbox{ if $op\in \{+,-,*,/,\%\}$}
\]
\[
\frac{\Gamma \vdash t_1 : \real\qquad\Gamma \vdash t_2 : \real}{\Gamma \vdash t_1~op~t_2 : \real} \mbox{ if $op\in \{+,-,*,/\}$}
\]
\[
\frac{\Gamma \vdash t_1 : \integer\qquad\Gamma \vdash t_2 : \integer}{\Gamma \vdash t_1~op~t_2 : \boolean} \mbox{ if $op\in \{==,!=,<=,<,>=,>\}$}
\]
\[
\frac{\Gamma \vdash t_1 : \real\qquad\Gamma \vdash t_2 : \real}{\Gamma \vdash t_1~op~t_2 : \boolean} \mbox{ if $op\in \{==,!=,<=,<,>=,>\}$}
\]
\[
\frac{\Gamma \vdash t_1 : \tau*\qquad\Gamma \vdash t_2 : \tau*}{\Gamma \vdash t_1~op~t_2 : \boolean} \mbox{ if $op\in \{==,!=,<=,<,>=,>\}$}
\]
\todo{Continuer}

\section{Function contracts}
\label{sec:fn-behavior}



\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\textwidth}
      \input{fn_behavior.bnf}
    \end{minipage}}
    \caption{Grammar of function contracts}
  \label{fig:gram:contracts}
\end{figure}

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\textwidth}
      \input{oldandresult.bnf}
    \end{minipage}}
    \caption{\old and \result in terms}
  \label{fig:gram:oldandresult}
\end{figure}



The Figure~\ref{fig:gram:contracts} show a grammar for the function
contracts. The grammars for non-terminal locations is given later,
informally, they denotes C l-values. We also introduce additional constructs
for terms as given on figure~\ref{fig:gram:oldandresult}. These are the following:
\begin{itemize}
\item $\old(e)$ denotes the value of $e$ in the pre-state of the function.
\item \result{} denotes the returned value of the function.
\end{itemize}


They both can be used only in \ensures{} clauses.


\oldremark{Patrick}{pourquoi seuls les ``behavior'' peuvent avoir un
  nom~? Ne peut-t'on pas avoir le ``ident:'' optionnel pour chacune
  des clauses~? Claude: parce que le nommage de behavior doit servir
  pour les associer a des clauses du corps de la fonction, p. ex.
  assert ou lopp invariant. Mais on peut aussi proposer par ailleurs
  de nommer des predicate ou terms, p. ex. avec la notation Caduceus
  (id : f) }

\subsection{Simple function contracts}

A simple function contract, having no named behavior, has the following
form:
\begin{flushleft}\ttfamily
/*@ requires $P_1$; \\
~~@ requires $P_2$; \\
~~@ assigns $L_1$; \\
~~@ assigns $L_2$; \\
~~@ ensures $E_1$; \\
~~@ ensures $E_2$; \\
~~@ decreases $m$ for $R$; \\
~~@*/
\end{flushleft}

The semantics of such a contract is as follows:
\begin{itemize}
\item The caller of the function must guarantee that it is called in a
  state where the property $P_1 \verb|&&| P_2$ holds.
\item The called function returns a state where the property
  $E_1 \verb|&&| E_2$ holds.
\item All memory locations of the pre-state that do not belong to the
  set $L_1 \cup L_2$ remain allocated and are left unchanged in the
  post-state.
\item If the decreases clause is present, the function can call only
  functions (including itself) which have also a decreases clause with
  the same relation $R$, which are called in a state for which the
  measure expression $m$ is smaller.
\end{itemize}

Notice that the multiplicity of clauses are proposed mainly to improve
readibility since the contract above is equivalent to the following
simplified one:
\begin{flushleft}\ttfamily
/*@ requires $P_1 \verb|&&| P_2$; \\
~~@ assigns $L_1,L_2$; \\
~~@ ensures $E_1 \verb|&&| E_2$; \\
~~@ decreases $m$ for $R$; \\
~~@*/
\end{flushleft}
Also, if no clause \requires is given, it defaults to requiring
`true', and similarly for \ensures clause. No clause \assigns means
potentially assigns ``everything''.

\begin{example}
  The following function is given a simple contract for computation of
  integer square root, rounded to the floor.  

  \input{isqrt.pp}

  The contract means that the function must not be called with a
  negative argument, and in return the result satisfies the
  conjunction of the three predicates given in \ensures{} clauses.
\end{example}

\begin{example}
  The following function is given a contract to specify it increments
  the value pointed by the pointer given as argument.

  \input{incrstar.pp}

  The contract means that the function must be called with a pointer
  $p$ that points to a safely allocated memory location (See
  Section~\ref{sec:pointers} for details on $\valid$ built-in
  predicate). It modifies only the value pointed by $p$, and more
  precisely it increments it by one.
\end{example}

\subsection{Contracts with named behaviors}

More generally, a function contract as the following form with named
behaviors (restricted to two behaviors for readability):
\begin{flushleft}\ttfamily
/*@ requires $P$; \\
~~@ assigns $L$; \\
~~@ ensures $E$; \\
~~@ behavior $b_1$: \\
~~@ ~~assumes $A_1$; \\
~~@ ~~requires $R_1$; \\
~~@ ~~assigns $L_1$; \\
~~@ ~~ensures $E_1$; \\
~~@ behavior $b_2$:  \\
~~@ ~~assumes $A_2$; \\
~~@ ~~requires $R_2$;  \\
~~@ ~~assigns $L_2$; \\
~~@ ~~ensures $E_2$; \\
~~@ decreases $m$ for $R$; \\
~~@r*/
\end{flushleft}

The semantics of such a contract is as follows:
\begin{itemize}
\item The caller of the function must guarantee that it is called in a
  state where the property $P \verb|&&| (A_1 \verb|==>| R_1) \verb|&&|
  (A_2 \verb|==>| R_2)$ holds.
\item The called function returns a state where the property $E$ holds
  and the properties $\old(A_i) \verb|==>| E_i$ hold for each $i$.
\item For each $i$, if the function is called in a pre-state where
  $A_i$ holds, then all memory locations of that pre-state that do not
  belong to the set $L \cup L_i$ remain allocated are left unchanged
  in the post-state. In any case, locations of $L$ are unchanged.
\end{itemize}

Notice that the \requires{} clauses in the behaviors are proposed
mainly to improve readibility (to avoid some duplications of
formulas), since the contract above is equivalent to the following
simplified one:
\begin{flushleft}\ttfamily
/*@ requires $P \verb|&&| (A_1 \verb|==>| R_1) \verb|&&| (A_2 \verb|==>| R_2)$; \\
~~@ assigns $L$; \\
~~@ ensures $E$; \\
~~@ behavior $b_1$: \\
~~@ ~~assumes $A_1$; \\
~~@ ~~assigns $L_1$; \\
~~@ ~~ensures $E_1$; \\
~~@ behavior $b_2$:  \\
~~@ ~~assumes $A_2$; \\
~~@ ~~assigns $L_2$; \\
~~@ ~~ensures $E_2$; \\
~~@ decreases $m$ for $R$; \\
~~@*/
\end{flushleft}

Notice that the contract does not impose that the disjunction of the
$A_i$ is true, that is it is not mandatory to provide a ``complete''
set of behaviors\footnote{Although, some tools might provide a way to check such a completeness}.

\begin{example}
\label{ex:bsearch}.
In the following, \texttt{bsearch($t,n,v$)} searches for element $v$ in array $t$ between index $0$ and $n-1$.
\input{bsearch.pp}

The intention is to perform a binary search, which requires that the
array $t$ is sorted in increasing order: this is the purpose of the
predicate named \texttt{t\_is\_sorted} in the precondition. The
remaining of the precondition is to require that the array is safely
allocated for at least the index from $0$ to $n-1$. The two named
behaviors correspond respectively to the succesful behavior and the
failing behavior.

See~\ref{sec:loop_annot} for a continuation of this example.
\end{example}

\begin{example}
  The following function illustrates the importance of different
  \assigns{} clauses for each behavior.

  \input{cond_assigns.pp}

  Its contract means that it assigns values pointed by $p$ or by $q$,
  conditionally on the sign of $n$.
\end{example}



\subsection{Memory locations}
\label{sec:locations}

There are several places where one needs to describe a set of memory locations:  in the above \assigns{} clauses of functions' contracts, or in the \reads{} clauses of Section~\ref{sec:logicspec}.

\begin{figure}
  \fbox{\begin{minipage}{0.97\textwidth}
      \input{loc.bnf}
    \end{minipage}}
  \caption{Grammar for memory locations}
\label{fig:gram:locations}
\end{figure}

The grammar for denoting such a set of memory locations is given
Figure~\ref{fig:gram:locations}.

The semantics is given as follows, where $s$ denotes any tset:
\begin{itemize}
\item a simple term denotes a singleton
\item $s\ra id$ denotes the set of $x\ra id$ for each $x \in s$
\item $s.id$ denotes the set of $x.id$ for each $x \in s$
\item $*s$ denotes the set of $*x$ for each $x \in s$
\item $s_1[s_2]$ denotes the set of $x_1[x_2]$ for each $x_1 \in s_1$
  and $x_2 \in s_2$
\item $t_1 .. t_2$ denotes the set of integers between $t_1$ and
  $t_2$, included.
\item $s_1,s_2$ denotes the union of $s_1$ and $s_2$
\item $s_1+s_2$ denotes the set of $x_1+x_2$ for each $x_1 \in s_1$ and $x_2 \in s_2$
\item $(s)$ denotes the same set as $s$
\item $\{ s \mid b ; P \}$ denotes set comprehension: set of term
  denoted by $s$ for each values of binders satisfying predicate $P$.
  Binders $b$ are bound in $s$ and $P$
\end{itemize}

A \emph{location} is any set of terms denoting a set of l-values.
Only locations are valid as argument to \assigns{} clauses

\begin{example}
  The following function sets to 0 each cell of an array.

  \input{assigns_array.pp}

  It is annotated with three equivalent \assigns{} clauses, each one
  specifying that only the set of cells $\{t[0],\ldots,t[n-1]\}$ are modified.
\end{example}

\begin{example}
  The following function increments each values stored in a linked
  list.

  \input{assigns_list.pp}

  The \assigns{} clause specifies that the set of modified memory
  locations is the set of fields $q\verb|->hd|$ for each pointer $q$
  reachable from \verb|p| following \verb|next| fields. See
  Section~\ref{sec:logicspec} for details about the declaration of the
  logic predicate \texttt{reachable}.


\end{example}

\subsection*{Typing rules for locations}

Two judgements:
\begin{itemize}
\item $\Gamma,\Lambda \vdash e : loc \tau$ means e is a set of location of type
  $tau$
\item $\Gamma,\Lambda \vdash e : tset \tau$ means e is a set of terms of type
  $tau$
\end{itemize}
$\Gamma$ is the C environment and $\Lambda$ is the logic environment.

Rules:
\[
\frac{\vdash e:loc \tau}{\vdash e: tset \tau}
\]
\[
\frac{\tau x \in \Gamma}{\vdash x: loc \tau}
\]
\[
\frac{e:tset \tau*}{\vdash *e: loc \tau}
\]
\[
\frac{e_1:tset \tau \quad e_2:tset \tau}{\vdash e_1,e_2: \tau}
\]
\[
\frac{e: tset struct S* \quad e_2:tset \tau}{\vdash e->f : loc \tau}
\]
\[
\frac{b\cup \Lambda \vdash e: tset \tau}{\vdash \{ e \mid b ; P \} : tset \tau }
\]
idem for $loc \tau$


\section{Statement annotations}

Annotations on C statements are of three kinds:
\begin{itemize}
\item Loop annotations: invariant, assigns clause, variant; allowed
  before any loop statement: \verb|while|, \verb|for|, and
  \verb|do...while|.
\item Assertions and logic labels; allowed before any C statement or
  at end of blocks.
\item Statement contracts; allowed before any C statement, specifying
  their behavior in a similar manner as C functions.
\end{itemize}

\subsection{Loop annotations}
\label{sec:loop_annot}


\begin{figure}[t]
  \begin{cadre}
    \input{loops.bnf}
  \end{cadre}
  \caption{Grammar for loop annotations}
  \label{fig:gram:loops}
\end{figure}

The syntax of loop annotations is given Figure~\ref{fig:gram:loops}
under the form of a addition to the grammar of C statements.

The semantics of loop invariants is defined as follows: a loop
annotation of the form
\begin{flushleft}\ttfamily
/*@ loop invariant $I$; \\
~~@ loop assigns $L$; \\
~~@ loop variant $m$ for $R$; \\
~~@*/ \\
...
\end{flushleft}
specifies that
\begin{itemize}
\item The predicate $I$ is initially true, that is true in the state
  before entering the loop (more precisely, in the case of a
  \verb|for| loop: after the initialization expression).
\item The predicate $I$ is an inductive invariant, that is if $I$ is
  assumed true in some state where the condition $c$ is also true, and
  if execution of the loop body in that state ends normally at the end
  of the body or with a \texttt{continue} statement, $I$ is true in
  the resulting state. Notice that if the loop condition has side
  effects, these are included in the loop body in a suitable way:
  \begin{itemize}
  \item for a $\verb|while|~(c)~s$ loop, $I$ must be preserved by the side-effects of $c$ followed by $s$
  \item for a $\verb|for|(init;c;step)~s$ loop, $I$ must be preserved by the side-effects of $c$ followed by $s$ followed by step
  \item for a $\verb|do|~s~\verb|while|~(c);$ loop, $I$ must be preserved by $s$ followed by the side-effects of $c$

\item At any loop iteration, any location that was allocated before
  entering the loop, and is not member of $L$ in the current state,
  must be remain allocated and have to same value as before entering
  the loop.
\item For each loop iteration that terminates normally or with
  \texttt{continue}, the value of $m$ at end of the iteration must be
  smaller that its value at the beginning of the iteration, with
  respect to relation $R$.
\end{itemize}

Remarks:
\begin{itemize}
\item The $\old$ construct is not allowed in loop annotations. The \verb|at| form should be used to refer to another state.
\item When a loop exists with \texttt{break} or \texttt{return} or
  \texttt{goto}, it is not required that the loop invariant holds.
\end{itemize}

\begin{example}
\label{ex:bsearch2}
Here is a continuation of example~\ref{ex:bsearch}.

\input{bsearch2.pp}

\end{example}

\subsection*{Advanced loop invariants}

\experimental

\remark{Claude}{J'ai mis la semantique actuelle de Caduceus, qui n'est pas forcement la meilleure. On pourrait envisager une semantique ou l'invariant est vrai entre $s$ et $c$. d'ailleurs, la syntaxe pourrait mettre ca en avant si on pouvait poser syntaxiquement l'invariant juste avant le mot-clef while}
  \end{itemize}
\remark{Claude}{De facon generale, on pourrait autoriser de poser un invariant de boucle n'importe ou dans le corps de boucle, la semantique etant plus ou moins celle d'une assert}

\subsection*{More about termination}

Property of termination concerns both loops and recursive function
calls.  For that purpose, loops can be annotated with \emph{loop
  variants}\index{loop variant}, and functions can be annotated with
such variants too, with the \decreases{} clause.

\subsubsection*{Integer measures}

Function are annotated with integer measure with the form
\begin{flushleft}\ttfamily
//@ decreases $e$ ;
\end{flushleft}
and loops are annotated similarly with the form
\begin{flushleft}\ttfamily
//@ loop variant $e$; 
\end{flushleft}
where the logic expression $e$ has type \verb|integer|. For recursive calls, or for loops, this expression must decrease for the relation $R$ defined by
\[
R(x,y) ::= x > y ~\verb|&&|~ x \geq 0
\]
In other words, the measure must be a sequence of integers which decreases and remain non-negative, except possible for the last value of the sequence.

\begin{example}
  In example~\ref{ex:bsearch2}, the loop variant \verb|u-l| decreases
  at each iteration, and remains non-negative, except at the last
  iteration where it may become negative.
\end{example}

\subsubsection*{General measures}

More general measures on other types can be provided, using the keyword \verb|for|. For function it becomes
\begin{flushleft}\ttfamily
//@ decreases $e$ for $R$;
\end{flushleft}
and for loops:
\begin{flushleft}\ttfamily
//@ loop variant $e$ for $R$; 
\end{flushleft}
In those cases, the logic expression $e$ has some type $\tau$ and $R$ must be relation on $\tau$, that is a logic binary predicate declared by the form
\begin{flushleft}\ttfamily
//@ predicate $R(\tau~x,\tau~y) \cdots$
\end{flushleft}
(see Section~\ref{sec:logicspec} for details). Of course, to guarantee termination, it must be proved that $R$ is a well-founded relation.



\subsection{Assertions and logic labels}

\begin{figure}[t]
  \begin{cadre}
    \input{assertions.bnf}
  \end{cadre}
  \caption{Grammar for assertions}
  \label{fig:gram:assertions}
\end{figure}

The syntax of those annotations is given Figure~\ref{fig:gram:assertions} under the form of a addition to the grammar of C statements. The grammar for terms is also completed with the built-in $\at$ construct.

\begin{itemize}
\item The $\texttt{label}~id$ annotation simply allows one to refer to
  the value of some expression $e$ in the state before the statement,
  in further annotations, using the construct $\at(e,id)$
  
  \todo{Inclure dans les ghosts statement ? Mais ce n'est pas un statement...}

\item  The $\texttt{assert}~p$ clause means that $p$ must hold in the state
  before the statement.

\item The form $\texttt{for} id_1,\ldots,id_k:~\texttt{assert}~p$
  variant associates the assertion to the named behaviors $id_i$ which
  must be a behavior identifiers for the current function.  It means
  that this assertion is meant to be valid only for the considered
  behaviors.
\end{itemize}

\oldremark{Claude}{unifier les 2 derniers cas? car a-t-on besoin de
  nommer un assert en dehors d'un behavior de la fonction? Surtout que l'on peut deja ecrire assert (id : p)}

\subsection*{Assertions on return}

\experimental

These allows to pose an assertion on function's state just before it
returns, (whatever way that return occurs) where it is still possible
to refer to local variables.


\subsection{Statement contracts}
\label{sec:statement_contract}


\begin{figure}[t]
  \begin{cadre}
    \input{st_contracts.bnf}
  \end{cadre}
  \caption{Grammar for statement contracts}
  \label{fig:gram:stcontracts}
\end{figure}


The grammar for statement contracts is given
Figure~\ref{fig:gram:stcontracts}. It is very similar to function
behaviors, but without \decreases{} clause. Additionally, behavior can
refer to enclosing named behaviors, with the form \texttt{for $id$ :
  \ldots}. Such behaviors are meant to be valid only for the
corresponding function behavior, in particular only under the
corresponding \assumes{} clause.

\begin{example}
  \todo{example}
\end{example}

\section{Logic specifications}
\label{sec:logicspec}

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth} \input{logic.bnf}
    \end{minipage}}
  \caption{Grammar for logic declarations}
\label{fig:gram:logic}
\end{figure}

The language of logic expressions used in annotations can be extended
by declaration of new logic types, and new constants, logic functions
and predicates. These declarations follows the classical setting of
\emph{algebraic specifications}, in particular new functions and
predicates may be either \emph{defined} by explicit expressions, or
\emph{axiomatized} by a set of axioms. The grammer for these declarations is given Figure~\ref{fig:gram:logic}.

\remark{Claude}{``logic typedef'' au lieu de ``logic type'' ?}

\subsection{Polymorphic logic types}

We consider here a algebraic specification setting based on
multi-sorted logic, where types can be \emph{polymorphic} that is
parameterized by other types. For example, one may declare the type of
polymorphic lists as \input{listdecl.pp} and then can consider for
example list of integers (\texttt{integer list}), list of pointers
(e.g. \texttt{char* list}), list of list of reals (\texttt{real list
  list}), etc.

\subsection{Recursive logic definitions}

The explicit definitions of logic functions and predicates can be
recursive or mutually recursive.

\begin{example}
  The following logic declaration

  \input{max_index.pp}

  defines a logic function which returns the maximal index $i$ between
  $0$ and $n-1$ such that $t[i]=0$.
\end{example}

\todo{syntax for mutual recursion}

\subsection{Higher-order logic constructions}

\experimental

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth} 
      \input{higherorder.bnf}
    \end{minipage}}  
  \caption{Grammar for higher-order constructs}
\label{fig:gram:higherorder}
\end{figure}

Figure~\ref{fig:gram:higherorder} introduces new term constructs for
higher-order logic.
\begin{description}
\item[Abstraction] The term $\verb|\lambda| \tau~x_1,\ldots,x_n ; t$ denotes the $n$-ary logic function which maps $x_1,\ldots,x_n$ to $t$.
\item[Extended quantifiers] Terms $quant(t_1,t_2,t_3)$ where $quant$
  is max, min, sum, product,or \verb|num_of|, are extended
  quantifications. $t_1$ and $t_2$ must have type \verb|integer|, and
  $t_3$ must be a unary function with an integer argument, and a
  numeric value (integer or real) except for \verb|\num_of| for which
  it should have a boolean value. Their meanings are given as follows:
  \begin{eqnarray*}
    \verb|\max|(i,j,f) &=& \max \{ f(i),f(i+1), \ldots, f(j) \} \\
    \verb|\min|(i,j,f) &=& \min \{ f(i),f(i+1), \ldots, f(j) \} \\
    \verb|\sum|(i,j,f) &=& f(i)+f(i+1)+\cdots+f(j) \\
    \verb|\product|(i,j,f) &=& f(i)\times f(i+1) \times \cdots \times f(j) \\
    \verb|\num_of|(i,j,f) &=& \# \{ k \mid i \leq k \leq j ~\verb|&&|~ f(k) \} \\
&=& \verb|\sum|(i,j,\verb|\lambda|~\verb|integer|~k ; f(k) ? 1 : 0)
  \end{eqnarray*}
  If $i>j$ then \verb|\sum| and \verb|num_of| above are 0,
  \verb|\product| is 1, and \verb|\max| and \verb|\min| are
  unspecified (see Section~\ref{sec:twovaluedlogic}).
\end{description}


\begin{example}
  Function that sums the element of an array of doubles.
  \input{sum.pp}
\end{example}

\subsection{Concrete logic types}

\begin{figure}[t]
  \fbox{\begin{minipage}{0.97\linewidth}
      \input{logictypedecl.bnf}
    \end{minipage}}
  \caption{Grammar for concrete logic types and pattern-matching}
\label{fig:gram:logictype}
\end{figure}

\experimental

Logic types may not only be declared but also defined concretely, either under thr form of record types, or of sum types. These definitions may be recursive.
With record types, the field access notation $t.id$ can be used, and for sum types, a pattern-matching construction is available. The grammar rules for these additional constructions are given Figure~\ref{fig:gram:logictype}

\begin{example}
  The declaration
  \input{listdef.pp}
  introduce a concrete definition of finite lists. The logic definition
  \input{listlengthdef.pp}
  defines the length of a list by recursion and pattern-matching.
\end{example}


\subsection{Hybrid functions and predicates}

These are functions or predicates which take both C types and logic
types as arguments.

\begin{example}
  \todo{example}
\end{example}

In case of a declaration without definition, a \reads{} clause is
usually mandatory.

\begin{example}
  \todo{example}
\end{example}

\subsection{Model variables and fields}

\experimental

\begin{example}
  \todo{example}
\end{example}

\subsection{Libraries of algebraic specifications}

Predefined algebraic specifications can be provided as libraries (see
section~\ref{sec:speclibraries}), and imported using 

\input{import.pp}

\section{Pointers and physical adressing}
\label{sec:pointers}

\subsection{Memory blocks and pointer dereferencing}

\begin{itemize}
\item \baseaddr{} base address of an allocated pointer
\[
\baseaddr{} : \alpha {\tt *} \ra {\tt char *}
\]
\item \blocklength{} length of the allocated block of a pointer
\[
\blocklength{} : \alpha {\tt *} \ra {\tt size\_t}
\]

\item $\valid$ is a built-in predicate which applies to a set of terms
  of some pointer type. $\valid(s)$ is true whenever dereferencing any
  $p\in s$ is safe. 

\end{itemize}

Shortcuts:
\begin{itemize}
\item $\verb|\null|$ is an extra notation for the NULL pointer
\item $\offset(p)$ returns the offset between p and its base address

  \begin{eqnarray*}
    \offset &:& \alpha {\tt *} \ra \verb|size_t|  \\
    \offset(p) &=& (\verb|char|*)p - \baseaddr(p)
  \end{eqnarray*}
  the following property holds: for any set of pointers $s$, $\valid(s)$ if and only if for all $p\in s$:
  \[
    \offset(p) \geq 0 \land \offset(p) + \verb|sizeof|(*p) \leq \blocklength(p)
\]

\item \comparable{} (checks whether two pointers are comparable as defined
  in the ANSI standard: \todo{by benjamin})
\[
\comparable{} : \alpha {\tt *} \ra \beta {\tt *} \ra \boolean
\]

 
\end{itemize}

\subsection{Separation}

pointer separation :
\[
p \not\equiv q := \baseaddr(p) \neq \baseaddr(q) \lor |(char*)p - (char*)q| \geq \max(\sizeof(p),\sizeof(q))
\]

$\separated(loc1,..,loc_n)$ : means that for if $i\neq j$, if $x\in
loc_i$ and $y \in loc_j$ then $\&x \not\equiv \& y$

where each $loc_i$ is a set of terms as defined in
Section~\ref{sec:locations}.

\subsection{Allocation and deallocation}

\experimental

\begin{itemize}
\item built-in predicate \fresh, specifying in a post-condition that a
  pointer was not allocated in the pre-state.

\item built-in predicate \freed, specifying in a post-condition that a
  pointer was allocated in the pre-state but not anymore.
\end{itemize}

\section{Abnormal termination}

\begin{itemize}
\item C function \verb|exit(n)|. special behavior notation
  \begin{verbatim}
    exit_behavior
       assumes
       assigns
       ensures ...
  \end{verbatim}
    where in ensures clause, \result is bound to n
\end{itemize}


\section{Dependencies information}

\remark{Patrick}{ne faut-t'il pas étendre les clauses ``assigns'' aux
  clauses ``from'' de CAVEAT prenant en comptes les locations lues, et les
  expressions fonctionnelles~?}

\experimental

\begin{verbatim}
assigns Locs from Locs
\end{verbatim}

\section{Functional expressions}

\experimental

trouver une syntaxe pour introduire les noms des fonctions implicites
derriere la construction
\begin{verbatim}
assigns Locs from Locs
\end{verbatim}

\section{Data invariants}
\label{sec:invariants}

\experimental

\begin{itemize}
\item Global invariants: invariants on global variables
\item Type invariants: invariants on struct, union, typedef
\item \verb|initially|: predicates that should hold after global
  variables initialization
\end{itemize}

Examples:
\input{invariants.pp}

\subsection{Semantics}

an invariant is true when ...\cite{barnett04jot}


\section{Ghost variables and statements}
\label{sec:ghost}

\experimental

\remark{Patrick}{les ``ghost statements'' correspondent à des
instructions d'observations des variables du C. Ces instructions
ne peuvent pas modifier les variables du C, mais que les ``ghost
variables''. Cela permet d'écrire plus facilement l'observateur
adéquat à la preuve des propriétés puisque les propriétés peuvent
porter à la fois sur les variables du C et les  ``ghost variables''.
}


\input{ghost.bnf}


\section{Module constructions}

\experimental

how to encapsulate several functions...

\section{Arithmetic, Overflow}

quantification can be either on mathematical \verb|integer| or bounded
types \verb|short|, \verb|char|, etc.

we need macros \verb|\max_range|, \verb|min_range| taking a C integer
type as argument, e.g. \verb|\max_range(unsigned char) = 255|\\

\remark{Patrick}{Ces macros, types et variables sont en principe
définies dans des \texttt{.h} que la norme spécifie en grande partie
(le nom l'est, le type peut y être contraint).
Il faudrait autant que possible se raprocher de ces noms.}

section{Attribute annotations}
\label{sec:attribute_annot}

\experimental

These are annotations allowing to add attributes on variables, like regular C attributes (const, volatile, restrict).

The purpose of these are various:
\begin{itemize}
\item specific verifications, like \url{http://www.cs.umd.edu/~jfoster/cqual}
\item specific analyses, like region 
  analyses~\cite{hubert07hav} a la Cyclone~\cite{grossman02pldi}.
\item allowing to attach model variables/fields to types that are not
  structures~\cite{filliatr07queens}.
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: "main"
%%% End:
