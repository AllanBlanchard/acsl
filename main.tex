\documentclass[a4paper]{report}

\usepackage{fullpage}
\usepackage{amssymb}
\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{pst-node}

\usepackage{xspace}
\usepackage{makeidx}
\makeindex
\input{./macros}

\begin{document}

\title{ACSL: ANSI C Specification Language}

\author{P.~Baudin \and J.-C.~Filli\^atre \and Th.~Hubert \and
  C.~March\'e \and B.~Monate \and Y.~Moy \and V.~Prevosto}

\maketitle

\chapter{Introduction}

This document is a reference manual for ACSL (ANSI C Specification Language), a language proposed by the CAT project and implemented in the Frama-C platform.

In this chapter we first introduce some definitions and vocabulary, and give generalities about this specification language.

Chapter~\ref{chap:base} presents the specification language itself.

Chapter~\ref{chap:base} presents the specification language itself.


\section{Glossary}

\emph{pure} : side-effect free

\emph{behavior}: pair pre- and post-condition, assigns\\

\remark{Claude}{ce document doit etre illustré par des
exemples. Toute construction qui ne serait pas illustrée par un
exemple sera non-retenue.}

\remark{Patrick}{utiliser en priorité les constructions de JML,
ensuite les généraliser lorsque cela a un sens, et en dernier recours,
en créer de nouvelles. Il y a peut-être des constructions
du C++ ou C\# à utiliser ou à généraliser.
Idem avec les extensions de GCC.}

\section{Annotations}

In this document, we consider that annotations are given as comments
written directly into C source files, so
that source files remain compilable\footnote{Other means of attaching
  annotations to source files, without modifying them, is left to user
  tools}. Those comments must start by \verb|/*@| or \verb|//@|.

\subsection{Kinds of annotations}

\begin{itemize}
\item Global annotation:
  \begin{itemize}
  \item Function behavior. Such an annotation is inserted just before
    the declaration or the definition of a function.
    See section~\ref{sec:fn-behavior}.


  \item global invariant. This is allowed at the level of global declarations
    See section~\ref{sec:invariants}.

  \item type invariant. This allows both structure or union
    invariants, and invariants on type names introduced by \typedef.
    See section~\ref{sec:invariants}.

  \item logical specifications: logic type introduction, introduction
    or definition of logical function or predicates, axioms. Such an
    annotation is placed at the global declarations level.

  \end{itemize}

\item Statement annotation:
  \begin{itemize}
  \item \assert,\footnote{Remark about \assume clauses: current
      discussion is that it is not considered as an element of
      specification, so not present here. This should be part of proof
      management done by tools}
    logical label. These are allowed everywhere a C label
    is allowed.
    \remark{Patrick}{En C, seules les instructions peuvent être
      étiquettées. GCC étend cela aux accolades fermantes des blocs,
      y compris celle fermant le corps de fonction. On peut dire que
      l'on fait de même lorsque l'on place des annotations juste avant
      la fermerture d'un bloc.}
    \remark{Patrick}{permettre de poser une assertion sur
      la sortie de fonction quelque soit cette sortie, et d'y
      parler des paramètres, et éventuellement des variables locales
      déclarées en début de fonction.}

  \item loop annotation (invariant, variant, assign clauses) are
    allowed immediately before loop statements: \For, \While,
    \Do\ldots \While

  \item statement behavior. Very similar to a function behavior.
    Semantical condition must be checked (normal termination only, no goto going inside, no goto going outside)
    \remark{Patrick}{as-t'on droit au \old dans le \ensures
      de cette annotation~?}

  \item ghost brackets for enclosing blocks
    \remark{Patrick}{on a besoin de ``ghost brackets'' pour
      écrire du ``ghost code''. Dans ce cas on n'en fait pas un point
      à part entière ici, on en parlera dans la section~\ref{sec:ghost}.
      Par contre, on a besoin de ``logical brackets'' afin de créer un
      ``logical statement'' auquel on désire associer un ``statement
      behavior''. Faut'il en parler ici, comme on a parlé des
      ``logical label'' plus haut~?}

  \item ghost code. See section~\ref{sec:ghost}

  \end{itemize}

\item Attribute annotation:
  \remark{Patrick}{annotation permettant d'ajouter des attributs
  partout où l'on peut écrire les qualifications habituelles du
  langage C (const, volatile, restrict) pour les outils qui réalisent
  de une vérification et/ou inférence de type comme dans
  \texttt{<http://www.cs.umd.edu/\~~jfoster/cqual>}, ou lors de l'inférence de
  zones seravnt à identifier un modéle mémoire. Cela permet également de
  proposer des types logiques pour les variables de la logique
  associées à des variables du C qui soient différents des types
  proposés par défaut.}

\end{itemize}

\subsection{Parsing annotations in practice}

In JML, parsing is done by just ignoring \verb|//@|, \verb|/*@| and \verb|*/| and the level of lexing. This technique can completely modify the semantics of the C code, for example:
\begin{verbatim}
return x /*@ +1 */ ;
\end{verbatim}

In our language this has to be forbidden. Technically, current
implementation of Frama-C isolate the comments in a first step of
syntax analysis, and then parses a second time. Nevertheless, the
grammar and the corresponding parser must be carefully designed to
avoid interaction of annotations with the code. For example, in such a
code:
\begin{verbatim}
if (c) //@ assert P;
   c=1;
\end{verbatim}
the statement \verb|c=1| must be understood as the then branch of the
if. This is ensured by the grammar below, saying that \verb|assert|
annotations are not statement themselves, but attached to the
statement that follows, like C labels.

% \remark{Patrick}{ce n'est plus le cas dans Frama-C.
% Les annotations sont maintenant, tout comme les étiquettes du C,
% indissociable de l'instruction qui suit ; celle-ci pouvant être
% également annotée.
% Ensuite, tout comme avec GCC où il est possible de placer un étiquette
% juste avant de fermer un bloc, il est possible d'y placer autant
% d'annotations que désiré (avant cette éventuelle étiquette, sinon il y
% a beaucoup de confits ``shift/reduce'' et ``reduce/réduce'' à résoudre).}

\subsection{About preprocessing}

This document considers C source \emph{after} preprocessing. Tool must
decide what to do for preprocessing phase: what to do with
annotations, should macro substitution be performed or not, etc.

\subsection{About logical expressions}

Logical expressions are pure C expressions, without function
calls. Semantics is given by the classical 2-valued logic. Additional constructs exist, given in Section~\ref{sec:expressions}

\subsection{About keywords}

additional keyword of the specification language start with a
backslash, if they are used in position of a term or a predicate. But
they are not otherwise, like \ensures{}.

\chapter{Specification language}

\section{Function behavior}
\label{sec:fn-behavior}
Grammar:

\input{fn_behavior.bnf}

\remark{Patrick}{pourquoi seuls les ``behavior'' peuvent avoir un
  nom~? Ne peut-t'on pas avoir le ``ident:'' optionnel pour chacune
  des clauses~?}

semantics:

\begin{verbatim}
  requires P_1
  requires P_2
  behavior x_1: assumes A_1 ensures E_1
  behavior x_2: assumes A_2 ensures E_2
\end{verbatim}


\begin{verbatim}
 pre-condition : P_1 and P_2
 post-condition: (\old(A_1) implies E_1)
             and (\old(A_2) implies E_2)
\end{verbatim}

\remark{Yannick}{JML propose deux modes de spécification des fonctions~:
 soit à base de ``requires'' et ``ensures'', soit à base de
 ``behavior''. JML n'a pas de ``assumes'' dans les
  ``behaviors'', mais des ``requires''. Dans le cas où les deux modes
  peuvent se combiner, la sémantique est la suivante~:}

\begin{verbatim}
  requires P_1
  requires P_2
  ensures  Q_1
  ensures  Q_2
  behavior x_1: requires R_1 ensures E_1
  behavior x_2: requires R_2 ensures E_2
\end{verbatim}


\begin{verbatim}
 pre-condition : P_1 and P_2
             and (R_1 or R_2)
 post-condition: Q_1 and Q_2
             and (\old(R_1) implies E_1)
             and (\old(R_2) implies E_2)
\end{verbatim}

\remark{Patrick}{les ``behavior'' de JML présente l'avantage de
  pouvoir spécifier une fonction par cas (non exclusifs)
  et de vérifier que les cas d'appel sont spécifiés (sinon on ne peut
  vérifier la pré-condition).
  Il semble important à Airbus de pouvoir s'assurer qu'ils ont
  énoncé l'ensemble des cas.}

\remark{Yannick}{avoir ``requires'' en plus des ``assumes'' dans les
  ``behaviors'' semble utile :
la sémantique consiste à rajouter $(A_i \ra R_i)$ en conjonction de la
précondition globale}

\begin{verbatim}
  requires P_1
  requires P_2
  ensures  Q_1
  ensures  Q_2
  behavior x_1: requires R_1 assumes A_1 ensures E_1
  behavior x_2: requires R_2 assumes A_2 ensures E_2
\end{verbatim}


\begin{verbatim}
 pre-condition : P_1 and P_2
             and (A_1 implies R_1)
             and (A_2 implies R_2)
 post-condition: Q_1 and Q_2
             and (\old(A_1) implies E_1)
             and (\old(A_2) implies E_2)
\end{verbatim}



\subsection{Memory locations}
\label{sec:locations}

There are several places where one needs to describe a set of memory locations: \assigns{} clauses, \reads{} clauses.

We give now the grammar for denoting such a set of memory locations

\input{loc.bnf}

The semantics is given as follows, where $s$ denotes any tset:
\begin{itemize}
\item a simple term denotes a singleton
\item s->id denotes the set of x->id for each x in s
\item s.id denotes the set of x.id for each x in s
\item *s denotes the set of *x for each x in s
\item $s_1[s_2]$ denotes the set of $x_1[x_2]$ for each $x_1 \in s_1$ and $x_2 \in s_2$
\item t1 .. t2 denotes the set of integers between t1 and t2, included.
\item $s_1,s_2$ denotes the union of $s_1$ and $s_2$
\item $s_1+s_2$ denotes the set of $x_1+x_2$ for each $x_1 in s_1$ and $x_2 in s_2$
\item (s) denotes the same set as s
\item $\{ s \mid b ; P \}$ denotes set comprehension: set of term denoted by s foreach values of binders satisfying predicvate P. Binders b are bound in s and P.
\end{itemize}

A \emph{location} is any set of terms denoting a set of lvalues.
Only locations are valid as argument to \assigns{} clauses

Examples:
\input{assigns.pp}

\remark{Patrick}{ne faut-t'il pas étendre les clauses ``assigns'' aux
  clauses ``from'' de CAVEAT prenant en comptes les locations lues, et les
  expressions fonctionnelles~?}

\subsection{Typing rules}

Two judgements:
\begin{itemize}
\item $\Gamma,\Lambda \vdash e : loc \tau$ means e is a set of location of type
  $tau$
\item $\Gamma,\Lambda \vdash e : tset \tau$ means e is a set of terms of type
  $tau$
\end{itemize}
$\Gamma$ is the C environment and $\Lambda$ is the logic environment.

Rules:
\[
\frac{\vdash e:loc \tau}{\vdash e: tset \tau}
\]
\[
\frac{\tau x \in \Gamma}{\vdash x: loc \tau}
\]
\[
\frac{e:tset \tau*}{\vdash *e: loc \tau}
\]
\[
\frac{e_1:tset \tau \quad e_2:tset \tau}{\vdash e_1,e_2: \tau}
\]
\[
\frac{e: tset struct S* \quad e_2:tset \tau}{\vdash e->f : loc \tau}
\]
\[
\frac{b\cup \Lambda \vdash e: tset \tau}{\vdash \{ e \mid b ; P \} : tset \tau }
\]
idem for $loc \tau$

Notes:
\begin{itemize}
\item Quantification can be be made over any type (both C and
  logic types).
\item Quantification over pointers, structures, union, etc.
  are possible too. TODO: the meaning must be carefully defined.
\end{itemize}

\section{Statement annotation}

  \begin{itemize}
  \item \assert, \assume, label
  \item loop invariants (+loop assigns ?)
  \item block behaviors (normal termination only, no goto going
    inside, no goto going outside)
  \end{itemize}

\section{Expressions}
\label{sec:expressions}

logical expressions = pure C expressions, without function
  calls. always defined (2-valued logic). With additional constructs:
  \begin{itemize}
  \item values in preceedings states: \old(e) and \at(e,label).

    construct \old{} is only valid in ensures clauses of function
    specification. For loop invariants, one need to put some label and
    use the \at{} construct.
  \item returned value: \result

    valid only in ensures clauses of function
    specification.

  \item quantifications:  $\Forall \tau x; e$ and $\Exists \tau x; e$
  \item \verb|==>|, \verb|<==>|,

   \remark{Clause}{Open question:}
   \verb|=>| and \verb|<=>| instead of \verb|==>|, \verb|<==>| ?

   \remark{Patrick}{
   en C il existe le ou exclusif bit à bit (noté \texttt{\^}), mais pas
   d'implication bit à bit, ni d'équivalence.
   Coté contrôle (que l'on assimile facilement à la logique) il
   n'existe pas en C d'équivalence (car c'est l'égalité qui joue ce
   rôle), ni de ou exclusif. Ne désire-t'on pas avoir
   quelque chose du genre :}
   \begin{tabular}{cc}
    bit à bit & logique \\
    \verb|&| & \verb|&&| \\
    \verb|=>| & \verb|==>| \\
    \verb|<=>| & \verb|<==>| \\
    \verb|^| & \verb|^^|
    \end{tabular}

  \item $\Let \tau x = e \In e$ and $\If e \Then e \Else e$

  \item nommage de formules, de termes

  \end{itemize}

on veut la logique equationnelle classique, cad que l'axiome
\[
\forall x, x=x
\]
est valide. Donc on ne peut pas introduire de construction
non-déterministe comme  $(\texttt{any} x \mid P)$


Types de la logique:
\begin{itemize}
\item types mathematiques: real, integer, boolean
\item types du C
\item types logiques introduits par l'utilisateur
\end{itemize}


\subsection{Grammar of logical expressions}

\input{term.bnf}

\section{Pointers and physical adressing}

\subsection{Memory blocks and pointer dereferencing}

\begin{itemize}
\item \baseaddr{} base address of an allocated pointer
\[
\baseaddr{} : \alpha {\tt *} \ra {\tt char *} 
\]
\item \blocklength{} length of the allocated block of a pointer
\[
\blocklength{} : \alpha {\tt *} \ra {\tt size_t} 
\]

\end{itemize}

Shortcuts:
\begin{itemize}
\item offset(p) returns the offset between p ans its base address

  \begin{eqnarray*}
    offset &:& \alpha {\tt *} \ra {\tt size\_t}  \\
    offset(p) &=& (char*)p - \baseaddr(p)
  \end{eqnarray*}

\item valid(p) tells whether dereferencing p is safe  

  \begin{eqnarray*}
    valid : \alpha {\tt *} \ra {\tt boolean} \\ 
    valid(p) = offset(p) \geq 0 \land offset(p) + sizeof(*p) \leq \blocklength(p)
  \end{eqnarray*}

\item \comparable{} (checks whether two pointers are comparable as defined
  in the ANSI standard: TODO by benjamin)
\[
\comparable{} : \alpha {\tt *} \ra \beta {\tt *} \ra {\tt boolean}
\]
\end{itemize}


\subsection{Separation}

pointer separation :
\[
p \not\equiv q := \baseaddr(p) \neq \baseaddr(q) \lor |(char*)p - (char*)q| \geq \max(\sizeof(p),\sizeof(q))
\]

$\separated(loc1,..,loc_n)$ : means that for if $i\neq j$, if $x\in loc_i$ and $y \in loc_j$ then $\&x \not\equiv \& y$

where each $loc_i$ is a set of memory location as defined in Section~\ref{sec:locations}. 

\subsection{Allocation and deallocation}

{\Huge on s'est arret\'e la le 6 juin}

\fresh, \freed

\section{Termination}

termination: loop variants, function variants for recursive
  functions, for integer measures.

More general case of measures on other types: use the keyword for:

\begin{syntax}
variant ::= "variant" e "for" id
\end{syntax}
where $e$ has type $\tau$ and $id$ is a logic predicate of type $\tau,\tau \ra
prop$


\section{Logic specifications}

\begin{itemize}
\item logic specifications: introduction of new logic types,
  constants, functions, predicates and axioms.

\remark{Patrick}{\texttt{list} est-il un mot clé du langage de
  spécification~?}

\item polymorphism: for example
\begin{verbatim}
type 'a list
\end{verbatim}
\item higher-order functions: $\lambda$, \Sum, \Max, \numof
\item {\tt enum}
\item recursive types, recursive definitions
\item hybrid functions and predicates: take both C types and logic
  types as arguments.
\item model variables
\end{itemize}


\section{Abnormal termination}

\begin{itemize}
\item C function \verb|exit(n)|. special behavior notation
  \begin{verbatim}
    exit_behavior
       assumes
       assigns
       ensures ...
  \end{verbatim}
    where in ensures clause, \result is bound to n
\end{itemize}


\section{Dependencies information}

\begin{verbatim}
assigns Locs from Locs
\end{verbatim}

\section{Functional expressions}

trouver une syntaxe pour introduire les noms des fonctions implicites
derriere la construction
\begin{verbatim}
assigns Locs from Locs
\end{verbatim}

\section{Data invariants}
\label{sec:invariants}

\begin{itemize}
\item Global invariants: invariants on global variables
\item Type invariants: invariants on struct, union, typedef
\end{itemize}

Examples:
\input{invariants.pp}

\subsection{Semantics}

an invariant is true when ...\cite{barnett04jot}


\section{Ghost variables and statements}
\label{sec:ghost}

\remark{Patrick}{les ``ghost statements'' correspondent à des
instructions d'observations des variables du C. Ces instructions
ne peuvent pas modifier les variables du C, mais que les ``ghost
variables''. Cela permet d'écrire plus facilement l'observateur
adéquat à la preuve des propriétés puisque les propriétés peuvent
porter à la fois sur les variables du C et les  ``ghost variables''.
}


\input{ghost.bnf}


\section{Module constructions}

how to encapsulate several functions...


\section{Arithmetic, Overflow}


quantification can be either on mathematical \verb|integer| or bounded
types \verb|short|, \verb|char|, etc.

we need macros \verb|\max_range|, \verb|min_range| taking a C integer
type as argument, e.g. \verb|\max_range(unsigned char) = 255|\\

\remark{Patrick}{Ces marcros, types et variables sont en principe
définies dans des \texttt{.h} que la norme spécifie en grande partie
(le nom l'est, le type peut y être contraint).
Il faudrait autant que possible se raprocher de ces noms.}


\chapter{Librairies}

\section{Jessie library: logical adressing of memory blocks}

Definition: a \emph{valid} pointer is a pointer such that *p is properly
allocated.

\offsetmin, \offsetmax : $\alpha * \ra \N$

$\offsetmin(p)$: the minimum integer $i$ such that $(p+i)$ is a valid
pointer

$\offsetmax(p)$: the maximum integer $i$ such that $(p+i)$ is a valid
pointer

properties:

\[
\offsetmin(p+i) = \offsetmin(p)-i
\offsetmax(p+i) = \offsetmax(p)-i
\]

syntactic sugar:
\[
\validrange(p,i,j) := \offsetmin(p) <= i \land \offsetmax(p) >= j
\valid(p) := \validrange(p,0,0)
\]

\remark{Benjamin}{propose plutot les noms ``indexmin'' et ``indexmax'' a la place de offsetmin et offsetmax}
  
\subsection{Strings}

\strlen

Peut disparaitre

\chapter{Quick reference card}

TODO by Benjamin


\bibliographystyle{plain}
\bibliography{./biblio}
%\input{biblio-demons}

\tableofcontents

\printindex
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
