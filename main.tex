\documentclass[a4paper]{article}

\usepackage{fullpage}
\usepackage{amssymb}
\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{pst-node}

\usepackage{xspace}
\input{macros}

\begin{document}

\title{The Frama-C specification language}

\author{P.~Baudin, J.-C.~Filli\^atre, C.~March\'e, B.~Monate, Y.~Moy, V.~Prevosto}

\maketitle

\tableofcontents
\newcommand{\remark}[2]{\textsl{\begin{itemize}\item \underline{remarque} de
      {#1}~: {#2}\end{itemize}}}
\section{Introduction, glossary}

\emph{pure} : side-effect free

\emph{behavior}: pair pre- and post-condition, assigns\\

\remark{Claude}{ce document doit etre illustré par des
exemples. Toute construction qui ne serait pas illustrée par un
exemple sera non-retenue.}

\remark{Patrick}{utiliser en priorité les constructions de JML,
ensuite les généraliser lorsque cela a un sens, et en dernier recours,
en créer de nouvelles. Il y a peut-être des constructions
du C++ ou C\# à utiliser ou à généraliser.
Idem avec les extensions de GCC.}

\section{Annotations}

In this document, we consider that annotations are given as comments
written directly into C source files, so
that source files remain compilable\footnote{Other means of attaching
  annotations to source files, without modifying them, is left to user
  tools}. Those comments must start by \verb|/*@| or \verb|//@|.

\subsection{Kinds of annotations}

\begin{itemize}
\item Global annotation:
  \begin{itemize}
  \item Function behavior. Such an annotation is inserted just before
    the declaration or the definition of a function.
    See section~\ref{sec:fn-behavior}.


  \item global invariant. This is allowed at the level of global declarations
    See section~\ref{sec:invariants}.

  \item type invariant. This allows both structure or union
    invariants, and invariants on type names introduced by \typedef. 
    See section~\ref{sec:invariants}.

  \item logical specifications: logic type introduction, introduction
    or definition of logical function or predicates, axioms. Such an
    annotation is placed at the global declarations level.

  \end{itemize}

\item Statement annotation:
  \begin{itemize}
  \item \assert,\footnote{Remark about \assume clauses: current
      discussion is that it is not considered as an element of
      specification, so not present here. This should be part of proof
      management done by tools}
    logical label. These are allowed everywhere a C label
    is allowed.
    \remark{Patrick}{En C, seules les instructions peuvent être
      étiquettées. GCC étend cela aux accolades fermantes des blocs,
      y compris celle fermant le corps de fonction. On peut dire que
      l'on fait de même lorsque l'on place des annotations juste avant
      la fermerture d'un bloc.}
    \remark{Patrick}{permettre de poser une assertion sur
      la sortie de fonction quelque soit cette sortie, et d'y
      parler des paramètres, et éventuellement des variables locales
      déclarées en début de fonction.}

  \item loop annotation (invariant, variant, assign clauses) are
    allowed immediately before loop statements: \For, \While,
    \Do\ldots \While

  \item statement behavior. Very similar to a function behavior.
    Semantical condition must be checked (normal termination only, no goto going inside, no goto going outside)
    \remark{Patrick}{as-t'on droit au \old dans le \ensures
      de cette annotation~?}

  \item ghost brackets for enclosing blocks
    \remark{Patrick}{on a besoin de ``ghost brackets'' pour
      écrire du ``ghost code''. Dans ce cas on n'en fait pas un point
      à part entière ici, on en parlera dans la section~\ref{sec:ghost}.
      Par contre, on a besoin de ``logical brackets'' afin de créer un
      ``logical statement'' auquel on désire associer un ``statement
      behavior''. Faut'il en parler ici, comme on a parlé des
      ``logical label'' plus haut~?}

  \item ghost code. See section~\ref{sec:ghost}

  \end{itemize}

\item Attribute annotation:
  \remark{Patrick}{annotation permettant d'ajouter des attributs
  partout où l'on peut écrire les qualifications habituelles du
  langage C (const, volatile, restrict) pour les outils qui réalisent
  de une vérification et/ou inférence de type comme dans
  \texttt{<http://www.cs.umd.edu/\~~jfoster/cqual>}, ou lors de l'inférence de
  zones seravnt à identifier un modéle mémoire. Cela permet également de
  proposer des types logiques pour les variables de la logique
  associées à des variables du C qui soient différents des types
  proposés par défaut.}

\end{itemize}

\subsection{Parsing annotations in practice}

In JML, parsing is done by just ignoring \verb|//@|, \verb|/*@| and \verb|*/| and the level of lexing. This technique can completely modify the semantics of the C code, for example:
\begin{verbatim}
return x /*@ +1 */ ;
\end{verbatim}

In our language this has to be forbidden. Technically, current
implementation of Frama-C isolate the comments in a first step of
syntax analysis, and then parses a second time. Nevertheless, the
grammar and the corresponding parser must be carefully designed to
avoid interaction of annotations with the code. For example, in such a
code:
\begin{verbatim}
if (c) //@ assert P;
   c=1;
\end{verbatim}
the statement \verb|c=1| must be understood as the then branch of the
if. This is ensured by the grammar below, saying that \verb|assert|
annotations are not statement themselves, but attached to the
statement that follows, like C labels.

% \remark{Patrick}{ce n'est plus le cas dans Frama-C.
% Les annotations sont maintenant, tout comme les étiquettes du C,
% indissociable de l'instruction qui suit ; celle-ci pouvant être
% également annotée.
% Ensuite, tout comme avec GCC où il est possible de placer un étiquette
% juste avant de fermer un bloc, il est possible d'y placer autant
% d'annotations que désiré (avant cette éventuelle étiquette, sinon il y
% a beaucoup de confits ``shift/reduce'' et ``reduce/réduce'' à résoudre).}

\subsection{About preprocessing}

This document considers C source \emph{after} preprocessing. Tool must
decide what to do for preprocessing phase: what to do with
annotations, should macro substitution be performed or not, etc.

\subsection{About logical expressions}

Logical expressions are pure C expressions, without function
calls. Semantics is given by the classical 2-valued logic. Additional constructs exist, given in Section~\ref{sec:expressions}

\section{Function behavior}
\label{sec:fn-behavior}
Grammar:

\input{fn_behavior.bnf}

\remark{Patrick}{pourquoi seuls les ``behavior'' peuvent avoir un
  nom~? Ne peut-t'on pas avoir le ``ident:'' optionnel pour chacune
  des clauses~?}

semantics:

\begin{verbatim}
  requires P_1
  requires P_2
  behavior x_1: assumes A_1 ensures E_1
  behavior x_2: assumes A_2 ensures E_2
\end{verbatim}


\begin{verbatim}
 pre-condition : P_1 and P_2
 post-condition: (\old(A_1) implies E_1)
             and (\old(A_2) implies E_2)
\end{verbatim}

\remark{Yannick}{JML propose deux modes de spécification des fonctions~: 
 soit à base de ``requires'' et ``ensures'', soit à base de
 ``behavior''. JML n'a pas de ``assumes'' dans les
  ``behaviors'', mais des ``requires''. Dans le cas où les deux modes
  peuvent se combiner, la sémantique est la suivante~:}

\begin{verbatim}
  requires P_1
  requires P_2
  ensures  Q_1
  ensures  Q_2
  behavior x_1: requires R_1 ensures E_1
  behavior x_2: requires R_2 ensures E_2
\end{verbatim}


\begin{verbatim}
 pre-condition : P_1 and P_2 
             and (R_1 or R_2)
 post-condition: Q_1 and Q_2 
             and (\old(R_1) implies E_1) 
             and (\old(R_2) implies E_2)
\end{verbatim}

\remark{Patrick}{les ``behavior'' de JML présente l'avantage de
  pouvoir spécifier une fonction par cas (non exclusifs) 
  et de vérifier que les cas d'appel sont spécifiés (sinon on ne peut
  vérifier la pré-condition). 
  Il semble important à Airbus de pouvoir s'assurer qu'ils ont
  énoncé l'ensemble des cas.}  

\remark{Yannick}{avoir ``requires'' en plus des ``assumes'' dans les
  ``behaviors'' semble utile :
la sémantique consiste à rajouter $(A_i \ra R_i)$ en conjonction de la
précondition globale}

\begin{verbatim}
  requires P_1
  requires P_2
  ensures  Q_1
  ensures  Q_2
  behavior x_1: requires R_1 assumes A_1 ensures E_1
  behavior x_2: requires R_2 assumes A_2 ensures E_2
\end{verbatim}


\begin{verbatim}
 pre-condition : P_1 and P_2 
             and (A_1 implies R_1) 
             and (A_2 implies R_2)
 post-condition: Q_1 and Q_2 
             and (\old(A_1) implies E_1) 
             and (\old(A_2) implies E_2)
\end{verbatim}



\subsection{syntax of assigns clauses}
\label{sec:locations}

\input{loc.bnf}

semantics:
\begin{itemize}
\item a "location" denotes a set of terms.
\item only location denoting a set of lvalues are valid as argument to
  "assigns" clauses : constructs in the two first lines above denotes
  lvalues, but not the two last lines
\end{itemize}

example:
\input{assigns}

\remark{Patrick}{ne faut-t'il pas étendre les clauses ``assigns'' aux
  clauses ``from'' de CAVEAT prenant en comptes les locations lues, et les
  expressions fonctionnelles~?}

\section{Statement annotation}

  \begin{itemize}
  \item \assert, \assume, label
  \item loop invariants (+loop assigns ?)
  \item block behaviors (normal termination only, no goto going
    inside, no goto going outside)
  \end{itemize}

\section{Expressions}
\label{sec:expressions}

logical expressions = pure C expressions, without function
  calls. always defined (2-valued logic). With additional constructs:
  \begin{itemize}
  \item values in preceedings states: \old(e) and \at(e,label).

    construct \old{} is only valid in ensures clauses of function
    specification. For loop invariants, one need to put some label and
    use the \at{} construct.
  \item returned value: \result

    valid only in ensures clauses of function
    specification.

  \item quantifications:  $\Forall \tau x; e$ and $\Exists \tau x; e$
  \item \verb|==>|, \verb|<==>|,

   \remark{Clause}{Open question:}
   \verb|=>| and \verb|<=>| instead of \verb|==>|, \verb|<==>| ?

   \remark{Patrick}{
   en C il existe le ou exclusif bit à bit (noté \texttt{\^}), mais pas
   d'implication bit à bit, ni d'équivalence.
   Coté contrôle (que l'on assimile facilement à la logique) il
   n'existe pas en C d'équivalence (car c'est l'égalité qui joue ce
   rôle), ni de ou exclusif. Ne désire-t'on pas avoir
   quelque chose du genre :}
   \begin{tabular}{cc}
    bit à bit & logique \\
    \verb|&| & \verb|&&| \\
    \verb|=>| & \verb|==>| \\
    \verb|<=>| & \verb|<==>| \\
    \verb|^| & \verb|^^|
    \end{tabular}

  \item $\Let \tau x = e \In e$ and $\If e \Then e \Else e$

  \item nommage de formules, de termes

  \end{itemize}

on veut la logique equationnelle classique, cad que l'axiome
\[
\forall x, x=x
\]
est valide. Donc on ne peut pas introduire de construction
non-déterministe comme  $(\texttt{any} x \mid P)$


Types de la logique:
\begin{itemize}
\item types mathematiques: real, integer, boolean
\item types du C
\item types logiques introduits par l'utilisateur
\end{itemize}

\section{Constructions for valid pointer dereferencing, separation}

\subsection{Memory blocks: physical adressing}

\verb|\base_addr|
\verb|\blocklength|


\subsection{Memory blocks: logical adressing}

a \emph{valid} pointer is a pointer such that *p is properly
allocated.

\offsetmin, \offsetmax : $\alpha * \ra \N$

\verb|\offset_min(p)| : the minimum integer i such that (p+i) is a valid
pointer

\verb|\offset_max(p)|: the maximum integer i such that (p+i) is a valid
pointer

properties:

\[
\offsetmin(p+i) = \offsetmin(p)-i
\offsetmax(p+i) = \offsetmax(p)-i
\]

syntactic sugar:
\[
\validrange(p,i,j) := \offsetmin(p) <= i \land \offsetmax(p) >= j
\valid(p) := \validrange(p,0,0)
\]

\subsection{Strings}

\strlen

Peut disparaitre

\subsection{Separation}

pointer separation :
\[
p \not\equiv q := \baseaddr(p) \neq \baseaddr(q) \lor |(char*)p - (char*)q| \geq \max(\sizeof(p),\sizeof(q))
\]

$\separated(p1,..,p_n)$ : means that for if $i<>j, p_i \not\equiv p_j$

cette construction peut-etre etendue au cas ou les $p_i$ sont des
ensembles de locations memoires, telles que definies a la section
\ref{sec:locations}.


\section{Termination}

termination: loop variants, function variants for recursive
  functions, for integer measures.

More general case of measures on other types: use the keyword for:

\begin{syntax}
variant ::= "variant" e "for" id
\end{syntax}
where $e$ has type $\tau$ and $id$ is a logic predicate of type $\tau,\tau \ra
prop$


\section{Logic specifications}

\begin{itemize}
\item logic specifications: introduction of new logic types,
  constants, functions, predicates and axioms.

\remark{Patrick}{\texttt{list} est-il un mot clé du langage de
  spécification~?}

\item polymorphism: for example
\begin{verbatim}
type 'a list
\end{verbatim}
\item higher-order functions: $\lambda$, \Sum, \Max, \numof
\item {\tt enum}
\item recursive types, recursive definitions
\item hybrid functions and predicates: take both C types and logic
  types as arguments.
\item model variables
\end{itemize}

\section{Allocation and deallocation}

\fresh, \freed

\section{Abnormal termination}

\begin{itemize}
\item C function \verb|exit(n)|. special behavior notation
  \begin{verbatim}
    exit_behavior
       assumes
       assigns
       ensures ...
  \end{verbatim}
    where in ensures clause, \result is bound to n
\end{itemize}


\section{Dependencies information}

\begin{verbatim}
assigns Locs from Locs
\end{verbatim}

\section{Functional expressions}

trouver une syntaxe pour introduire les noms des fonctions implicites
derriere la construction
\begin{verbatim}
assigns Locs from Locs
\end{verbatim}

\section{Data invariants}
\label{sec:invariants}

\begin{itemize}
\item Global invariants: invariants on global variables
\item Type invariants: invariants on struct, union, typedef
\end{itemize}

Examples:
\input{invariants.pp}

\subsection{Semantics}

an invariant is true when ...\cite{barnett04jot}


\section{Ghost variables and statements}
\label{sec:ghost}

\remark{Patrick}{les ``ghost statements'' correspondent à des
instructions d'observations des variables du C. Ces instructions
ne peuvent pas modifier les variables du C, mais que les ``ghost
variables''. Cela permet d'écrire plus facilement l'observateur
adéquat à la preuve des propriétés puisque les propriétés peuvent 
porter à la fois sur les variables du C et les  ``ghost variables''.
}


\section{Module constructions}

how to encapsulate several functions...


\section{Arithmetic, Overflow}


quantification can be either on mathematical \verb|integer| or bounded
types \verb|short|, \verb|char|, etc.

we need macros \verb|\max_range|, \verb|min_range| taking a C integer
type as argument, e.g. \verb|\max_range(unsigned char) = 255|\\

\remark{Patrick}{Ces marcros, types et variables sont en principe
définies dans des \texttt{.h} que la norme spécifie en grande partie
(le nom l'est, le type peut y être contraint).
Il faudrait autant que possible se raprocher de ces noms.}

\bibliographystyle{plain}
\bibliography{biblio}
%\input{biblio-demons}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
