\documentclass{article}

\usepackage{amssymb}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{alltt}

\newcommand{\assert}{\texttt{assert}}
\newcommand{\assume}{\texttt{assume}}
\newcommand{\baseaddr}{\texttt{{\textbackslash}baseaddr}}
\newcommand{\boundseparated}{\texttt{{\textbackslash}bound\_separated}}
\newcommand{\Exists}{\texttt{{\textbackslash}exists}~}
\newcommand{\Forall}{\texttt{{\textbackslash}forall}~}
\newcommand{\freed}{\texttt{{\textbackslash}freed}}
\newcommand{\fresh}{\texttt{{\textbackslash}fresh}}
\newcommand{\fullseparated}{\texttt{{\textbackslash}full\_separated}}
\newcommand{\Max}{\texttt{max}}
\newcommand{\nothing}{\texttt{{\textbackslash}nothing}}
\newcommand{\numof}{\texttt{num\_of}}
\newcommand{\offsetmin}{\texttt{{\textbackslash}offset\_min}}
\newcommand{\offsetmax}{\texttt{{\textbackslash}offset\_max}}
\newcommand{\old}{\texttt{{\textbackslash}old}}
\newcommand{\at}{\texttt{{\textbackslash}at}}
\newcommand{\If}{\texttt{if}~}
\newcommand{\Then}{~\texttt{then}~}
\newcommand{\Else}{~\texttt{else}~}
\newcommand{\Let}{\texttt{let}~}
\newcommand{\In}{~\texttt{in}~}
\newcommand{\result}{\texttt{{\textbackslash}result}}
\newcommand{\separated}{\texttt{{\textbackslash}separated}}
\newcommand{\sizeof}{\texttt{sizeof}}
\newcommand{\strlen}{\texttt{{\textbackslash}str\_len}}
\newcommand{\Sum}{\texttt{sum}}
\newcommand{\valid}{\texttt{{\textbackslash}valid}}
\newcommand{\validrange}{\texttt{{\textbackslash}valid\_range}}

\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\ra}{\ensuremath{\rightarrow}}

\begin{document}

\emph{pure} : side-effect free

\emph{behavior}: pair pre- and post-condition, assigns\\

Proposition de Claude: ce document doit etre illustré par des
exemples. Toute construction qui ne serait pas illustrée par un
exemple sera non-retenue.\\

Proposition de Patrick: utiliser en priorité les constructions de JML,
ensuite les généraliser lorsque cela a un sens, et en dernier recours,
en créer de nouvelles. Il y a peut-être des constructions
du C++ ou C\# à utiliser ou à généraliser. 
Idem avec les extensions de GCC.

\section{Frama-C base level}

\subsection{Expressions}


logical expressions = pure C expressions, without function
  calls. always defined (2-valued logic). With additional constructs:
  \begin{itemize}
  \item values in preceedings states: \old(e) and \at(e,label).

    construct \old{} is only valid in ensures clauses of function
    specification. For loop invariants, one need to put some label and
    use the \at{} construct.
  \item returned value: \result

    valid only in ensures clauses of function
    specification.

  \item quantifications:  $\Forall \tau x; e$ and $\Exists \tau x; e$
  \item \verb|==>|, \verb|<==>|, 

    Open question: \verb|=>| and \verb|<=>| instead of \verb|==>|,
    \verb|<==>| ? 
\\
   Remarque de Patrick : 
   en C il existe le ou exclusif bit à bit (noté \verb|^|), mais pas
   d'implication bit à bit, ni d'équivalence.
   Coté contrôle (que l'on assimile facilement à la logique) il
   n'existe pas en C d'équivalence (car c'est l'égalité qui joue ce
   rôle), ni de ou exclusif. Ne désire-t'on pas avoir
   quelque chose du genre :\\
   \begin{tabular}{cc}
    bit à bit & logique \\
    \verb|&| & \verb|&&| \\
    \verb|=>| & \verb|==>| \\
    \verb|<=>| & \verb|<==>| \\
    \verb|^| & \verb|^^| 
  \end{tabular}

  \item $\Let \tau x = e \In e$ and $\If e \Then e \Else e$

  \item nommage de formules, de termes

  \end{itemize}

on veut la logique equationnelle classique, cad que l'axiome 
\[
\forall x, x=x
\]
est valide. Donc on ne peut pas introduire de construction
non-déterministe comme  $(\texttt{any} x \mid P)$


Types de la logique: 
\begin{itemize}
\item types mathematiques: real, integer, boolean
\item types du C
\item types logiques introduits par l'utilisateur
\end{itemize}

\subsection{Annotations}

\begin{itemize}
\item C function behaviors
\item statement annotations:
  \begin{itemize}
  \item \assert, \assume, label
  \item loop invariants (+loop assigns ?)
  \item block behaviors (normal termination only, no goto going
    inside, no goto going outside)
  \item proposition de Patrick: permettre de poser une assertion sur
    la sortie de fonction quelque soit cette sortie, et d'y
    parler des paramètres, et éventuellement des variables locales
    déclarées en début de fonction.
  \item remarque de Patrick: ces annotations peuvent être vues
    comme des étiquettes indiquant le point de programme 
    où la propriété porte. En C, toute instruction peut être
    étiquettée. GCC étend cela aux accolades fermantes des blocs,
    y compris celle fermant le corps de fonction.=On peut dire que
    l'on fait de même lorsque l'on place des annotations juste avant
    la fermerture d'un bloc.
  \end{itemize}
\item attribute annotations 
  \begin{itemize}
  \item sur proposition de Patrick afin permettre d'ajouter des attributs
  partout où l'on peut écrire les qualifications habituelles du
  langage C (const, volatile, restrict) pour les outils qui réalisent
  de une vérification et/ou inférence de type comme dans
  \verb|<http://www.cs.umd.edu/~jfoster/cqual>|, ou lors de l'inférence de
  zones seravnt à identifier un modéle mémoire. Cela permet également de
  proposer des types logiques pour les variables de la logique
  associées à des variables du C qui soient différents des types
  proposés par défaut.
  \end{itemize}
\end{itemize}


Grammar:

\begin{eqnarray*}
  fun-spec &::=& (requires-clause | fun-behavior ) * variant-clause ? \\
  requires-clause &::=& "requires" predicate \\
  variant-clause &::=& "variant" term ("for" ident)? \\
  fun-behavior &::=& "behavior" ident ":"
             (assumes-clause | assigns-clause |
              ensures-clause ) * \\
  assumes-clause &::=& "assumes" predicate \\
  assigns-clause &::=& "assigns" (location (, location) * |
  "\nothing") \\
  ensures-clause &::=& "ensures" predicate \\
  invariant-clause &::=& "invariant" predicate \\
  location &::=& (see below)
\end{eqnarray*}



semantics:

\begin{verbatim}
  requires R_j
  behavior x_i: assumes A_i ensures E_i


 pre-condition : R_1 and R_2 and ...
 post-condition : (\old(A_1 and I_1) implies E_1) and ...
\end{verbatim}


Proposition de Yannick: des requires dans les behaviors:
la semantique consiste a rajouter $(A_i \ra R_i)$ en conjonction de la
precondition globale 



Questions: "reads" clause ?

\subsection{syntax of assigns clauses}
\label{sec:locations}

\begin{alltt}
  location ::=
       var | location->id | location.id | *location
       | location[term ? .. term?] | location[term]
       |  (\Forall \(\tau\)) | (\Forall \(\tau\) x ; predicate)
       |  location + [ term? .. term? ] | location + term
\end{alltt}

semantics:
\begin{itemize}
\item a "location" denotes a set of terms.
\item only location denoting a set of lvalues are valid as argument to
  "assigns" clauses : constructs in the two first lines above denotes
  lvalues, but not the two last lines
\end{itemize}

example:

\begin{alltt}
  assigns  (\Forall struct list *p ; reachable(root,p)) -> hd
\end{alltt}

\section{Constructions for valid pointer dereferencing, separation}

\subsection{Memory blocks: physical adressing}

\verb|\base_addr|
\verb|\blocklength|


\subsection{Memory blocks: logical adressing}

a \emph{valid} pointer is a pointer such that *p is properly
allocated.

\offsetmin, \offsetmax : $\alpha * \ra \N$

\verb|\offset_min(p)| : the minimum integer i such that (p+i) is a valid
pointer

\verb|\offset_max(p)|: the maximum integer i such that (p+i) is a valid
pointer

properties:

\[
\offsetmin(p+i) = \offsetmin(p)-i
\offsetmax(p+i) = \offsetmax(p)-i
\]

syntactic sugar:
\[
\validrange(p,i,j) := \offsetmin(p) <= i \land \offsetmax(p) >= j
\valid(p) := \validrange(p,0,0)
\]

\subsection{Strings}

\strlen

Peut disparaitre

\subsection{Separation}

pointer separation :
\[
p \not\equiv q := \baseaddr(p) \neq \baseaddr(q) \lor |(char*)p - (char*)q| \geq \max(\sizeof(p),\sizeof(q))
\]

$\separated(p1,..,p_n)$ : means that for if $i<>j, p_i \not\equiv p_j$

cette construction peut-etre etendue au cas ou les $p_i$ sont des
ensembles de locations memoires, telles que definies a la section
\ref{sec:locations}. 


\section{Termination}

termination: loop variants, function variants for recursive
  functions, for integer measures.

More general case of measures on other types: use the keyword for:

\begin{eqnarray*}
&& "variant" e "for" id
\end{eqnarray*}
where $e$ has type $\tau$ and $id$ is a logic predicate of type $\tau,\tau \ra
prop$


\section{Logic specifications}

\begin{itemize}
\item logic specifications: introduction of new logic types,
  constants, functions, predicates and axioms\\

Remarque de Patrick : \verb|list| est-il un mot clé du langage de
spécification~?
\item polymorphism: for example
\begin{verbatim}
type 'a list
\end{verbatim}
\item higher-order functions: $\lambda$, \Sum, \Max, \numof
\item {\tt enum}
\item recursive types, recursive definitions
\item hybrid functions and predicates: take both C types and logic
  types as arguments.
\item model variables
\end{itemize}

\section{Allocation and deallocation}

\fresh, \freed

\section{Abnormal termination}

\begin{itemize}
\item C function \verb|exit(n)|. special behavior notation
  \begin{verbatim}
    exit_behavior
       assumes
       assigns
       ensures ...
  \end{verbatim}
    where in ensures clause, \result is bound to n
\end{itemize}


\section{Dependencies information}

\begin{verbatim}
assigns Locs from Locs
\end{verbatim}

\section{Functional expressions}

trouver une syntaxe pour introduire les noms des fonctions implicites
derriere la construction
\begin{verbatim}
assigns Locs from Locs
\end{verbatim}

\section{Data invariants}


\begin{itemize}
\item Global invariants: invariants on global variables
\item Type invariants: invariants on struct, union, typedef
\end{itemize}

semantics:

an invariant is true when ... \cite{boogie}

\section{Ghost variables and statements}

Remarque de Patrick : les ``ghost statements'' correspondent à des
instructions d'observations des variables du C. Ces instructions
ne peuvent pas modifier les variables du C, mais que les ``ghost
variables''. Cela permet d'écrire plus facilement l'observateur
adéquat à la preuve des propriétés.\\

Remarque de Patrick : Les propriétés peuvent porter à la fois sur les
variables du C et les  ``ghost variables''. 



\section{Annotations: in comments or in another file}

in JML, parsing is done by just removing the $/*@$ and $*/$. this can
completely modify the semantics: Example:
\begin{verbatim}
return x /*@ +1 */ ;
\end{verbatim}

The current option is to isolate the comments in a first step, and
then parse a second time. But the same problem may appear:
\begin{verbatim}
if (c) //@ assert P
   c=1;
\end{verbatim}
for the analyser, instruction \verb|c=1| is executed unconditionnaly.\\

Remarque de Patrick : ce n'est plus le cas dans Fram-C. 
Les annotations sont maintenant, tout comme les étiquettes du C, 
indissociable de l'instruction qui suit ; celle-ci pouvant être
également annotée.
Ensuite, tout comme avec GCC où il est possible de placer un étiquette
juste avant de fermer un bloc, il est possible d'y placer autant
d'annotations que désiré (avant cette éventuelle étiquette, sinon il y
a beaucoup de confits ``shift/reduce'' et ``reduce/réduce'' à résoudre).
 

\section{Module constructions}

how to encapsulate several functions...


\section{Arithmetic, Overflow}


quantification can be either on mathematical \verb|integer| or bounded
types \verb|short|, \verb|char|, etc.

we need macros \verb|\max_range|, \verb|min_range| taking a C integer
type as argument, e.g. \verb|\max_range(unsigned char) = 255|\\

Remarque de Patrick : Ces marcros, types et variables sont en principe
définies dans des \verb|.h| que la norme spécifie en grande partie 
(le nom l'est, le type peut y être contraint). 
Il faudrait autant que possible se raprocher de ces noms.
 
\bibliographystyle{plain}
\bibliography{biblio}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
