\documentclass{article}

\usepackage{amssymb}
\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{pst-node}

\input{macros}

\begin{document}

\title{The Frama-C specification language}

\author{P.~Baudin, J.-C.~Filli\^atre, C.~March\'e, B.~Monate, Y.~Moy, V.~Prevosto} 

\maketitle

\tableofcontents

\section{Introduction, glossary}

\emph{pure} : side-effect free

\emph{behavior}: pair pre- and post-condition, assigns\\

Proposition de Claude: ce document doit etre illustré par des
exemples. Toute construction qui ne serait pas illustrée par un
exemple sera non-retenue.\\

Proposition de Patrick: utiliser en priorité les constructions de JML,
ensuite les généraliser lorsque cela a un sens, et en dernier recours,
en créer de nouvelles. Il y a peut-être des constructions
du C++ ou C\# à utiliser ou à généraliser. 
Idem avec les extensions de GCC.


\section{Annotations}

In this document, we consider that annotations are given as comments
written directly into C source files, so
that source files remain compilable\footnote{Other means of attaching
  annotations to source files, without modifying them, is left to user
  tools}. Those comments must start by \verb|/*@| or \verb|//@|.

\subsection{Kinds of annotations}

\begin{itemize}
\item Function behavior. Such an annotation is inserted just before
  the declaration or the definition of a function.

\item Statement annotation:
  \begin{itemize}
  \item \assert, logical label. These are allowed everywhere a C label
    is allowed.\footnote{Remark about \assume clauses: current
      discussion is that it is not considered as an element of
      specification, so not present here. This should be part of proof
      management done by tools}

  \item loop annotation (invariant, variant, assign clauses) are
    allowed immediately before loop statements: \For, \While,
    \Do\ldots \While

  \item statement behavior. Very similar to a function behavior.
    Semantical condition must be checked (normal termination only, no goto going inside, no goto going outside)

  \item ghost brackets for enclosing blocks

  \item ghost code. See section~\ref{sec:ghost}

  \item logical specifications: logic type introduction, introduction
    or definition of logical function or predicates, axioms. Such an
    annotation is placed at the global declarations level.

  \item global invariant. This is allowed at the level of global declarations 

  \item type invariant. This allows both structure or union invariants, and invariants on type names introduced by \typedef. See section~\ref{sec:invariants}.


  \item proposition de Patrick: permettre de poser une assertion sur
    la sortie de fonction quelque soit cette sortie, et d'y
    parler des paramètres, et éventuellement des variables locales
    déclarées en début de fonction.

  \item remarque de Patrick: ces annotations peuvent être vues
    comme des étiquettes indiquant le point de programme 
    où la propriété porte. En C, toute instruction peut être
    étiquettée. GCC étend cela aux accolades fermantes des blocs,
    y compris celle fermant le corps de fonction.=On peut dire que
    l'on fait de même lorsque l'on place des annotations juste avant
    la fermerture d'un bloc.
  \end{itemize}
\item attribute annotations 
  \begin{itemize}
  \item sur proposition de Patrick afin permettre d'ajouter des attributs
  partout où l'on peut écrire les qualifications habituelles du
  langage C (const, volatile, restrict) pour les outils qui réalisent
  de une vérification et/ou inférence de type comme dans
  \verb|<http://www.cs.umd.edu/~jfoster/cqual>|, ou lors de l'inférence de
  zones seravnt à identifier un modéle mémoire. Cela permet également de
  proposer des types logiques pour les variables de la logique
  associées à des variables du C qui soient différents des types
  proposés par défaut.
  \end{itemize}
\end{itemize}

\subsection{Parsing annotations in practice}

In JML, parsing is done by just ignoring \verb|//@|, \verb|/*@| and \verb|*/| and the level of lexing. This technique can completely modify the semantics of the C code, for example:  
\begin{verbatim}
return x /*@ +1 */ ;
\end{verbatim}

In our language this has to be forbidden. Technically, current implementation of Frama-C isolate the comments in a first step of syntax analysis, and then parses a second time. Nevertheless, the grammar and the corresponding parser must be carefully designed to avoid interaction of annotations with the code. For example, in such a code: 
\begin{verbatim}
if (c) //@ assert P;
   c=1;
\end{verbatim}
the statement \verb|c=1| must understood as the then branch of the if. This is ensured by the grammar below, saying that \verb|assert| annotations are not statement themselves, but attached to the statement that follows, like C labels. 
 
is executed unconditionnaly.\\

% Remarque de Patrick : ce n'est plus le cas dans Frama-C. 
% Les annotations sont maintenant, tout comme les étiquettes du C, 
% indissociable de l'instruction qui suit ; celle-ci pouvant être
% également annotée.
% Ensuite, tout comme avec GCC où il est possible de placer un étiquette
% juste avant de fermer un bloc, il est possible d'y placer autant
% d'annotations que désiré (avant cette éventuelle étiquette, sinon il y
% a beaucoup de confits ``shift/reduce'' et ``reduce/réduce'' à résoudre).
 
\subsection{About preprocessing}

This document considers C source \emph{after} preprocessing. Tool must
decide what to do for preprocessing phase: what to do with
annotations, should macro substitution be performed or not, etc.

\subsection{About logical expressions}

Logical expressions are pure C expressions, without function
calls. Semantics is given by the classical 2-valued logic. Additional constructs exist, given in Section~\ref{sec:expressions}


\section{Function behavior}

Grammar:

\begin{eqnarray*}
  fun-spec &::=& (requires-clause | fun-behavior ) * variant-clause ? \\
  requires-clause &::=& \term{requires} predicate \\
  variant-clause &::=& \term{variant} term (\term{for} ident)? \\
  fun-behavior &::=& \term{behavior} ident \term{:}
             (assumes-clause | assigns-clause |
              ensures-clause ) * \\
  assumes-clause &::=& \term{assumes} predicate \\
  assigns-clause &::=& \term{assigns} (location (, location) * |
  \term{\nothing}) \\
  ensures-clause &::=& \term{ensures} predicate \\
  invariant-clause &::=& \term{invariant} predicate \\
  location &::=& (see below)
\end{eqnarray*}



semantics:

\begin{verbatim}
  requires R_j
  behavior x_i: assumes A_i ensures E_i


 pre-condition : R_1 and R_2 and ...
 post-condition : (\old(A_1 and I_1) implies E_1) and ...
\end{verbatim}


Proposition de Yannick: des requires dans les behaviors:
la semantique consiste a rajouter $(A_i \ra R_i)$ en conjonction de la
precondition globale 



Questions: "reads" clause ?

\subsection{syntax of assigns clauses}
\label{sec:locations}

\begin{eqnarray*}
  location &::=& 
       var | location->id | location.id | *location \\
       | location[term ? .. term?] | location[term] \\
       |  (\Forall \tau) | (\Forall \tau x ; predicate) \\
       |  location + [ term? .. term? ] | location + term
     \end{eqnarray*}
     
semantics:
\begin{itemize}
\item a "location" denotes a set of terms.
\item only location denoting a set of lvalues are valid as argument to
  "assigns" clauses : constructs in the two first lines above denotes
  lvalues, but not the two last lines
\end{itemize}

example:
\input{assigns}

\section{Statement annotation}

  \begin{itemize}
  \item \assert, \assume, label
  \item loop invariants (+loop assigns ?)
  \item block behaviors (normal termination only, no goto going
    inside, no goto going outside)
  \item proposition de Patrick: permettre de poser une assertion sur
    la sortie de fonction quelque soit cette sortie, et d'y
    parler des paramètres, et éventuellement des variables locales
    déclarées en début de fonction.
  \item remarque de Patrick: ces annotations peuvent être vues
    comme des étiquettes indiquant le point de programme 
    où la propriété porte. En C, toute instruction peut être
    étiquettée. GCC étend cela aux accolades fermantes des blocs,
    y compris celle fermant le corps de fonction.=On peut dire que
    l'on fait de même lorsque l'on place des annotations juste avant
    la fermerture d'un bloc.
  \end{itemize}
attribute annotations :
  \begin{itemize}
  \item sur proposition de Patrick afin permettre d'ajouter des attributs
  partout où l'on peut écrire les qualifications habituelles du
  langage C (const, volatile, restrict) pour les outils qui réalisent
  de une vérification et/ou inférence de type comme dans
  \verb|<http://www.cs.umd.edu/~jfoster/cqual>|, ou lors de l'inférence de
  zones seravnt à identifier un modéle mémoire. Cela permet également de
  proposer des types logiques pour les variables de la logique
  associées à des variables du C qui soient différents des types
  proposés par défaut.
  \end{itemize}




\section{Expressions}
\label{sec:expressions}

logical expressions = pure C expressions, without function
  calls. always defined (2-valued logic). With additional constructs:
  \begin{itemize}
  \item values in preceedings states: \old(e) and \at(e,label).

    construct \old{} is only valid in ensures clauses of function
    specification. For loop invariants, one need to put some label and
    use the \at{} construct.
  \item returned value: \result

    valid only in ensures clauses of function
    specification.

  \item quantifications:  $\Forall \tau x; e$ and $\Exists \tau x; e$
  \item \verb|==>|, \verb|<==>|, 

    Open question: \verb|=>| and \verb|<=>| instead of \verb|==>|,
    \verb|<==>| ? 
\\
   Remarque de Patrick : 
   en C il existe le ou exclusif bit à bit (noté \verb|^|), mais pas
   d'implication bit à bit, ni d'équivalence.
   Coté contrôle (que l'on assimile facilement à la logique) il
   n'existe pas en C d'équivalence (car c'est l'égalité qui joue ce
   rôle), ni de ou exclusif. Ne désire-t'on pas avoir
   quelque chose du genre :\\
   \begin{tabular}{cc}
    bit à bit & logique \\
    \verb|&| & \verb|&&| \\
    \verb|=>| & \verb|==>| \\
    \verb|<=>| & \verb|<==>| \\
    \verb|^| & \verb|^^| 
  \end{tabular}

  \item $\Let \tau x = e \In e$ and $\If e \Then e \Else e$

  \item nommage de formules, de termes

  \end{itemize}

on veut la logique equationnelle classique, cad que l'axiome 
\[
\forall x, x=x
\]
est valide. Donc on ne peut pas introduire de construction
non-déterministe comme  $(\texttt{any} x \mid P)$


Types de la logique: 
\begin{itemize}
\item types mathematiques: real, integer, boolean
\item types du C
\item types logiques introduits par l'utilisateur
\end{itemize}

\section{Constructions for valid pointer dereferencing, separation}

\subsection{Memory blocks: physical adressing}

\verb|\base_addr|
\verb|\blocklength|


\subsection{Memory blocks: logical adressing}

a \emph{valid} pointer is a pointer such that *p is properly
allocated.

\offsetmin, \offsetmax : $\alpha * \ra \N$

\verb|\offset_min(p)| : the minimum integer i such that (p+i) is a valid
pointer

\verb|\offset_max(p)|: the maximum integer i such that (p+i) is a valid
pointer

properties:

\[
\offsetmin(p+i) = \offsetmin(p)-i
\offsetmax(p+i) = \offsetmax(p)-i
\]

syntactic sugar:
\[
\validrange(p,i,j) := \offsetmin(p) <= i \land \offsetmax(p) >= j
\valid(p) := \validrange(p,0,0)
\]

\subsection{Strings}

\strlen

Peut disparaitre

\subsection{Separation}

pointer separation :
\[
p \not\equiv q := \baseaddr(p) \neq \baseaddr(q) \lor |(char*)p - (char*)q| \geq \max(\sizeof(p),\sizeof(q))
\]

$\separated(p1,..,p_n)$ : means that for if $i<>j, p_i \not\equiv p_j$

cette construction peut-etre etendue au cas ou les $p_i$ sont des
ensembles de locations memoires, telles que definies a la section
\ref{sec:locations}. 


\section{Termination}

termination: loop variants, function variants for recursive
  functions, for integer measures.

More general case of measures on other types: use the keyword for:

\begin{eqnarray*}
&& "variant" e "for" id
\end{eqnarray*}
where $e$ has type $\tau$ and $id$ is a logic predicate of type $\tau,\tau \ra
prop$


\section{Logic specifications}

\begin{itemize}
\item logic specifications: introduction of new logic types,
  constants, functions, predicates and axioms\\

Remarque de Patrick : \verb|list| est-il un mot clé du langage de
spécification~?
\item polymorphism: for example
\begin{verbatim}
type 'a list
\end{verbatim}
\item higher-order functions: $\lambda$, \Sum, \Max, \numof
\item {\tt enum}
\item recursive types, recursive definitions
\item hybrid functions and predicates: take both C types and logic
  types as arguments.
\item model variables
\end{itemize}

\section{Allocation and deallocation}

\fresh, \freed

\section{Abnormal termination}

\begin{itemize}
\item C function \verb|exit(n)|. special behavior notation
  \begin{verbatim}
    exit_behavior
       assumes
       assigns
       ensures ...
  \end{verbatim}
    where in ensures clause, \result is bound to n
\end{itemize}


\section{Dependencies information}

\begin{verbatim}
assigns Locs from Locs
\end{verbatim}

\section{Functional expressions}

trouver une syntaxe pour introduire les noms des fonctions implicites
derriere la construction
\begin{verbatim}
assigns Locs from Locs
\end{verbatim}

\section{Data invariants}
\label{sec:invariants}

\begin{itemize}
\item Global invariants: invariants on global variables
\item Type invariants: invariants on struct, union, typedef
\end{itemize}

Examples:
\input{invariants.pp}

\subsection{Semantics}

an invariant is true when ...\cite{barnett04jot}


\section{Ghost variables and statements}
\label{sec:ghost}

Remarque de Patrick : les ``ghost statements'' correspondent à des
instructions d'observations des variables du C. Ces instructions
ne peuvent pas modifier les variables du C, mais que les ``ghost
variables''. Cela permet d'écrire plus facilement l'observateur
adéquat à la preuve des propriétés.\\

Remarque de Patrick : Les propriétés peuvent porter à la fois sur les
variables du C et les  ``ghost variables''. 



\section{Module constructions}

how to encapsulate several functions...


\section{Arithmetic, Overflow}


quantification can be either on mathematical \verb|integer| or bounded
types \verb|short|, \verb|char|, etc.

we need macros \verb|\max_range|, \verb|min_range| taking a C integer
type as argument, e.g. \verb|\max_range(unsigned char) = 255|\\

Remarque de Patrick : Ces marcros, types et variables sont en principe
définies dans des \verb|.h| que la norme spécifie en grande partie 
(le nom l'est, le type peut y être contraint). 
Il faudrait autant que possible se raprocher de ces noms.
 
\bibliographystyle{plain}
%\bibliography{biblio}
\input{biblio-demons}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
