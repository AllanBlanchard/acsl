\documentclass[a4paper]{report}

\usepackage{fullpage}
\usepackage{amssymb}
\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{pst-node}
\usepackage{pstcol}

\usepackage{xspace}
\usepackage{makeidx}
\makeindex
\input{./macros}

\begin{document}

\title{ACSL: ANSI C Specification Language}

\author{P.~Baudin \and J.-C.~Filli\^atre \and Th.~Hubert \and
  C.~March\'e \and B.~Monate \and Y.~Moy \and V.~Prevosto}

\maketitle

\input{intro.pp}

\chapter{Specification language}

\section{Function behavior}
\label{sec:fn-behavior}
Grammar:

\input{fn_behavior.bnf}

\remark{Patrick}{pourquoi seuls les ``behavior'' peuvent avoir un
  nom~? Ne peut-t'on pas avoir le ``ident:'' optionnel pour chacune
  des clauses~?}

\remark{Virgile}{Changement du mot-clé des variants pour éviter un
  conflit avec les variants de boucle. Le choix du mot-clé exact reste
  à débattre}

semantics:

\begin{verbatim}
  requires P_1
  requires P_2
  behavior x_1: assumes A_1 ensures E_1
  behavior x_2: assumes A_2 ensures E_2
\end{verbatim}


\begin{verbatim}
 pre-condition : P_1 and P_2
 post-condition: (\old(A_1) implies E_1)
             and (\old(A_2) implies E_2)
\end{verbatim}

\remark{Yannick}{JML propose deux modes de spécification des fonctions~:
 soit à base de ``requires'' et ``ensures'', soit à base de
 ``behavior''. JML n'a pas de ``assumes'' dans les
  ``behaviors'', mais des ``requires''. Dans le cas où les deux modes
  peuvent se combiner, la sémantique est la suivante~:}

\begin{verbatim}
  requires P_1
  requires P_2
  ensures  Q_1
  ensures  Q_2
  behavior x_1: requires R_1 ensures E_1
  behavior x_2: requires R_2 ensures E_2
\end{verbatim}


\begin{verbatim}
 pre-condition : P_1 and P_2
             and (R_1 or R_2)
 post-condition: Q_1 and Q_2
             and (\old(R_1) implies E_1)
             and (\old(R_2) implies E_2)
\end{verbatim}

\remark{Patrick}{les ``behavior'' de JML présente l'avantage de
  pouvoir spécifier une fonction par cas (non exclusifs)
  et de vérifier que les cas d'appel sont spécifiés (sinon on ne peut
  vérifier la pré-condition).
  Il semble important à Airbus de pouvoir s'assurer qu'ils ont
  énoncé l'ensemble des cas.}

\remark{Yannick}{avoir ``requires'' en plus des ``assumes'' dans les
  ``behaviors'' semble utile :
la sémantique consiste à rajouter $(A_i \ra R_i)$ en conjonction de la
précondition globale}

\begin{verbatim}
  requires P_1
  requires P_2
  ensures  Q_1
  ensures  Q_2
  behavior x_1: requires R_1 assumes A_1 ensures E_1
  behavior x_2: requires R_2 assumes A_2 ensures E_2
\end{verbatim}


\begin{verbatim}
 pre-condition : P_1 and P_2
             and (A_1 implies R_1)
             and (A_2 implies R_2)
 post-condition: Q_1 and Q_2
             and (\old(A_1) implies E_1)
             and (\old(A_2) implies E_2)
\end{verbatim}

\subsection{Memory locations}
\label{sec:locations}

There are several places where one needs to describe a set of memory locations: \assigns{} clauses, \reads{} clauses.

We give now the grammar for denoting such a set of memory locations

\input{loc.bnf}

The semantics is given as follows, where $s$ denotes any tset:
\begin{itemize}
\item a simple term denotes a singleton
\item s->id denotes the set of x->id for each x in s
\item s.id denotes the set of x.id for each x in s
\item *s denotes the set of *x for each x in s
\item $s_1[s_2]$ denotes the set of $x_1[x_2]$ for each $x_1 \in s_1$ and $x_2 \in s_2$
\item t1 .. t2 denotes the set of integers between t1 and t2, included.
\item $s_1,s_2$ denotes the union of $s_1$ and $s_2$
\item $s_1+s_2$ denotes the set of $x_1+x_2$ for each $x_1 in s_1$ and $x_2 in s_2$
\item (s) denotes the same set as s
\item $\{ s \mid b ; P \}$ denotes set comprehension: set of term denoted by s foreach values of binders satisfying predicvate P. Binders b are bound in s and P.
\end{itemize}

A \emph{location} is any set of terms denoting a set of lvalues.
Only locations are valid as argument to \assigns{} clauses

Examples:
\input{assigns.pp}

\remark{Patrick}{ne faut-t'il pas étendre les clauses ``assigns'' aux
  clauses ``from'' de CAVEAT prenant en comptes les locations lues, et les
  expressions fonctionnelles~?}

\subsection{Typing rules}

Two judgements:
\begin{itemize}
\item $\Gamma,\Lambda \vdash e : loc \tau$ means e is a set of location of type
  $tau$
\item $\Gamma,\Lambda \vdash e : tset \tau$ means e is a set of terms of type
  $tau$
\end{itemize}
$\Gamma$ is the C environment and $\Lambda$ is the logic environment.

Rules:
\[
\frac{\vdash e:loc \tau}{\vdash e: tset \tau}
\]
\[
\frac{\tau x \in \Gamma}{\vdash x: loc \tau}
\]
\[
\frac{e:tset \tau*}{\vdash *e: loc \tau}
\]
\[
\frac{e_1:tset \tau \quad e_2:tset \tau}{\vdash e_1,e_2: \tau}
\]
\[
\frac{e: tset struct S* \quad e_2:tset \tau}{\vdash e->f : loc \tau}
\]
\[
\frac{b\cup \Lambda \vdash e: tset \tau}{\vdash \{ e \mid b ; P \} : tset \tau }
\]
idem for $loc \tau$

Notes:
\begin{itemize}
\item Quantification can be be made over any type (both C and
  logic types).
\item Quantification over pointers, structures, union, etc.
  are possible too. TODO: the meaning must be carefully defined.
\end{itemize}

\section{Statement annotation}

  \begin{itemize}
  \item \assert, \assume, label
    \remark{claude}{permettre de nommer les asserts}
  \item loop invariants (+loop assigns ?)
  \item block behaviors (normal termination only, no goto going
    inside, no goto going outside)
  \end{itemize}

\subsection{Loop annotations}

semantics of loop invariants: in particular for {\tt for} loops

\begin{syntax}
  invariant-clause ::= "loop invariant" predicate \\
\end{syntax}

loop assigns: semantics?


\section{Expressions}
\label{sec:expressions}

logical expressions = pure C expressions, without function
  calls. always defined (2-valued logic). With additional constructs:
  \begin{itemize}
  \item values in preceedings states: \old(e) and \at(e,label).

    construct \old{} is only valid in ensures clauses of function
    specification. For loop invariants, one need to put some label and
    use the \at{} construct.
  \item returned value: \result

    valid only in ensures clauses of function
    specification.

  \item quantifications:  $\Forall \tau x; e$ and $\Exists \tau x; e$
  \item \verb|==>|, \verb|<==>|,

   \remark{Clause}{Open question:}
   \verb|=>| and \verb|<=>| instead of \verb|==>|, \verb|<==>| ?

   \remark{Patrick}{
   en C il existe le ou exclusif bit à bit (noté \texttt{\^}), mais pas
   d'implication bit à bit, ni d'équivalence.
   Coté contrôle (que l'on assimile facilement à la logique) il
   n'existe pas en C d'équivalence (car c'est l'égalité qui joue ce
   rôle), ni de ou exclusif. Ne désire-t'on pas avoir
   quelque chose du genre :}
   \begin{tabular}{cc}
    bit à bit & logique \\
    \verb|&| & \verb|&&| \\
    \verb|=>| & \verb|==>| \\
    \verb|<=>| & \verb|<==>| \\
    \verb|^| & \verb|^^|
    \end{tabular}

  \item $\Let \tau x = e \In e$ and $\If e \Then e \Else e$

  \item nommage de formules, de termes

  \end{itemize}

on veut la logique equationnelle classique, cad que l'axiome
\[
\forall x, x=x
\]
est valide. Donc on ne peut pas introduire de construction
non-déterministe comme  $(\texttt{any} x \mid P)$


Types de la logique (see Section~\ref{sec:logicspec}:
\begin{itemize}
\item types mathematiques: real, integer, boolean
\item types du C
\item types logiques introduits par l'utilisateur
\end{itemize}


\subsection{Grammar of logical expressions}

\input{term.bnf}

\section{Pointers and physical adressing}

\subsection{Memory blocks and pointer dereferencing}

\begin{itemize}
\item \baseaddr{} base address of an allocated pointer
\[
\baseaddr{} : \alpha {\tt *} \ra {\tt char *}
\]
\item \blocklength{} length of the allocated block of a pointer
\[
\blocklength{} : \alpha {\tt *} \ra {\tt size\_t}
\]

\end{itemize}

Shortcuts:
\begin{itemize}
\item offset(p) returns the offset between p ans its base address

  \begin{eqnarray*}
    offset &:& \alpha {\tt *} \ra {\tt size\_t}  \\
    offset(p) &=& (char*)p - \baseaddr(p)
  \end{eqnarray*}

\item valid(p) tells whether dereferencing p is safe

  \begin{eqnarray*}
    valid : \alpha {\tt *} \ra {\tt boolean} \\
    valid(p) = offset(p) \geq 0 \land offset(p) + sizeof(*p) \leq \blocklength(p)
  \end{eqnarray*}

\item \comparable{} (checks whether two pointers are comparable as defined
  in the ANSI standard: TODO by benjamin)
\[
\comparable{} : \alpha {\tt *} \ra \beta {\tt *} \ra {\tt boolean}
\]
\end{itemize}


\subsection{Separation}

pointer separation :
\[
p \not\equiv q := \baseaddr(p) \neq \baseaddr(q) \lor |(char*)p - (char*)q| \geq \max(\sizeof(p),\sizeof(q))
\]

$\separated(loc1,..,loc_n)$ : means that for if $i\neq j$, if $x\in loc_i$ and $y \in loc_j$ then $\&x \not\equiv \& y$

where each $loc_i$ is a set of memory location as defined in Section~\ref{sec:locations}.

\subsection{Allocation and deallocation}

\experimental

\begin{itemize}
\item built-in predicate \fresh, specifying in a post-condition that a
  pointer was not allocated in the pre-state.
 
\item built-in predicate \freed, specifying in a post-condition that a
  pointer was allocated in the pre-state but not anymore.
\end{itemize}

\section{Termination}

Property of termination concerns both loops and recursive function calls. 
For that purpose, loops can be annotated with \emph{loop variants}\index{loop variant}, and functions can be annotated with such variants too.

\subsection{integer measures}

For loops:
\begin{syntax}
variant_clause ::= "loop variant" e 
\end{syntax}

For functions:
\begin{syntax}
decreases_clause ::= "decreases" e 
\end{syntax}
where $e$ has type integer

\subsection{general measures}

More general case of measures on other types: use the keyword for:

\begin{syntax}
variant_clause ::= "loop variant" e "for" id
decreases_clause ::= "decreases" e "for" id
\end{syntax}

where $e$ has type $\tau$ and $id$ is a logic predicate of type $\tau,\tau \ra
prop$ (see Section~\ref{sec:logicspec}


\section{Logic specifications}
\label{sec:logicspec}

\begin{itemize}
\item logic specifications: introduction of new logic types,
  constants, functions, predicates and axioms.

logic types can be polymorphic: for example
\begin{c}
type 'a list
\end{c}

\input{logic.bnf}

\item recursive definitions: are allowed in logic function and predicate definitions. Example:  
  \begin{c}
    logic int max\_index(int t[],int n) {
      (n==0) ? 0 :
      (t[n-1]==0) ? n : max\_index(t, n-1)
    }
  \end{c}

mutual recursion

\item predefined logic specifications can be provided as libraries (see section~\ref{sec:speclibraries}, and imported using
\begin{c}
//@ import <specfile>
\end{c}

\item higher-order functions: $\lambda$, \Sum, \Max, \numof
\item {\tt enum}, recursive types


\item hybrid functions and predicates: take both C types and logic
  types as arguments.
\item model variables
\end{itemize}


\section{Abnormal termination}

\begin{itemize}
\item C function \verb|exit(n)|. special behavior notation
  \begin{verbatim}
    exit_behavior
       assumes
       assigns
       ensures ...
  \end{verbatim}
    where in ensures clause, \result is bound to n
\end{itemize}


\section{Dependencies information}

\begin{verbatim}
assigns Locs from Locs
\end{verbatim}

\section{Functional expressions}

trouver une syntaxe pour introduire les noms des fonctions implicites
derriere la construction
\begin{verbatim}
assigns Locs from Locs
\end{verbatim}

\section{Data invariants}
\label{sec:invariants}

\begin{itemize}
\item Global invariants: invariants on global variables
\item Type invariants: invariants on struct, union, typedef
\end{itemize}

Examples:
\input{invariants.pp}

\subsection{Semantics}

an invariant is true when ...\cite{barnett04jot}


\section{Ghost variables and statements}
\label{sec:ghost}

\remark{Patrick}{les ``ghost statements'' correspondent à des
instructions d'observations des variables du C. Ces instructions
ne peuvent pas modifier les variables du C, mais que les ``ghost
variables''. Cela permet d'écrire plus facilement l'observateur
adéquat à la preuve des propriétés puisque les propriétés peuvent
porter à la fois sur les variables du C et les  ``ghost variables''.
}


\input{ghost.bnf}


\section{Module constructions}

how to encapsulate several functions...


\section{Arithmetic, Overflow}


quantification can be either on mathematical \verb|integer| or bounded
types \verb|short|, \verb|char|, etc.

we need macros \verb|\max_range|, \verb|min_range| taking a C integer
type as argument, e.g. \verb|\max_range(unsigned char) = 255|\\

\remark{Patrick}{Ces marcros, types et variables sont en principe
définies dans des \texttt{.h} que la norme spécifie en grande partie
(le nom l'est, le type peut y être contraint).
Il faudrait autant que possible se raprocher de ces noms.}


\chapter{Librairies}

\section{Jessie library: logical adressing of memory blocks}

Definition: a \emph{valid} pointer is a pointer such that *p is properly
allocated.

\offsetmin, \offsetmax : $\alpha * \ra \N$

$\offsetmin(p)$: the minimum integer $i$ such that $(p+i)$ is a valid
pointer

$\offsetmax(p)$: the maximum integer $i$ such that $(p+i)$ is a valid
pointer

properties:

\[
\offsetmin(p+i) = \offsetmin(p)-i
\offsetmax(p+i) = \offsetmax(p)-i
\]

syntactic sugar:
\[
\validrange(p,i,j) := \offsetmin(p) <= i \land \offsetmax(p) >= j
\valid(p) := \validrange(p,0,0)
\]

\remark{Benjamin}{propose plutot les noms ``indexmin'' et ``indexmax'' a la place de offsetmin et offsetmax}

\subsection{Strings}

\strlen

Peut disparaitre

\section{Memory leaks}

\experimental

Verification of absence of memory leak is outside the scope of the
specification language. On the other hand, various models could be set
up, using for example ghost variables.


\chapter{Quick reference card}

TODO by Benjamin

\section{Libraries of logic specifications}

\subsection{Library list}

\begin{verbatim}
type 'a list = ...
\end{verbatim}

\chapter{Comparison with JML}

TODO by Yannick

\begin{verbatim}
  JML                  Frama-C

  loop_invariant       loop invariant 
  decreases            loop variant

\end{verbatim}

\bibliographystyle{plain}
\bibliography{./biblio}
%\input{biblio-demons}

\tableofcontents

\printindex
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
