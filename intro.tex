\chapter{Introduction}

This document is a reference manual for ACSL, an acronym for ``ANSI C
Specification Language''. This is a specification language proposed by
the CAT
project\footnote{\url{http://www.rntl.org/projet/resume2005/cat.htm},
  TODO: referer a une page publique en anglais dont la creation a ete
  decide}, implemented in the \textsc{Frama-C} platform, which aims at
specifying behavioral properties of C source code. The main
inspiration for this language comes from the specification language of
the \textsc{Caduceus} tool~\cite{filliatre04icfem,filliatre07cav} for
deductive verification of behavioral properties of C programs. It is
itself inspired from the \emph{Java Modeling Language} (JML) which
aims at similar goals for Java source code: indeed it aims both
\emph{runtime assertion checking} and \emph{static verification} using
the \textsc{ESC/Java2} tool~\cite{ESCJava2}.

Going back further in history, JML design was guided by the general
\emph{design-by-contract} principle proposed by Bertrand Meyer, who
indeed took its own inspiration from the concepts of preconditions and
postconditions on a routine, go back at least to Dijkstra, Floyd and
Hoare in the late 60's and early 70's, and originally implemented in
the \textsc{Eiffel} language.

\section{Organization of this document}

In this preliminary chapter we introduce some definitions and
vocabulary, and discuss generalities about this specification language.

Chapter~\ref{chap:base} presents the specification language itself.

Chapter~\ref{chap:lib} presents additional informations about
\emph{libraries} of specifications.

Some features in this document are considered ``experimental'',
meaning that their syntax and semantics is still under discussion. We
also consider them as ``advanced features'' which are not supposed to
be useful for a basic use of that specification language.

A detailed table of contents is given on page~\pageref{chap:contents}

\section{Glossary}

TODO: \emph{l-value}

An expression is called \emph{pure} if it has no side-effect.

A \emph{contract} is a specification of a function, consisting of the combination of a pre-condition and a collection of \emph{behaviors}.

A \emph{behavior} is mainly a post-condition, possibly associated with
an \emph{frame clause} (called also an \emph{assigns clause} in the
following) specifying side-effects, and possible an assumption on the
pre-state om which the function is called.


\remark{Claude}{ce document doit etre illustré par des
exemples. Toute construction qui ne serait pas illustrée par un
exemple sera non-retenue.}

\remark{Patrick}{utiliser en priorité les constructions de JML,
ensuite les généraliser lorsque cela a un sens, et en dernier recours,
en créer de nouvelles. Il y a peut-être des constructions
du C++ ou C\# à utiliser ou à généraliser.
Idem avec les extensions de GCC.}

\section{Generalities about Annotations}

In this document, we consider that annotations are given as comments
written directly into C source files, so
that source files remain compilable\footnote{Other means of attaching
  annotations to source files, without modifying them, is left to user
  tools}. Those comments must start by \verb|/*@| or \verb|//@|.

\subsection{Kinds of annotations}

\begin{itemize}
\item Global annotations:
  \begin{itemize}
  \item Function contract. Such an annotation is inserted just before
    the declaration or the definition of a function.
    See section~\ref{sec:fn-behavior}.


  \item global invariant. This is allowed at the level of global declarations
    See section~\ref{sec:invariants}.

  \item type invariant. This allows both structure or union
    invariants, and invariants on type names introduced by \typedef.
    See section~\ref{sec:invariants}.

  \item logical specifications: logic type introduction, introduction
    or definition of logical function or predicates, axioms. Such an
    annotation is placed at the global declarations level.

  \end{itemize}

\item Statement annotations:
  \begin{itemize}
  \item \assert,\footnote{Remark about \assume{} clauses: current
      discussion is that it is not considered as an element of
      specification, so not present here. This should be part of proof
      management done by tools}
    logical label. These are allowed everywhere a C label
    is allowed.
    \remark{Patrick}{En C, seules les instructions peuvent être
      étiquettées. GCC étend cela aux accolades fermantes des blocs,
      y compris celle fermant le corps de fonction. On peut dire que
      l'on fait de même lorsque l'on place des annotations juste avant
      la fermerture d'un bloc.}
    \remark{Patrick}{permettre de poser une assertion sur
      la sortie de fonction quelque soit cette sortie, et d'y
      parler des paramètres, et éventuellement des variables locales
      déclarées en début de fonction.}

  \item loop annotation (invariant, variant, assign clauses) are
    allowed immediately before loop statements: \For, \While,
    \Do\ldots \While

  \item statement contract. Very similar to a function contract.
    Semantical condition must be checked (normal termination only, no
    goto going inside, no goto going outside) \remark{Patrick}{as-t'on
      droit au \old dans le \ensures de cette annotation~? Oui, pour
      refer a l'etat avant le statement consider\'er}

  \item ghost brackets for enclosing blocks
    \remark{Patrick}{on a besoin de ``ghost brackets'' pour
      écrire du ``ghost code''. Dans ce cas on n'en fait pas un point
      à part entière ici, on en parlera dans la section~\ref{sec:ghost}.
      Par contre, on a besoin de ``logical brackets'' afin de créer un
      ``logical statement'' auquel on désire associer un ``statement
      behavior''. Faut'il en parler ici, comme on a parlé des
      ``logical label'' plus haut~?}

  \item ghost code. See section~\ref{sec:ghost}

  \end{itemize}

\item Attribute annotations:
  \remark{Patrick}{annotation permettant d'ajouter des attributs
  partout où l'on peut écrire les qualifications habituelles du
  langage C (const, volatile, restrict) pour les outils qui réalisent
  de une vérification et/ou inférence de type comme dans
  \texttt{<http://www.cs.umd.edu/\~~jfoster/cqual>}, ou lors de l'inférence de
  zones seravnt à identifier un modéle mémoire. Cela permet également de
  proposer des types logiques pour les variables de la logique
  associées à des variables du C qui soient différents des types
  proposés par défaut.}

\end{itemize}

\subsection{Parsing annotations in practice}

In JML, parsing is done by just ignoring \verb|//@|, \verb|/*@| and \verb|*/| and the level of lexing. This technique can completely modify the semantics of the C code, for example:
\input{annot1.pp}

In our language this has to be forbidden. Technically, current
implementation of Frama-C isolate the comments in a first step of
syntax analysis, and then parses a second time. Nevertheless, the
grammar and the corresponding parser must be carefully designed to
avoid interaction of annotations with the code. For example, in such a
code:
\input{annot2.pp}
the statement \verb|c=1| must be understood as the \texttt{then} branch of the
\texttt{if}. This is ensured by the grammar below, saying that \verb|assert|
annotations are not statement themselves, but attached to the
statement that follows, like C labels.

\subsection{About preprocessing}

This document considers C source \emph{after} preprocessing. Tools must
decide what to do for preprocessing phase: what to do with
annotations, should macro substitution be performed or not, etc.

\subsection{About logical expressions}

Logical expressions are pure C expressions, without function calls.
Semantics is given by the classical 2-valued logic. Additional
constructs exist, given in Section~\ref{sec:expressions}

\subsection{About keywords}

Additional keywords of the specification language start with a
backslash, if they are used in position of a term or a predicate. Otherwise
they do not start with a backslash, like \ensures{}.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
