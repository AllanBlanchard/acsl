\chapter{Introduction}

This document is a reference manual for ACSL (ANSI C Specification Language), a language proposed by the CAT project and implemented in the Frama-C platform.

In this chapter we first introduce some definitions and vocabulary, and give generalities about this specification language.

Some features in this document are considered ``experimental'', meaning that their syntax and semantics is still under discussion. We also consider them as ``advanced features'' which are not supposed to be useful for a basic use of that specification language

Chapter~\ref{chap:base} presents the specification language itself.

Chapter~\ref{chap:base} presents the specification language itself.


\section{Glossary}

\emph{pure} : side-effect free

\emph{behavior}: pair pre- and post-condition, assigns\\

\remark{Claude}{ce document doit etre illustré par des
exemples. Toute construction qui ne serait pas illustrée par un
exemple sera non-retenue.}

\remark{Patrick}{utiliser en priorité les constructions de JML,
ensuite les généraliser lorsque cela a un sens, et en dernier recours,
en créer de nouvelles. Il y a peut-être des constructions
du C++ ou C\# à utiliser ou à généraliser.
Idem avec les extensions de GCC.}

\section{Annotations}

In this document, we consider that annotations are given as comments
written directly into C source files, so
that source files remain compilable\footnote{Other means of attaching
  annotations to source files, without modifying them, is left to user
  tools}. Those comments must start by \verb|/*@| or \verb|//@|.

\subsection{Kinds of annotations}

\begin{itemize}
\item Global annotation:
  \begin{itemize}
  \item Function behavior. Such an annotation is inserted just before
    the declaration or the definition of a function.
    See section~\ref{sec:fn-behavior}.


  \item global invariant. This is allowed at the level of global declarations
    See section~\ref{sec:invariants}.

  \item type invariant. This allows both structure or union
    invariants, and invariants on type names introduced by \typedef.
    See section~\ref{sec:invariants}.

  \item logical specifications: logic type introduction, introduction
    or definition of logical function or predicates, axioms. Such an
    annotation is placed at the global declarations level.

  \end{itemize}

\item Statement annotation:
  \begin{itemize}
  \item \assert,\footnote{Remark about \assume clauses: current
      discussion is that it is not considered as an element of
      specification, so not present here. This should be part of proof
      management done by tools}
    logical label. These are allowed everywhere a C label
    is allowed.
    \remark{Patrick}{En C, seules les instructions peuvent être
      étiquettées. GCC étend cela aux accolades fermantes des blocs,
      y compris celle fermant le corps de fonction. On peut dire que
      l'on fait de même lorsque l'on place des annotations juste avant
      la fermerture d'un bloc.}
    \remark{Patrick}{permettre de poser une assertion sur
      la sortie de fonction quelque soit cette sortie, et d'y
      parler des paramètres, et éventuellement des variables locales
      déclarées en début de fonction.}

  \item loop annotation (invariant, variant, assign clauses) are
    allowed immediately before loop statements: \For, \While,
    \Do\ldots \While

  \item statement behavior. Very similar to a function behavior.
    Semantical condition must be checked (normal termination only, no goto going inside, no goto going outside)
    \remark{Patrick}{as-t'on droit au \old dans le \ensures
      de cette annotation~?}

  \item ghost brackets for enclosing blocks
    \remark{Patrick}{on a besoin de ``ghost brackets'' pour
      écrire du ``ghost code''. Dans ce cas on n'en fait pas un point
      à part entière ici, on en parlera dans la section~\ref{sec:ghost}.
      Par contre, on a besoin de ``logical brackets'' afin de créer un
      ``logical statement'' auquel on désire associer un ``statement
      behavior''. Faut'il en parler ici, comme on a parlé des
      ``logical label'' plus haut~?}

  \item ghost code. See section~\ref{sec:ghost}

  \end{itemize}

\item Attribute annotation:
  \remark{Patrick}{annotation permettant d'ajouter des attributs
  partout où l'on peut écrire les qualifications habituelles du
  langage C (const, volatile, restrict) pour les outils qui réalisent
  de une vérification et/ou inférence de type comme dans
  \texttt{<http://www.cs.umd.edu/\~~jfoster/cqual>}, ou lors de l'inférence de
  zones seravnt à identifier un modéle mémoire. Cela permet également de
  proposer des types logiques pour les variables de la logique
  associées à des variables du C qui soient différents des types
  proposés par défaut.}

\end{itemize}

\subsection{Parsing annotations in practice}

In JML, parsing is done by just ignoring \verb|//@|, \verb|/*@| and \verb|*/| and the level of lexing. This technique can completely modify the semantics of the C code, for example:
\begin{c}
return x /*@ +1 */ ;
\end{c}

In our language this has to be forbidden. Technically, current
implementation of Frama-C isolate the comments in a first step of
syntax analysis, and then parses a second time. Nevertheless, the
grammar and the corresponding parser must be carefully designed to
avoid interaction of annotations with the code. For example, in such a
code:
\begin{c}
if (c) //@ assert P;
   c=1;
\end{c}
the statement \verb|c=1| must be understood as the then branch of the
if. This is ensured by the grammar below, saying that \verb|assert|
annotations are not statement themselves, but attached to the
statement that follows, like C labels.

% \remark{Patrick}{ce n'est plus le cas dans Frama-C.
% Les annotations sont maintenant, tout comme les étiquettes du C,
% indissociable de l'instruction qui suit ; celle-ci pouvant être
% également annotée.
% Ensuite, tout comme avec GCC où il est possible de placer un étiquette
% juste avant de fermer un bloc, il est possible d'y placer autant
% d'annotations que désiré (avant cette éventuelle étiquette, sinon il y
% a beaucoup de confits ``shift/reduce'' et ``reduce/réduce'' à résoudre).}

\subsection{About preprocessing}

This document considers C source \emph{after} preprocessing. Tool must
decide what to do for preprocessing phase: what to do with
annotations, should macro substitution be performed or not, etc.

\subsection{About logical expressions}

Logical expressions are pure C expressions, without function
calls. Semantics is given by the classical 2-valued logic. Additional constructs exist, given in Section~\ref{sec:expressions}

\subsection{About keywords}

additional keyword of the specification language start with a
backslash, if they are used in position of a term or a predicate. But
they are not otherwise, like \ensures{}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
