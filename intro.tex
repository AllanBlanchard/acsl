\chapter{Introduction}

This document is a reference manual for ACSL, an acronym for ``ANSI C
Specification Language''. This is a Behavioral Interface Specification
Language (aka BISL) implemented in the \textsc{Frama-C} framework. As
its name suggests it, it aims at specifying behavioral properties of C
source code. The main inspiration for this language comes from the
specification language of the \textsc{Caduceus}
tool~\cite{filliatre04icfem,filliatre07cav} for deductive verification
of behavioral properties of C programs. It is itself inspired from the
\emph{Java Modeling Language} (JML~\cite{leavens00jml}) which aims at
similar goals for Java source code: indeed it aims both at
\emph{runtime assertion checking} and \emph{static verification} using
the \textsc{ESC/Java2} tool~\cite{ESCJava2}, where we aim at
\emph{static verification} and \emph{deductive verification} (see
Appendix~\ref{sec:comp-jml} for a detailed comparison between ACSL and
JML).

Going back further in history, JML design was guided by the general
\emph{design-by-contract} principle proposed by Bertrand Meyer, who
took his own inspiration from the concepts of preconditions and
postconditions on a routine, going back at least to Dijkstra, Floyd and
Hoare in the late 60's and early 70's, and originally implemented in
the \textsc{Eiffel} language.

In this document, we assume that the reader has a good knowledge of
the ANSI C programming language~\cite{KR88,standardc99}.

\section{Organization of this document}

In this preliminary chapter we introduce some definitions and
vocabulary, and discuss generalities about this specification
language.  Chapter~\ref{chap:base} presents the specification language
itself.  Chapter~\ref{chap:lib} presents additional informations about
\emph{libraries} of specifications.  Chapter~\ref{chap:appendix}
finally provides a few additional information.  A detailed table of
contents is given on page~\pageref{chap:contents}

\section{Glossary}

\begin{description}
\item[pure expressions] \index{pure expression} In ACSL setting, a
  \emph{pure} expression is a C expression which contains no assignments, no
  incrementation operator \verb|++| or \verb|--|, no function call,
  and no access to a volatile object. The set of pure expression is a
  subset of the set of C expressions without side effect (C
  standard~\cite{KR88,standardc99}, \S 5.1.2.3, alinea 2).

\item[left-values] \index{left-value}\index{lvalue} 

  A \emph{left-value} (\emph{lvalue} for short) is an expression which
  denotes some place in the memory during program execution, either on
  the stack, on the heap, or in the static data segment. It can be
  either a variable identifier or an expression of the form $*e$,
  $e[e]$, $e\verb|.|id$ or $e\verb|->|id$, where $e$ is any expression
  and $id$ a field name. See C standard, \S 6.3.2.1 for a more
  detailed description of lvalues.

  A \emph{modifiable lvalue} is an lvalue allowed in the left part of
  an assignment.
 
\item[pre-state and post-state]
    \index{pre-state}\index{post-state}
    
    For a given function call, the \emph{pre-state} denotes the
    program state at the beginning of the call, including the
    current values for the function parameters. the \emph{post-state}
    denotes the program state at the return of the call.

\item[function behavior] \index{function behavior} \index{behavior}

  A \emph{function behavior} (\emph{behavior} for short) is a set of
  properties relating the pre-state and the post-state for a
  possibly restricted set of pre-states (behavior \emph{assumptions}).

\item[function contract] \index{function contract} \index{contract} 

  A \emph{function contract} (\emph{contract} for short) forms a
  specification of a function, consisting of the combination of a
  precondition (a requirement on the pre-state for any caller to that
  function), a collection of behaviors, and possibly a measure in case
  of a recursive function.

\end{description}

\oldremark{Claude}{ce document doit etre illustré par des
exemples. Toute construction qui ne serait pas illustrée par un
exemple sera non-retenue.}

\oldremark{Patrick}{utiliser en priorité les constructions de JML,
ensuite les généraliser lorsque cela a un sens, et en dernier recours,
en créer de nouvelles. Il y a peut-être des constructions
du C++ ou C\# à utiliser ou à généraliser.
Idem avec les extensions de GCC.}

\section{Generalities about Annotations}

In this document, we consider that specifications are given as annotations 
in comments written directly in C source files, so that source files remain
compilable\footnote{Other means of attaching annotations to source
  files, without modifying them, are left to user tools.}. Those
comments must start by \verb|/*@| or \verb|//@| and end as usual in~C.

\subsection{Kinds of annotations}

\begin{itemize}
\item Global annotations:
  \begin{itemize}
  \item function contract. Such an annotation is inserted just before
    the declaration or the definition of a function.
    See section~\ref{sec:fn-behavior}.

  \item global invariant. This is allowed at the level of global declarations.
    See section~\ref{sec:invariants}.

  \item type invariant. This allows both structure or union
    invariants, and invariants on type names introduced by \typedef.
    See section~\ref{sec:invariants}.

  \item logic specifications: logic type introduction, introduction
    or definition of logic functions or predicates, axioms. Such an
    annotation is placed at the level of global declarations.

  \end{itemize}

\item Statement annotations:
  \begin{itemize}
  \item \assert clause. These are allowed
    everywhere a C label is allowed, or just before a
    block closing brace.  
    \oldremark{Claude}{About \assume{} clauses: current
      discussion is that it is not considered as an element of
      specification, so not present here. This should be part of proof
      management done by tools.} 
    \oldremark{Patrick}{En C, seules les
      instructions peuvent être étiquettées. GCC étend cela aux
      accolades fermantes des blocs, y compris celle fermant le corps
      de fonction. On peut dire que l'on fait de même lorsque l'on
      place des annotations juste avant la fermerture d'un bloc.}
    
  \item loop annotation (invariant, variant, assign clauses) is
    allowed immediately before a loop statement: \For, \While,
    \Do\ldots \While. See Section~\ref{sec:loop_annot}

  \item statement contract. Very similar to a function contract, and
    placed before a statement or a block.  Semantical condition must
    be checked (normal termination only, no goto going inside, no goto
    going outside).  See Section~\ref{sec:statement_contract}
    \oldremark{Patrick}{as-t'on droit au \old dans le \ensures de
      cette annotation~? Oui, pour refer a l'etat avant le statement
      consider\'e}
    
  \item ghost code: is regular C code, only visible from the
    specification, that is only allowed to modify ghost variables. See
    section~\ref{sec:ghost}. This includes ghost braces for enclosing blocks.

  \end{itemize}

%\item Attribute annotations: \experimental. See
%  Section~\ref{sec:attribute_annot}.

\end{itemize}

\subsection{Parsing annotations in practice}

In JML, parsing is done by just ignoring \verb|//@|, \verb|/*@| and
\verb|*/| and the level of lexing. This technique could modify the
semantics of the C code, for example: \input{annot1.pp}

In our language this is forbidden. Technically, the current
implementation of Frama-C isolates the comments in a first step of
syntax analysis, and then parses a second time. Nevertheless, the
grammar and the corresponding parser must be carefully designed to
avoid interaction of annotations with the code. For example, in such a
code: 
\input{annot2.pp} 
the statement \verb|c=1| must be understood as the \texttt{then}
branch of the \texttt{if}. This is ensured by the grammar below,
saying that \verb|assert| annotations are not statement themselves,
but attached to the statement that follows, like C labels.

\subsection{About preprocessing}

This document considers C source \emph{after} preprocessing. Tools
must decide what to do for preprocessing phase: what to do with
annotations, should macro substitution be performed or not, etc.

\subsection{About keywords}

Additional keywords of the specification language start with a
backslash, if they are used in position of a term or a predicate
(which are defined in the following).  Otherwise they do not start
with a backslash (like \ensures{}) and they remains valid identifiers.


\section{Notations for grammars}

In this document, grammar rules are given in BNF form. In grammar
rules, we use extra notations $e^*$ to denote repetition of zero, one
or more occurrences of $e$, $e^+$ for repetition of one or more
occurrences of $e$, $e^?$ for zero or one occurrence of $e$.



%%% Local Variables:
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: "main"
%%% End:
