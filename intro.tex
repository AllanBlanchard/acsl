\chapter{Introduction}

This document is a reference manual for ACSL, an acronym for ``ANSI C
Specification Language''. This is a specification language proposed by
the CAT
project\footnote{\url{http://www.rntl.org/projet/resume2005/cat.htm},
  \todo{referer a une page publique en anglais dont la creation a ete
  decide}}, implemented in the \textsc{Frama-C} platform, which aims at
specifying behavioral properties of C source code. The main
inspiration for this language comes from the specification language of
the \textsc{Caduceus} tool~\cite{filliatre04icfem,filliatre07cav} for
deductive verification of behavioral properties of C programs. It is
itself inspired from the \emph{Java Modeling Language} (JML) which
aims at similar goals for Java source code: indeed it aims both
\emph{runtime assertion checking} and \emph{static verification} using
the \textsc{ESC/Java2} tool~\cite{ESCJava2}.

Going back further in history, JML design was guided by the general
\emph{design-by-contract} principle proposed by Bertrand Meyer, who
indeed took its own inspiration from the concepts of preconditions and
postconditions on a routine, going back at least to Dijkstra, Floyd and
Hoare in the late 60's and early 70's, and originally implemented in
the \textsc{Eiffel} language.

In this document, we assume that the reader has a good knowledge of
the ANSI C programming language~\cite{KR88}.

\section{Organization of this document}

In this preliminary chapter we introduce some definitions and
vocabulary, and discuss generalities about this specification language.

Chapter~\ref{chap:base} presents the specification language itself.

Chapter~\ref{chap:lib} presents additional informations about
\emph{libraries} of specifications.

A detailed table of contents is given on page~\pageref{chap:contents}

\subsection*{Experimental features}

Some features in this document are considered \emph{experimental},
meaning that their syntax and semantics is still under discussion.
These features are marked with \experimental.

They must also be considered as ``advanced features'' which are not
supposed to be useful for a basic use of that specification language.


\section{Glossary}

\begin{description}
\item[pure expressions] \index{pure expression} A C expression is
  called \emph{pure} if it has no side-effect: no assignments, no
  incrementation operator \verb|++| or \verb|--|. Moreover it should
  not contain any function call, even if the called function has no
  side-effect itself.

\item[memory locations and left-values] \index{memory location}
  \index{left value}\index{l-value} A \emph{memory location} is an
  expression which denotes some place in the memory during program
  execution, either on the stack, on the heap, or in the static data
  segment. It can be either a variable identifier or an expression of
  the form $*e$, $e[e]$, $e\verb|.|id$ or $e\verb|->|id$.

  A \emph{left value}, or \emph{l-value} for short, is a memory
  location allowed in the left part of an assignment, that is a
  non-constant memory location.
 
\item[pre-state and post-state]
    \index{pre-state}\index{post-state}
    
    For a given function call, the \emph{pre-state} denotes the
    program's state at the beginning of the call, including the
    current values for the function parameters. the \emph{post-state}
    denotes the program's state at the return of the call.

\item[function behavior] \index{function behavior} \index{behavior}

  A \emph{function behavior} is a set of properties relating the
  pre-state and the post-state for any call to that function.

\item[contract] \index{contract} A \emph{contract} forms a
  specification of a function, consisting of the combination of a
  pre-condition (an assumption about the pre-state) and a collection
  of behaviors.

\end{description}

\oldremark{Claude}{ce document doit etre illustré par des
exemples. Toute construction qui ne serait pas illustrée par un
exemple sera non-retenue.}

\oldremark{Patrick}{utiliser en priorité les constructions de JML,
ensuite les généraliser lorsque cela a un sens, et en dernier recours,
en créer de nouvelles. Il y a peut-être des constructions
du C++ ou C\# à utiliser ou à généraliser.
Idem avec les extensions de GCC.}

\section{Generalities about Annotations}

In this document, we consider that annotations are given as comments
written directly into C source files, so
that source files remain compilable\footnote{Other means of attaching
  annotations to source files, without modifying them, is left to user
  tools}. Those comments must start by \verb|/*@| or \verb|//@|.

\subsection{Kinds of annotations}

\begin{itemize}
\item Global annotations:
  \begin{itemize}
  \item Function contract. Such an annotation is inserted just before
    the declaration or the definition of a function.
    See section~\ref{sec:fn-behavior}.


  \item global invariant. This is allowed at the level of global declarations
    See section~\ref{sec:invariants}.

  \item type invariant. This allows both structure or union
    invariants, and invariants on type names introduced by \typedef.
    See section~\ref{sec:invariants}.

  \item logic specifications: logic type introduction, introduction
    or definition of logic functions or predicates, axioms. Such an
    annotation is placed at the global declarations level.

  \end{itemize}

\item Statement annotations:
  \begin{itemize}
  \item \assert,\oldremark{Claude}{about \assume{} clauses: current
      discussion is that it is not considered as an element of
      specification, so not present here. This should be part of proof
      management done by tools}
    logic label. These are allowed everywhere a C label
    is allowed, or exceptionally just before a block closing brace.
    \oldremark{Patrick}{En C, seules les instructions peuvent être
      étiquettées. GCC étend cela aux accolades fermantes des blocs,
      y compris celle fermant le corps de fonction. On peut dire que
      l'on fait de même lorsque l'on place des annotations juste avant
      la fermerture d'un bloc.}

  \item loop annotation (invariant, variant, assign clauses) is
    allowed immediately before a loop statement: \For, \While,
    \Do\ldots \While. See Section~\ref{sec:loop_annot}

  \item statement contract. Very similar to a function contract.
    Semantical condition must be checked (normal termination only, no
    goto going inside, no goto going outside) \oldremark{Patrick}{as-t'on
      droit au \old dans le \ensures de cette annotation~? Oui, pour
      refer a l'etat avant le statement consider\'e}
See Section~\ref{sec:statement_contract}


  \item ghost code: is regular C-code, only visible from the
    specification, that is only allowed to modify ghost variables. See
    section~\ref{sec:ghost}.

  \item ghost braces for enclosing blocks
    \remark{Patrick}{on a besoin de ``ghost braces'' pour
      écrire du ``ghost code''. Dans ce cas on n'en fait pas un point
      à part entière ici, on en parlera dans la section~\ref{sec:ghost}.
      Par contre, on a besoin de ``logic braces'' afin de créer un
      ``logic statement'' auquel on désire associer un ``statement
      behavior''. Faut'il en parler ici, comme on a parlé des
      ``logic label'' plus haut~?}


  \end{itemize}

\item Attribute annotations: \experimental. See Section~\ref{sec:attribute_annot}.


\end{itemize}

\subsection{Parsing annotations in practice}

In JML, parsing is done by just ignoring \verb|//@|, \verb|/*@| and \verb|*/| and the level of lexing. This technique can completely modify the semantics of the C code, for example:
\input{annot1.pp}

In our language this has to be forbidden. Technically, current
implementation of Frama-C isolate the comments in a first step of
syntax analysis, and then parses a second time. Nevertheless, the
grammar and the corresponding parser must be carefully designed to
avoid interaction of annotations with the code. For example, in such a
code:
\input{annot2.pp}
the statement \verb|c=1| must be understood as the \texttt{then} branch of the
\texttt{if}. This is ensured by the grammar below, saying that \verb|assert|
annotations are not statement themselves, but attached to the
statement that follows, like C labels.

\subsection{About preprocessing}

This document considers C source \emph{after} preprocessing. Tools must
decide what to do for preprocessing phase: what to do with
annotations, should macro substitution be performed or not, etc.

\subsection{About logical expressions}

Logical expressions are pure C expressions, without function calls.
Semantics is given by the classical 2-valued logic. Additional
constructs exist, given in Section~\ref{sec:expressions}

\subsection{About keywords}

Additional keywords of the specification language start with a
backslash, if they are used in position of a term or a predicate. Otherwise
they do not start with a backslash, like \ensures{}.

\subsection{Notations for grammar}

In this document, grammar rules are given in BNF form. In grammar
rules, we use extra notations $e^*$ to denote repetition of zero, one
or more occurrences of $e$, $e^+$ for repetition of one or more
occurrences of $e$, $e^?$ for zero or one occurrence of $e$.



%%% Local Variables:
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: "main"
%%% End:
